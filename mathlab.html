<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MathLab (GeoGebra-like) - Single HTML</title>

  <!-- KaTeX (LaTeX 렌더링) -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>

  <style>
    :root{
      --bg:#0b0f14;
      --border:#24314a;
      --text:#e8eefc;
      --muted:#aab6d1;
      --accent:#5aa2ff;
      --danger:#ff5a7a;
      --shadow:0 12px 40px rgba(0,0,0,.45);
      --btnRadius:12px;
      --font: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans KR", Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    html,body{
      margin:0; height:100%;
      background:var(--bg);
      color:var(--text);
      font-family:var(--font);
      overflow:hidden;
      user-select:none;
    }

    #app{ position:fixed; inset:0; display:flex; flex-direction:column; }

    #topbar{
      display:flex; align-items:center; gap:10px;
      padding:10px 12px;
      background:linear-gradient(180deg, rgba(18,24,38,.95), rgba(18,24,38,.70));
      border-bottom:1px solid var(--border);
      backdrop-filter: blur(10px);
      z-index:10;
    }

    .group{
      display:flex; gap:8px; align-items:center;
      padding:6px;
      background:rgba(15,21,34,.55);
      border:1px solid rgba(36,49,74,.65);
      border-radius:16px;
    }

    .btn{
      appearance:none;
      border:1px solid rgba(36,49,74,.9);
      background:rgba(18,24,38,.65);
      color:var(--text);
      padding:9px 10px;
      border-radius:var(--btnRadius);
      cursor:pointer;
      font-size:13px;
      line-height:1;
      display:inline-flex;
      align-items:center;
      gap:8px;
      transition: transform .05s ease, background .15s ease, border-color .15s ease;
    }
    .btn:hover{ background:rgba(24,32,52,.75); border-color:rgba(90,162,255,.6); }
    .btn:active{ transform: translateY(1px); }
    .btn.active{
      border-color: rgba(90,162,255,.9);
      box-shadow: 0 0 0 2px rgba(90,162,255,.18) inset;
      background: rgba(90,162,255,.12);
    }
    .btn.danger{ border-color: rgba(255,90,122,.55); }
    .btn.danger:hover{ border-color: rgba(255,90,122,.9); background: rgba(255,90,122,.12); }

    .sep{ width:1px; height:26px; background:rgba(36,49,74,.75); margin:0 4px; }

    #hint{
      margin-left:auto;
      color:var(--muted);
      font-size:12px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      max-width: 44vw;
    }

    #canvasWrap{ position:relative; flex:1; overflow:hidden; }
    canvas{
      position:absolute; inset:0;
      width:100%; height:100%;
      display:block;
      cursor:crosshair;
    }

    #overlay{ position:absolute; inset:0; pointer-events:none; z-index:6; }

    .textItem{
      position:absolute;
      pointer-events:auto;
      white-space:pre-wrap;
      color:var(--text);
      font-size:16px;
      line-height:1.25;
      padding:4px 6px;
      border-radius:10px;
      background: rgba(18,24,38,.0);
      border:1px solid rgba(0,0,0,0);
      transform: translate(-50%, -50%);
    }
    .textItem.selected{
      background: rgba(90,162,255,.10);
      border-color: rgba(90,162,255,.50);
      box-shadow: 0 0 0 2px rgba(90,162,255,.12) inset;
    }

    .labelItem{
      position:absolute;
      pointer-events:none;
      transform: translate(-50%, -120%);
      font-size:13px;
      color: rgba(232,238,252,.92);
      background: rgba(18,24,38,.55);
      border: 1px solid rgba(36,49,74,.7);
      border-radius:10px;
      padding:3px 6px;
      box-shadow: 0 10px 26px rgba(0,0,0,.30);
      white-space:nowrap;
    }

    #floatingTip{
      position:fixed;
      z-index:50;
      max-width: 360px;
      background: rgba(18,24,38,.92);
      border:1px solid rgba(36,49,74,.9);
      border-radius: 14px;
      padding:10px 12px;
      box-shadow: var(--shadow);
      display:none;
      font-size:12px;
      color: var(--text);
    }
    #floatingTip .t{ font-weight:700; margin-bottom:6px; font-size:12px; }
    #floatingTip .d{ color: var(--muted); line-height:1.35; }

    .panel{
      position:fixed;
      z-index:60;
      width: 340px;
      background: rgba(18,24,38,.96);
      border:1px solid rgba(36,49,74,.95);
      border-radius: 16px;
      box-shadow: var(--shadow);
      padding:12px;
      display:none;
      user-select:text;
    }
    .panel h3{ margin:0 0 8px 0; font-size:14px; color: var(--text); }

    .row{ display:flex; gap:8px; align-items:center; margin:8px 0; }
    .row label{ width:88px; color: var(--muted); font-size:12px; }
    .row input, .row textarea{
      flex:1;
      background: rgba(15,21,34,.85);
      border:1px solid rgba(36,49,74,.85);
      color: var(--text);
      border-radius: 12px;
      padding:8px 10px;
      font-size:12px;
      outline:none;
    }
    .row textarea{
      min-height: 80px;
      resize: vertical;
      font-family: var(--font);
    }
    .actions{ display:flex; gap:8px; justify-content:flex-end; margin-top:10px; }
    .mini{ font-size:12px; padding:8px 10px; border-radius: 12px; }

    #siteLink{
      position:fixed;
      left:12px;
      bottom:12px;
      z-index:20;
      text-decoration:none;
    }

    @media (max-width: 820px){
      #hint{ display:none; }
      .panel{ width: 90vw; }
    }
  </style>
</head>

<body>
<div id="app">
  <div id="topbar">
    <div class="group" id="toolGroup">
      <button class="btn" data-tool="select"  id="btnSelect">선택/이동</button>
      <button class="btn" data-tool="point"   id="btnPoint">점</button>
      <button class="btn" data-tool="segment" id="btnSeg">선분</button>
      <button class="btn" data-tool="line"    id="btnLine">직선</button>
      <button class="btn" data-tool="circle"  id="btnCircle">원</button>
      <button class="btn" data-tool="parabola" id="btnParabola">포물선</button>
      <button class="btn" data-tool="ellipse"  id="btnEllipse">타원</button>
      <button class="btn" data-tool="text"    id="btnText">텍스트</button>
    </div>

    <div class="group">
      <button class="btn" id="btnUndo">이전(Undo)</button>
      <button class="btn" id="btnRedo">다음(Redo)</button>
      <div class="sep"></div>
      <button class="btn" id="btnLang">KO</button>
    </div>

    <div id="hint"></div>
  </div>

  <div id="canvasWrap">
    <canvas id="cv"></canvas>
    <div id="overlay"></div>
  </div>
</div>

<a id="siteLink" class="btn" href="https://min7014.github.io" target="_blank" rel="noopener">min7014.github.io</a>

<div id="floatingTip">
  <div class="t" id="tipTitle"></div>
  <div class="d" id="tipDesc"></div>
</div>

<div class="panel" id="objEditor">
  <h3 id="objTitle">객체 속성</h3>
  <div class="row"><label id="lblKind">종류</label><input id="objKind" readonly /></div>
  <div class="row"><label>ID</label><input id="objId" readonly /></div>
  <div class="row"><label id="lblName">이름</label><input id="objName" placeholder="예: A, l1, c1 ..." /></div>
  <div class="row"><label id="lblCaption">캡션</label><textarea id="objCaption" placeholder="예: $y=x^2$ 처럼 $...$ 안은 LaTeX"></textarea></div>
  <div class="row" id="rowX"><label>X</label><input id="objX" /></div>
  <div class="row" id="rowY"><label>Y</label><input id="objY" /></div>
  <div class="actions">
    <button class="btn mini danger" id="btnObjCancel">취소</button>
    <button class="btn mini" id="btnObjSave">저장</button>
  </div>
</div>

<div class="panel" id="textEditor">
  <h3 id="textTitle">텍스트 편집</h3>
  <div class="row"><label id="lblText">내용</label><textarea id="textContent" placeholder="텍스트. $...$ 안은 LaTeX로 렌더링됩니다."></textarea></div>
  <div class="actions">
    <button class="btn mini danger" id="btnTextCancel">취소</button>
    <button class="btn mini" id="btnTextSave">저장</button>
  </div>
</div>

<script>
(() => {
  "use strict";

  const I18N = {
    ko: {
      tools: {
        select: { name:"선택/이동", desc:"객체 선택 후 드래그로 이동합니다. 선택된 객체에서 Enter 키를 누르면 속성창이 열립니다." },
        point:  { name:"점", desc:"화면 클릭으로 점 생성. 선/선분/원/곡선 위 클릭이면 그 위에서만 움직이는 종속점 생성. 교점도 생성 가능." },
        segment:{ name:"선분", desc:"첫 점 선택/생성 → 둘째 점 선택/생성하면 선분 생성. 선분 1개 생성 후 다음 클릭은 새 선분의 첫 점입니다." },
        line:   { name:"직선", desc:"두 점 선택/생성하면 그 두 점을 지나는 직선 생성." },
        circle: { name:"원", desc:"중심점 선택/생성 → 원 위 점 선택/생성으로 원 생성." },
        parabola:{ name:"포물선", desc:"초점 점 선택/생성 → 준선(직선/선분) 선택 또는 두 점으로 준선 지정 시 포물선 생성." },
        ellipse:{ name:"타원", desc:"초점1 → 초점2 → 타원 위 점(3번째 점)으로 타원 생성." },
        text:   { name:"텍스트", desc:"클릭 위치에 텍스트 생성. $...$ 내부는 LaTeX로 렌더링됩니다." },
      },
      ui: {
        hint:"팁: 선택도구에서 객체 선택 후 Enter → 속성창 / 텍스트 더블클릭 → 내용 편집 / Shift+더블클릭 → 속성창",
        objTitle:"객체 속성",
        kind:"종류",
        name:"이름",
        caption:"캡션",
        textTitle:"텍스트 편집",
        content:"내용",
        undo:"이전(Undo)",
        redo:"다음(Redo)",
      }
    },
    en: {
      tools: {
        select: { name:"Select/Move", desc:"Select and drag to move. Press Enter on a selected object to open properties." },
        point:  { name:"Point", desc:"Click to create a point. Click on objects to create dependent constrained points (also intersections)." },
        segment:{ name:"Segment", desc:"Pick/create first point → pick/create second point to create a segment. Then it resets for a new segment." },
        line:   { name:"Line", desc:"Pick/create two points to create a line." },
        circle: { name:"Circle", desc:"Pick/create center → pick/create a point on circle." },
        parabola:{ name:"Parabola", desc:"Pick/create focus → choose directrix (line/segment) or define by two points." },
        ellipse:{ name:"Ellipse", desc:"Focus1 → Focus2 → a point on the ellipse." },
        text:   { name:"Text", desc:"Click to create text. Anything inside $...$ is rendered as LaTeX." },
      },
      ui: {
        hint:"Tip: Select tool + Enter opens properties / Double-click text edits content / Shift+Double-click opens properties",
        objTitle:"Object Properties",
        kind:"Kind",
        name:"Name",
        caption:"Caption",
        textTitle:"Edit Text",
        content:"Content",
        undo:"Undo",
        redo:"Redo",
      }
    }
  };

  let lang = "ko";
  const t = () => I18N[lang];
  const $ = (id) => document.getElementById(id);
  const rndId = () => Math.random().toString(36).slice(2, 10);
  const clamp = (v,a,b) => Math.max(a, Math.min(b, v));
  const dist2 = (ax,ay,bx,by) => (ax-bx)*(ax-bx)+(ay-by)*(ay-by);
  const dist = (ax,ay,bx,by) => Math.hypot(ax-bx, ay-by);
  const deepClone = (o) => JSON.parse(JSON.stringify(o));

  function escapeHtml(s){
    return s.replace(/[&<>"']/g, (c) => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
    }[c]));
  }

  function renderMixedLatex(raw){
    if (!raw) return "";
    const hasKaTeX = typeof katex !== "undefined" && katex.renderToString;
    if (!hasKaTeX) return escapeHtml(raw);

    let out = "";
    let i = 0;
    while (i < raw.length){
      const s = raw.indexOf("$", i);
      if (s === -1){ out += escapeHtml(raw.slice(i)); break; }
      const e = raw.indexOf("$", s+1);
      if (e === -1){ out += escapeHtml(raw.slice(i)); break; }

      out += escapeHtml(raw.slice(i, s));
      const latex = raw.slice(s+1, e);
      try{
        out += katex.renderToString(latex, {throwOnError:false, displayMode:false});
      }catch(err){
        out += "<span style='color:rgba(255,90,122,.95)'>" + escapeHtml("$"+latex+"$") + "</span>";
      }
      i = e+1;
    }
    return out;
  }

  // per-session separation
  const SESSION_KEY = "mathlab_session_id_v1";
  let sessionId = sessionStorage.getItem(SESSION_KEY);
  if (!sessionId) {
    sessionId = "s_" + rndId();
    sessionStorage.setItem(SESSION_KEY, sessionId);
  }
  const STORE_KEY = "mathlab_state_v1_" + sessionId;

  let objects = [];
  let tool = "select";
  let selected = null;
  let dragging = null;

  let segmentPending = null;
  let linePending = null;
  let circlePending = null;
  let parabolaPending = { focusId:null, directrixId:null, directrixP1:null, directrixP2:null };
  let ellipsePending = { f1:null, f2:null };

  const cam = { x:0, y:0, scale:70 };
  let isPanning = false;
  let panStart = null;

  let lastMouseClient = { cx: 200, cy: 120 };

  const undoStack = [];
  const redoStack = [];

  function saveToStorage(){
    try{
      localStorage.setItem(STORE_KEY, JSON.stringify({
        objects, cam, tool, selected,
        segmentPending, linePending, circlePending,
        parabolaPending, ellipsePending
      }));
    }catch(e){}
  }

  function loadFromStorage(){
    try{
      const raw = localStorage.getItem(STORE_KEY);
      if (!raw) return false;
      const st = JSON.parse(raw);
      objects = st.objects || [];
      cam.x = st.cam?.x ?? 0;
      cam.y = st.cam?.y ?? 0;
      cam.scale = st.cam?.scale ?? 70;
      tool = st.tool || "select";
      selected = st.selected || null;
      segmentPending = st.segmentPending ?? null;
      linePending = st.linePending ?? null;
      circlePending = st.circlePending ?? null;
      parabolaPending = st.parabolaPending || { focusId:null, directrixId:null, directrixP1:null, directrixP2:null };
      ellipsePending = st.ellipsePending || { f1:null, f2:null };
      return true;
    }catch(e){
      return false;
    }
  }

  function pushState(){
    undoStack.push({
      objects: deepClone(objects),
      cam: deepClone(cam),
      tool,
      selected: selected ? deepClone(selected) : null,
      segmentPending, linePending, circlePending,
      parabolaPending: deepClone(parabolaPending),
      ellipsePending: deepClone(ellipsePending)
    });
    if (undoStack.length > 80) undoStack.shift();
    redoStack.length = 0;
    saveToStorage();
  }

  function applyState(st){
    objects = deepClone(st.objects || []);
    cam.x = st.cam?.x ?? 0;
    cam.y = st.cam?.y ?? 0;
    cam.scale = st.cam?.scale ?? 70;
    tool = st.tool || "select";
    selected = st.selected ? deepClone(st.selected) : null;

    segmentPending = st.segmentPending ?? null;
    linePending = st.linePending ?? null;
    circlePending = st.circlePending ?? null;
    parabolaPending = st.parabolaPending ? deepClone(st.parabolaPending) : { focusId:null, directrixId:null, directrixP1:null, directrixP2:null };
    ellipsePending = st.ellipsePending ? deepClone(st.ellipsePending) : { f1:null, f2:null };

    syncToolUI();
    syncOverlay();
    saveToStorage();
  }

  function undo(){
    if (!undoStack.length) return;
    const cur = {
      objects: deepClone(objects),
      cam: deepClone(cam),
      tool,
      selected: selected ? deepClone(selected) : null,
      segmentPending, linePending, circlePending,
      parabolaPending: deepClone(parabolaPending),
      ellipsePending: deepClone(ellipsePending)
    };
    redoStack.push(cur);
    const prev = undoStack.pop();
    applyState(prev);
  }

  function redo(){
    if (!redoStack.length) return;
    const cur = {
      objects: deepClone(objects),
      cam: deepClone(cam),
      tool,
      selected: selected ? deepClone(selected) : null,
      segmentPending, linePending, circlePending,
      parabolaPending: deepClone(parabolaPending),
      ellipsePending: deepClone(ellipsePending)
    };
    undoStack.push(cur);
    const next = redoStack.pop();
    applyState(next);
  }

  // Auto point labels
  const ALPH = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  function indexToLabel(i){
    if (i < 26) return ALPH[i];
    const letter = ALPH[i % 26];
    const n = Math.floor(i / 26);
    return letter + String(n);
  }
  function labelToIndex(name){
    const m = String(name || "").trim().match(/^([A-Z])(\d+)?$/);
    if (!m) return null;
    const letter = m[1];
    const n = m[2] ? parseInt(m[2], 10) : 0;
    if (!Number.isFinite(n) || n < 0) return null;
    return (letter.charCodeAt(0) - 65) + 26 * n;
  }
  function nextPointLabel(){
    const used = new Set();
    for (const o of objects){
      if (o.kind !== "point") continue;
      const idx = labelToIndex(o.name);
      if (idx !== null) used.add(idx);
    }
    let i = 0;
    while (used.has(i)) i++;
    return indexToLabel(i);
  }
  function buildCaptionForLabel(label){
    const s = String(label || "").trim();
    const m = s.match(/^([A-Z])(\d+)$/);
    if (m){
      const L = m[1];
      const num = m[2];
      return `$\\mathrm{${L}_{${num}}}$`;
    }
    return `$\\mathrm{${s}}$`;
  }
  function applyAutoPointLabel(p){
    if (!p || p.kind !== "point") return;
    const hasName = !!(p.name && String(p.name).trim());
    const hasCap  = !!(p.caption && String(p.caption).trim());
    if (hasName && hasCap) return;

    if (!hasName){
      const label = nextPointLabel();
      p.name = label;
      if (!hasCap) p.caption = buildCaptionForLabel(label);
    } else {
      if (!hasCap) p.caption = buildCaptionForLabel(String(p.name).trim());
    }
  }
  function normalizeAllPointLabels(){
    for (const o of objects){
      if (o.kind === "point") applyAutoPointLabel(o);
    }
  }

  // Canvas & coords
  const cv = $("cv");
  const ctx = cv.getContext("2d");
  const overlay = $("overlay");

  function canvasRect(){ return cv.getBoundingClientRect(); }
  function clientToCanvas(clientX, clientY){
    const r = canvasRect();
    return { sx: clientX - r.left, sy: clientY - r.top };
  }
  function canvasSizeCSS(){
    const r = canvasRect();
    return { w: r.width, h: r.height };
  }
  function resize(){
    const r = canvasRect();
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    cv.width  = Math.floor(r.width * dpr);
    cv.height = Math.floor(r.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener("resize", resize);

  function worldToScreen(wx, wy){
    const {w,h} = canvasSizeCSS();
    return {
      sx: (wx - cam.x) * cam.scale + w/2,
      sy: h/2 - (wy - cam.y) * cam.scale
    };
  }
  function screenToWorld(sx, sy){
    const {w,h} = canvasSizeCSS();
    return {
      wx: (sx - w/2) / cam.scale + cam.x,
      wy: (h/2 - sy) / cam.scale + cam.y
    };
  }

  // Geometry
  function getById(id){ return objects.find(o => o.id === id) || null; }
  function worldTol(){ return 10 / cam.scale; }
  function ensurePointAt(wx, wy){
    const id = "p_" + rndId();
    const p = { id, kind:"point", x: wx, y: wy, name:"", caption:"", constraint: null };
    applyAutoPointLabel(p);
    objects.push(p);
    return p;
  }
  function getOrCreatePointNear(wx, wy, tolWorld){
    const tol2 = tolWorld*tolWorld;
    let best = null;
    for (const o of objects){
      if (o.kind !== "point") continue;
      const d = dist2(o.x,o.y, wx,wy);
      if (d <= tol2 && (!best || d < best.d)) best = {p:o, d};
    }
    if (best){
      applyAutoPointLabel(best.p);
      return best.p;
    }
    return ensurePointAt(wx,wy);
  }
  function getViewportWorldBounds(){
    const {w,h} = canvasSizeCSS();
    const a = screenToWorld(0,0);
    const b = screenToWorld(w,h);
    return {
      xmin: Math.min(a.wx, b.wx),
      xmax: Math.max(a.wx, b.wx),
      ymin: Math.min(a.wy, b.wy),
      ymax: Math.max(a.wy, b.wy)
    };
  }
  function segmentIntersection(a,b,c,d){
    const r = {x: b.x-a.x, y: b.y-a.y};
    const s = {x: d.x-c.x, y: d.y-c.y};
    const denom = r.x*s.y - r.y*s.x;
    if (Math.abs(denom) < 1e-12) return null;
    const uNumer = (c.x-a.x)*r.y - (c.y-a.y)*r.x;
    const tNumer = (c.x-a.x)*s.y - (c.y-a.y)*s.x;
    const t = tNumer/denom;
    const u = uNumer/denom;
    if (t >= 0 && t <= 1 && u >= 0 && u <= 1){
      return {x: a.x + t*r.x, y: a.y + t*r.y};
    }
    return null;
  }
  function polylineProject(poly, pt){
    if (!poly || poly.length < 2) return {x:pt.x, y:pt.y, t:0};
    let best = {d: Infinity, x: poly[0].x, y: poly[0].y, t:0};

    let total = 0;
    const lens = [];
    for (let i=0;i<poly.length-1;i++){
      const L = dist(poly[i].x,poly[i].y, poly[i+1].x,poly[i+1].y);
      lens.push(L); total += L;
    }
    if (total < 1e-12) return {x:poly[0].x, y:poly[0].y, t:0};

    let acc = 0;
    for (let i=0;i<poly.length-1;i++){
      const A = poly[i], B = poly[i+1];
      const vx = B.x - A.x, vy = B.y - A.y;
      const vv = vx*vx + vy*vy;
      let u = 0;
      if (vv > 1e-12){
        u = ((pt.x - A.x)*vx + (pt.y - A.y)*vy) / vv;
        u = clamp(u, 0, 1);
      }
      const px = A.x + u*vx;
      const py = A.y + u*vy;
      const d = dist2(px,py, pt.x,pt.y);
      if (d < best.d){
        const tLocal = (acc + u*lens[i]) / total;
        best = {d, x:px, y:py, t: tLocal};
      }
      acc += lens[i];
    }
    return {x:best.x, y:best.y, t:best.t};
  }
  function polylineIntersections(polyA, polyB){
    const out = [];
    if (!polyA || !polyB || polyA.length<2 || polyB.length<2) return out;
    for (let i=0;i<polyA.length-1;i++){
      const a = polyA[i], b = polyA[i+1];
      for (let j=0;j<polyB.length-1;j++){
        const c = polyB[j], d = polyB[j+1];
        const p = segmentIntersection(a,b,c,d);
        if (p) out.push(p);
      }
    }
    return out;
  }
  function getLineEqFromTwoPoints(p1, p2){
    const dx = p2.x - p1.x;
    const dy = p2.y - p1.y;
    let nx = dy, ny = -dx;
    const len = Math.hypot(nx, ny);
    if (len < 1e-12) return null;
    nx /= len; ny /= len;
    const d = nx*p1.x + ny*p1.y;
    return {nx, ny, d};
  }

  // Sampling (approx)
  function sampleObject(obj){
    const b = getViewportWorldBounds();
    const margin = 1.2;
    const xmin = b.xmin*margin, xmax = b.xmax*margin;
    const ymin = b.ymin*margin, ymax = b.ymax*margin;

    if (obj.kind === "segment"){
      const A = getById(obj.aId), B = getById(obj.bId);
      if (!A || !B) return null;
      return [{x:A.x,y:A.y},{x:B.x,y:B.y}];
    }

    if (obj.kind === "line"){
      const A = getById(obj.aId), B = getById(obj.bId);
      if (!A || !B) return null;
      const dx = B.x-A.x, dy = B.y-A.y;
      const L = Math.hypot(dx,dy);
      if (L < 1e-12) return null;
      const ux = dx/L, uy = dy/L;
      const diag = Math.hypot(xmax-xmin, ymax-ymin);
      const tlen = diag*1.2;
      return [
        {x: A.x - ux*tlen, y: A.y - uy*tlen},
        {x: A.x + ux*tlen, y: A.y + uy*tlen},
      ];
    }

    if (obj.kind === "circle"){
      const C = getById(obj.cId), P = getById(obj.pId);
      if (!C || !P) return null;
      const r = dist(C.x,C.y, P.x,P.y);
      if (r < 1e-12) return null;
      const N = 200;
      const pts = [];
      for (let i=0;i<=N;i++){
        const ang = (i/N)*Math.PI*2;
        pts.push({x:C.x + r*Math.cos(ang), y:C.y + r*Math.sin(ang)});
      }
      return pts;
    }

    if (obj.kind === "ellipse"){
      const F1 = getById(obj.f1Id), F2 = getById(obj.f2Id), P = getById(obj.pId);
      if (!F1 || !F2 || !P) return null;
      const sum = dist(F1.x,F1.y,P.x,P.y) + dist(F2.x,F2.y,P.x,P.y);
      const a = sum/2;
      const c = dist(F1.x,F1.y,F2.x,F2.y)/2;
      if (a < 1e-10 || a < c + 1e-10) return null;
      const b0 = Math.sqrt(Math.max(0, a*a - c*c));

      const cx = (F1.x+F2.x)/2, cy = (F1.y+F2.y)/2;
      const ang = Math.atan2(F2.y-F1.y, F2.x-F1.x);
      const ca = Math.cos(ang), sa = Math.sin(ang);

      const N = 240;
      const pts = [];
      for (let i=0;i<=N;i++){
        const th = (i/N)*Math.PI*2;
        const ex = a*Math.cos(th);
        const ey = b0*Math.sin(th);
        const wx = cx + ex*ca - ey*sa;
        const wy = cy + ex*sa + ey*ca;
        pts.push({x:wx,y:wy});
      }
      return pts;
    }

    if (obj.kind === "parabola"){
      const F = getById(obj.fId);
      if (!F) return null;

      let L = null;
      if (obj.directrixKind === "ref"){
        const ref = getById(obj.directrixId);
        if (ref && (ref.kind === "line" || ref.kind === "segment")){
          const p1 = getById(ref.aId), p2 = getById(ref.bId);
          if (p1 && p2) L = getLineEqFromTwoPoints(p1,p2);
        }
      } else if (obj.directrixKind === "2p"){
        const p1 = getById(obj.p1Id), p2 = getById(obj.p2Id);
        if (p1 && p2) L = getLineEqFromTwoPoints(p1,p2);
      }
      if (!L) return null;

      const nx = L.nx, ny = L.ny, d = L.d;
      const ux = -ny, uy = nx;
      const Ox = nx*d, Oy = ny*d;

      const fx = ux*(F.x - Ox) + uy*(F.y - Oy);
      const fy = nx*(F.x - Ox) + ny*(F.y - Oy);
      if (Math.abs(fy) < 1e-6) return null;

      const span = Math.max(xmax-xmin, ymax-ymin) * 1.2;
      const xMin = fx - span;
      const xMax = fx + span;

      const N = 240;
      const pts = [];
      for (let i=0;i<=N;i++){
        const x = xMin + (i/N)*(xMax-xMin);
        const y = (((x - fx)*(x - fx)) + fy*fy) / (2*fy);
        pts.push({x: Ox + ux*x + nx*y, y: Oy + uy*x + ny*y});
      }
      return pts.length >= 2 ? pts : null;
    }

    return null;
  }

  // Dependent points update
  function updateDependentPoints(){
    for (const o of objects){
      if (o.kind !== "point" || !o.constraint) continue;
      const c = o.constraint;

      if (c.type === "on"){
        const parent = getById(c.parentId);
        if (!parent) continue;
        const poly = sampleObject(parent);
        if (!poly) continue;
        const proj = polylineProject(poly, {x:o.x,y:o.y});
        o.x = proj.x; o.y = proj.y; c.t = proj.t;
      }

      if (c.type === "intersection"){
        const A = getById(c.aId), B = getById(c.bId);
        if (!A || !B) continue;
        const pA = sampleObject(A);
        const pB = sampleObject(B);
        if (!pA || !pB) continue;

        const ints = polylineIntersections(pA, pB);
        if (!ints.length) continue;

        const ref = {x:o.x ?? c.seed?.x ?? 0, y:o.y ?? c.seed?.y ?? 0};
        let best = ints[0], bestD = dist2(ints[0].x,ints[0].y, ref.x,ref.y);
        for (let i=1;i<ints.length;i++){
          const dd = dist2(ints[i].x,ints[i].y, ref.x,ref.y);
          if (dd < bestD){ bestD = dd; best = ints[i]; }
        }
        o.x = best.x; o.y = best.y;
      }
    }
  }

  // Hit testing
  function hitTest(wx, wy){
    const tol = worldTol();

    let best = null;
    for (const o of objects){
      if (o.kind !== "point") continue;
      const d = dist(o.x,o.y, wx,wy);
      if (d <= tol && (!best || d < best.d)) best = {id:o.id, d};
    }
    if (best) return best.id;

    let best2 = null;
    for (const o of objects){
      if (o.kind==="point" || o.kind==="text") continue;
      const poly = sampleObject(o);
      if (!poly) continue;
      const proj = polylineProject(poly, {x:wx,y:wy});
      const d = dist(proj.x,proj.y, wx,wy);
      if (d <= tol*1.2 && (!best2 || d < best2.d)) best2 = {id:o.id, d};
    }
    return best2 ? best2.id : null;
  }

  function findNearestIntersectionCandidate(wx, wy){
    const tol = worldTol()*1.2;
    let best = null;

    const candidates = objects.filter(o => ["segment","line","circle","parabola","ellipse"].includes(o.kind));
    for (let i=0;i<candidates.length;i++){
      for (let j=i+1;j<candidates.length;j++){
        const A = candidates[i], B = candidates[j];
        const pA = sampleObject(A), pB = sampleObject(B);
        if (!pA || !pB) continue;
        const ints = polylineIntersections(pA, pB);
        for (const p of ints){
          const d = dist(p.x,p.y, wx,wy);
          if (d <= tol && (!best || d < best.d)){
            best = {aId:A.id, bId:B.id, x:p.x, y:p.y, d};
          }
        }
      }
    }
    return best;
  }

  function createIntersectionPoint(hit){
    const id = "p_" + rndId();
    const p = {
      id, kind:"point",
      x: hit.x, y: hit.y,
      name:"", caption:"",
      constraint: {type:"intersection", aId: hit.aId, bId: hit.bId, seed:{x:hit.x,y:hit.y}}
    };
    applyAutoPointLabel(p);
    objects.push(p);
    return p;
  }

  function createPointOnObject(parentId, wx, wy){
    const parent = getById(parentId);
    if (!parent) return null;
    const poly = sampleObject(parent);
    if (!poly) return null;
    const proj = polylineProject(poly, {x:wx,y:wy});

    const p = ensurePointAt(proj.x, proj.y);
    p.constraint = {type:"on", parentId, t: proj.t};
    return p;
  }

  // Create objects
  function createSegment(aId, bId){
    const id = "s_" + rndId();
    objects.push({id, kind:"segment", aId, bId, name:"", caption:""});
    return id;
  }
  function createLine(aId, bId){
    const id = "l_" + rndId();
    objects.push({id, kind:"line", aId, bId, name:"", caption:""});
    return id;
  }
  function createCircle(cId, pId){
    const id = "c_" + rndId();
    objects.push({id, kind:"circle", cId, pId, name:"", caption:""});
    return id;
  }
  function createParabola(fId, directrix){
    const id = "pa_" + rndId();
    objects.push({
      id, kind:"parabola", fId,
      directrixKind: directrix.kind,
      directrixId: directrix.directrixId || null,
      p1Id: directrix.p1Id || null,
      p2Id: directrix.p2Id || null,
      name:"", caption:""
    });
    return id;
  }
  function createEllipse(f1Id, f2Id, pId){
    const id = "e_" + rndId();
    objects.push({id, kind:"ellipse", f1Id, f2Id, pId, name:"", caption:""});
    return id;
  }
  function createText(wx, wy, content){
    const id = "t_" + rndId();
    objects.push({id, kind:"text", x:wx, y:wy, content: content ?? "텍스트", name:"", caption:""});
    return id;
  }

  // Tooltip (1s idle)
  const floatingTip = $("floatingTip");
  const tipTitle = $("tipTitle");
  const tipDesc  = $("tipDesc");
  let tipTimer = null;
  let tipArmed = false;

  function cancelFloatingTip(){
    tipArmed = false;
    if (tipTimer){ clearTimeout(tipTimer); tipTimer = null; }
    floatingTip.style.display = "none";
  }

  function armTipForButton(btnEl, toolKey){
    cancelFloatingTip();
    tipArmed = true;
    const rect = btnEl.getBoundingClientRect();
    const x = rect.right + 8;
    const y = rect.top;

    tipTimer = setTimeout(() => {
      if (!tipArmed) return;
      const info = t().tools[toolKey];
      tipTitle.textContent = info.name;
      tipDesc.textContent  = info.desc;
      floatingTip.style.left = x + "px";
      floatingTip.style.top  = y + "px";
      floatingTip.style.display = "block";
    }, 1000);
  }

  ["pointerdown","pointermove","wheel","keydown","touchstart"].forEach(ev => {
    window.addEventListener(ev, () => { if (tipArmed) cancelFloatingTip(); }, {passive:true});
  });

  // Editors
  const objEditor = $("objEditor");
  const objKind = $("objKind");
  const objId = $("objId");
  const objName = $("objName");
  const objCaption = $("objCaption");
  const rowX = $("rowX");
  const rowY = $("rowY");
  const objX = $("objX");
  const objY = $("objY");
  let editingObjId = null;

  function openObjEditor(sel, clientX, clientY){
    const obj = getById(sel.id);
    if (!obj) return;

    editingObjId = obj.id;
    $("objTitle").textContent = t().ui.objTitle;
    $("lblKind").textContent = t().ui.kind;
    $("lblName").textContent = t().ui.name;
    $("lblCaption").textContent = t().ui.caption;

    objKind.value = obj.kind;
    objId.value = obj.id;
    objName.value = obj.name || "";
    objCaption.value = obj.caption || "";

    const showXY = (obj.kind === "point" || obj.kind === "text");
    rowX.style.display = showXY ? "flex" : "none";
    rowY.style.display = showXY ? "flex" : "none";
    if (showXY){
      objX.value = (obj.x ?? 0);
      objY.value = (obj.y ?? 0);
    }

    const pad = 10;
    const w = objEditor.offsetWidth || 340;
    const h = objEditor.offsetHeight || 320;
    const x = clamp(clientX + 12, pad, window.innerWidth - w - pad);
    const y = clamp(clientY + 12, pad, window.innerHeight - h - pad);
    objEditor.style.left = x + "px";
    objEditor.style.top  = y + "px";
    objEditor.style.display = "block";
    setTimeout(() => objName.focus(), 0);
  }

  function closeObjEditor(){
    objEditor.style.display = "none";
    editingObjId = null;
  }

  $("btnObjCancel").addEventListener("click", closeObjEditor);
  $("btnObjSave").addEventListener("click", () => {
    if (!editingObjId) return;
    const obj = getById(editingObjId);
    if (!obj) { closeObjEditor(); return; }

    pushState();
    obj.name = objName.value || "";
    obj.caption = objCaption.value || "";

    if (obj.kind === "point" || obj.kind === "text"){
      const x = parseFloat(objX.value);
      const y = parseFloat(objY.value);
      if (Number.isFinite(x)) obj.x = x;
      if (Number.isFinite(y)) obj.y = y;
    }

    closeObjEditor();
    saveToStorage();
    syncOverlay();
  });

  const textEditor = $("textEditor");
  const textContent = $("textContent");
  let editingTextId = null;

  function openTextEditorFor(id, clientX, clientY){
    const obj = getById(id);
    if (!obj || obj.kind !== "text") return;

    editingTextId = id;
    $("textTitle").textContent = t().ui.textTitle;
    $("lblText").textContent = t().ui.content;
    textContent.value = obj.content || "";

    const pad = 10;
    const w = textEditor.offsetWidth || 340;
    const h = textEditor.offsetHeight || 240;
    const x = clamp(clientX + 12, pad, window.innerWidth - w - pad);
    const y = clamp(clientY + 12, pad, window.innerHeight - h - pad);
    textEditor.style.left = x + "px";
    textEditor.style.top  = y + "px";
    textEditor.style.display = "block";
    setTimeout(() => textContent.focus(), 0);
  }

  function closeTextEditor(){
    textEditor.style.display = "none";
    editingTextId = null;
  }

  $("btnTextCancel").addEventListener("click", closeTextEditor);
  $("btnTextSave").addEventListener("click", () => {
    if (!editingTextId) return;
    const obj = getById(editingTextId);
    if (!obj) { closeTextEditor(); return; }

    pushState();
    obj.content = textContent.value || "";

    closeTextEditor();
    saveToStorage();
    syncOverlay();
  });

  window.addEventListener("keydown", (e) => {
    if (e.key === "Escape"){
      if (objEditor.style.display === "block") closeObjEditor();
      if (textEditor.style.display === "block") closeTextEditor();
    }
  });

  // Overlay labels + text
  function getObjectAnchor(obj){
    if (!obj) return {x:0,y:0};
    if (obj.kind === "point") return {x:obj.x, y:obj.y};
    if (obj.kind === "text")  return {x:obj.x, y:obj.y};
    if (obj.kind === "segment" || obj.kind === "line"){
      const A = getById(obj.aId), B = getById(obj.bId);
      if (A && B) return {x:(A.x+B.x)/2, y:(A.y+B.y)/2};
    }
    if (obj.kind === "circle"){
      const C = getById(obj.cId);
      if (C) return {x:C.x, y:C.y};
    }
    if (obj.kind === "parabola"){
      const F = getById(obj.fId);
      if (F) return {x:F.x, y:F.y};
    }
    if (obj.kind === "ellipse"){
      const F1 = getById(obj.f1Id), F2 = getById(obj.f2Id);
      if (F1 && F2) return {x:(F1.x+F2.x)/2, y:(F1.y+F2.y)/2};
    }
    return {x:0,y:0};
  }

  function buildLabelHtml(obj){
    const name = (obj.name && obj.name.trim()) ? obj.name.trim() : "";
    const cap  = (obj.caption && obj.caption.trim()) ? obj.caption.trim() : "";
    const isSel = (selected?.id === obj.id);

    if (name && cap){
      if (isSel) return "<b>" + escapeHtml(name) + "</b>";
      return renderMixedLatex(cap);
    }
    if (cap) return renderMixedLatex(cap);
    if (name) return "<b>" + escapeHtml(name) + "</b>";
    return "";
  }

  function syncOverlay(){
    const existingTextEls = new Map([...overlay.querySelectorAll(".textItem")].map(el => [el.dataset.id, el]));
    const existingLabelEls = new Map([...overlay.querySelectorAll(".labelItem")].map(el => [el.dataset.id, el]));

    const texts = objects.filter(o => o.kind === "text");
    for (const o of texts){
      let el = existingTextEls.get(o.id);
      if (!el){
        el = document.createElement("div");
        el.className = "textItem";
        el.dataset.id = o.id;
        overlay.appendChild(el);

        el.addEventListener("pointerdown", (e) => {
          cancelFloatingTip();
          e.stopPropagation();
          e.preventDefault();
          if (tool !== "select") return;

          selected = {id:o.id};
          const {sx,sy} = clientToCanvas(e.clientX, e.clientY);
          dragging = {
            id:o.id, kind:"text",
            startWorld: screenToWorld(sx, sy),
            startObj: {x:o.x, y:o.y},
            moved:false
          };
          syncOverlay();
        });

        el.addEventListener("dblclick", (e) => {
          cancelFloatingTip();
          e.stopPropagation();
          e.preventDefault();
          if (textEditor.style.display === "block" || objEditor.style.display === "block") return;

          if (tool === "select" && (e.shiftKey || e.altKey)){
            openObjEditor({id:o.id}, e.clientX, e.clientY);
          } else {
            openTextEditorFor(o.id, e.clientX, e.clientY);
          }
        });
      }

      const s = worldToScreen(o.x,o.y);
      el.style.left = s.sx + "px";
      el.style.top  = s.sy + "px";
      el.innerHTML = renderMixedLatex(o.content || "");
      el.classList.toggle("selected", selected?.id === o.id);

      existingTextEls.delete(o.id);
    }
    for (const el of existingTextEls.values()) el.remove();

    const labelTargets = objects.filter(o =>
      (o.name && o.name.trim()) || (o.caption && o.caption.trim())
    );

    for (const o of labelTargets){
      let el = existingLabelEls.get(o.id);
      if (!el){
        el = document.createElement("div");
        el.className = "labelItem";
        el.dataset.id = o.id;
        overlay.appendChild(el);
      }
      const a = getObjectAnchor(o);
      const s = worldToScreen(a.x,a.y);
      el.style.left = s.sx + "px";
      el.style.top  = s.sy + "px";
      el.innerHTML = buildLabelHtml(o);

      existingLabelEls.delete(o.id);
    }
    for (const el of existingLabelEls.values()) el.remove();
  }

  // Drawing helpers
  function niceStep(target){
    const pow = Math.pow(10, Math.floor(Math.log10(target)));
    const x = target / pow;
    if (x < 1.5) return 1*pow;
    if (x < 3.5) return 2*pow;
    if (x < 7.5) return 5*pow;
    return 10*pow;
  }

  function drawGrid(){
    const bounds = getViewportWorldBounds();
    const step = niceStep(40 / cam.scale);

    const xmin = Math.floor(bounds.xmin/step)*step;
    const xmax = Math.ceil(bounds.xmax/step)*step;
    const ymin = Math.floor(bounds.ymin/step)*step;
    const ymax = Math.ceil(bounds.ymax/step)*step;

    ctx.save();
    ctx.lineWidth = 1;
    ctx.strokeStyle = "rgba(36,49,74,.35)";

    for (let x=xmin; x<=xmax; x+=step){
      const s1 = worldToScreen(x, ymin);
      const s2 = worldToScreen(x, ymax);
      ctx.beginPath(); ctx.moveTo(s1.sx, s1.sy); ctx.lineTo(s2.sx, s2.sy); ctx.stroke();
    }
    for (let y=ymin; y<=ymax; y+=step){
      const s1 = worldToScreen(xmin, y);
      const s2 = worldToScreen(xmax, y);
      ctx.beginPath(); ctx.moveTo(s1.sx, s1.sy); ctx.lineTo(s2.sx, s2.sy); ctx.stroke();
    }
    ctx.restore();
  }

  function drawAxes(){
    const {w,h} = canvasSizeCSS();
    const origin = worldToScreen(0,0);

    ctx.save();
    ctx.lineWidth = 1;
    ctx.strokeStyle = "rgba(170,182,209,.45)";
    ctx.fillStyle = "rgba(170,182,209,.75)";

    ctx.beginPath(); ctx.moveTo(0, origin.sy); ctx.lineTo(w, origin.sy); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(origin.sx, 0); ctx.lineTo(origin.sx, h); ctx.stroke();

    const ah = 8;
    ctx.beginPath(); ctx.moveTo(w-ah, origin.sy-ah/2); ctx.lineTo(w, origin.sy); ctx.lineTo(w-ah, origin.sy+ah/2); ctx.fill();
    ctx.beginPath(); ctx.moveTo(ah, origin.sy-ah/2); ctx.lineTo(0, origin.sy); ctx.lineTo(ah, origin.sy+ah/2); ctx.fill();
    ctx.beginPath(); ctx.moveTo(origin.sx-ah/2, ah); ctx.lineTo(origin.sx, 0); ctx.lineTo(origin.sx+ah/2, ah); ctx.fill();
    ctx.beginPath(); ctx.moveTo(origin.sx-ah/2, h-ah); ctx.lineTo(origin.sx, h); ctx.lineTo(origin.sx+ah/2, h-ah); ctx.fill();

    ctx.font = "12px " + getComputedStyle(document.body).fontFamily;
    ctx.fillStyle = "rgba(232,238,252,.75)";
    ctx.fillText("0", origin.sx + 6, origin.sy - 6);

    ctx.restore();
  }

  // ✅ 여기에서 직선 점선 제거: 모든 도형을 실선으로 그림
  function drawObjects(){
    ctx.save();
    ctx.lineWidth = 2;
    ctx.setLineDash([]); // 항상 실선 유지

    for (const o of objects){
      if (o.kind === "segment"){
        const A = getById(o.aId), B = getById(o.bId);
        if (!A || !B) continue;
        const a = worldToScreen(A.x,A.y);
        const b = worldToScreen(B.x,B.y);
        ctx.strokeStyle = (selected?.id===o.id) ? "rgba(90,162,255,.95)" : "rgba(232,238,252,.72)";
        ctx.beginPath(); ctx.moveTo(a.sx,a.sy); ctx.lineTo(b.sx,b.sy); ctx.stroke();
      }
      if (o.kind === "line"){
        const poly = sampleObject(o);
        if (!poly) continue;
        const a = worldToScreen(poly[0].x,poly[0].y);
        const b = worldToScreen(poly[1].x,poly[1].y);
        ctx.strokeStyle = (selected?.id===o.id) ? "rgba(90,162,255,.95)" : "rgba(232,238,252,.55)";
        ctx.beginPath(); ctx.moveTo(a.sx,a.sy); ctx.lineTo(b.sx,b.sy); ctx.stroke(); // 실선
      }
      if (o.kind === "circle" || o.kind === "parabola" || o.kind === "ellipse"){
        const poly = sampleObject(o);
        if (!poly) continue;
        ctx.strokeStyle = (selected?.id===o.id) ? "rgba(90,162,255,.95)" : "rgba(232,238,252,.62)";
        ctx.beginPath();
        const p0 = worldToScreen(poly[0].x, poly[0].y);
        ctx.moveTo(p0.sx, p0.sy);
        for (let i=1;i<poly.length;i++){
          const pi = worldToScreen(poly[i].x, poly[i].y);
          ctx.lineTo(pi.sx, pi.sy);
        }
        ctx.stroke(); // 실선
      }
    }

    for (const o of objects){
      if (o.kind !== "point") continue;
      const p = worldToScreen(o.x,o.y);
      const r = (selected?.id===o.id) ? 6 : 5;
      ctx.fillStyle = (selected?.id===o.id) ? "rgba(90,162,255,.95)" : "rgba(232,238,252,.9)";
      ctx.beginPath(); ctx.arc(p.sx, p.sy, r, 0, Math.PI*2); ctx.fill();

      if (o.constraint){
        ctx.strokeStyle = "rgba(55,214,138,.8)";
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(p.sx, p.sy, r+2, 0, Math.PI*2); ctx.stroke();
        ctx.lineWidth = 2;
      }
    }

    ctx.restore();
  }

  // UI
  const toolButtons = [...document.querySelectorAll("#toolGroup .btn")];
  function setHint(){ $("hint").textContent = t().ui.hint; }

  function syncToolUI(){
    for (const b of toolButtons){
      const key = b.dataset.tool;
      b.classList.toggle("active", key === tool);
      b.textContent = t().tools[key].name;
    }
    $("btnUndo").textContent = t().ui.undo;
    $("btnRedo").textContent = t().ui.redo;
    $("btnLang").textContent = (lang === "ko") ? "KO" : "EN";
    setHint();
  }

  toolButtons.forEach(btn => {
    btn.addEventListener("click", () => {
      const key = btn.dataset.tool;
      tool = key;

      segmentPending = null;
      linePending = null;
      circlePending = null;
      parabolaPending = { focusId:null, directrixId:null, directrixP1:null, directrixP2:null };
      ellipsePending = { f1:null, f2:null };
      selected = null;
      dragging = null;

      syncToolUI();
      syncOverlay();
      armTipForButton(btn, key);
      saveToStorage();
    });
  });

  $("btnUndo").addEventListener("click", () => { cancelFloatingTip(); undo(); });
  $("btnRedo").addEventListener("click", () => { cancelFloatingTip(); redo(); });

  $("btnLang").addEventListener("click", () => {
    cancelFloatingTip();
    lang = (lang === "ko") ? "en" : "ko";
    syncToolUI();
    syncOverlay();
  });

  function setCanvasCursor(){
    if (tool === "select") cv.style.cursor = isPanning ? "grabbing" : "default";
    else cv.style.cursor = "crosshair";
  }

  // Canvas events
  cv.addEventListener("pointermove", (e) => {
    lastMouseClient.cx = e.clientX;
    lastMouseClient.cy = e.clientY;

    const {sx,sy} = clientToCanvas(e.clientX, e.clientY);

    if (isPanning && panStart){
      const now = screenToWorld(sx, sy);
      cam.x = panStart.camX - (now.wx - panStart.wx);
      cam.y = panStart.camY - (now.wy - panStart.wy);
      saveToStorage();
      return;
    }

    if (dragging){
      const w = screenToWorld(sx, sy);
      const obj = getById(dragging.id);
      if (!obj) return;

      const dx = w.wx - dragging.startWorld.wx;
      const dy = w.wy - dragging.startWorld.wy;

      if (dragging.kind === "point"){
        const p = obj;
        const target = {x: dragging.startObj.x + dx, y: dragging.startObj.y + dy};

        if (p.constraint?.type === "on"){
          const parent = getById(p.constraint.parentId);
          const poly = parent ? sampleObject(parent) : null;
          if (poly){
            const proj = polylineProject(poly, target);
            p.x = proj.x; p.y = proj.y; p.constraint.t = proj.t;
          } else {
            p.x = target.x; p.y = target.y;
          }
        } else if (p.constraint?.type === "intersection"){
          // 교점은 드래그 이동 금지
        } else {
          p.x = target.x; p.y = target.y;
        }
        dragging.moved = true;
      }

      if (dragging.kind === "text"){
        obj.x = dragging.startObj.x + dx;
        obj.y = dragging.startObj.y + dy;
        dragging.moved = true;
      }

      saveToStorage();
      syncOverlay();
      return;
    }
  });

  cv.addEventListener("pointerdown", (e) => {
    cancelFloatingTip();
    lastMouseClient.cx = e.clientX;
    lastMouseClient.cy = e.clientY;

    const {sx,sy} = clientToCanvas(e.clientX, e.clientY);
    const w = screenToWorld(sx, sy);

    if (e.button === 2 || e.ctrlKey || e.metaKey || (e.shiftKey && tool==="select")){
      isPanning = true;
      panStart = { wx: w.wx, wy: w.wy, camX: cam.x, camY: cam.y };
      setCanvasCursor();
      e.preventDefault();
      return;
    }

    if (tool === "select"){
      const id = hitTest(w.wx,w.wy);
      if (id){
        selected = {id};
        const obj = getById(id);
        if (obj?.kind === "point"){
          dragging = {id, kind:"point", startWorld: w, startObj:{x:obj.x,y:obj.y}, moved:false};
        } else {
          dragging = null;
        }
      } else {
        selected = null;
        dragging = null;
      }
      syncOverlay();
      saveToStorage();
      return;
    }

    if (tool === "point"){
      const hit = findNearestIntersectionCandidate(w.wx, w.wy);
      if (hit){
        pushState();
        const p = createIntersectionPoint(hit);
        selected = {id:p.id};
        syncOverlay();
        saveToStorage();
        return;
      }

      const id = hitTest(w.wx,w.wy);
      const obj = id ? getById(id) : null;
      if (obj && obj.kind !== "point" && obj.kind !== "text"){
        pushState();
        const p = createPointOnObject(obj.id, w.wx, w.wy);
        if (p){
          selected = {id:p.id};
          syncOverlay();
          saveToStorage();
          return;
        }
      }

      pushState();
      const p = ensurePointAt(w.wx,w.wy);
      selected = {id:p.id};
      syncOverlay();
      saveToStorage();
      return;
    }

    if (tool === "segment"){
      pushState();
      const p = getOrCreatePointNear(w.wx,w.wy, worldTol());
      if (!segmentPending){
        segmentPending = p.id;
        selected = {id:p.id};
      } else {
        createSegment(segmentPending, p.id);
        segmentPending = null;
        selected = {id:p.id};
      }
      syncOverlay();
      saveToStorage();
      return;
    }

    if (tool === "line"){
      pushState();
      const p = getOrCreatePointNear(w.wx,w.wy, worldTol());
      if (!linePending){
        linePending = p.id; selected = {id:p.id};
      } else {
        createLine(linePending, p.id);
        linePending = null; selected = {id:p.id};
      }
      syncOverlay();
      saveToStorage();
      return;
    }

    if (tool === "circle"){
      pushState();
      const p = getOrCreatePointNear(w.wx,w.wy, worldTol());
      if (!circlePending){
        circlePending = p.id; selected = {id:p.id};
      } else {
        createCircle(circlePending, p.id);
        circlePending = null; selected = {id:p.id};
      }
      syncOverlay();
      saveToStorage();
      return;
    }

    if (tool === "parabola"){
      pushState();
      const id = hitTest(w.wx,w.wy);
      const obj = id ? getById(id) : null;

      if (!parabolaPending.focusId){
        const p = getOrCreatePointNear(w.wx,w.wy, worldTol());
        parabolaPending.focusId = p.id;
        selected = {id:p.id};
        syncOverlay(); saveToStorage();
        return;
      }

      if (obj && (obj.kind === "line" || obj.kind === "segment")){
        createParabola(parabolaPending.focusId, {kind:"ref", directrixId: obj.id});
        parabolaPending = { focusId:null, directrixId:null, directrixP1:null, directrixP2:null };
        selected = {id: obj.id};
        syncOverlay(); saveToStorage();
        return;
      }

      const p = getOrCreatePointNear(w.wx,w.wy, worldTol());
      if (!parabolaPending.directrixP1){
        parabolaPending.directrixP1 = p.id;
        selected = {id:p.id};
      } else if (!parabolaPending.directrixP2){
        parabolaPending.directrixP2 = p.id;
        createParabola(parabolaPending.focusId, {kind:"2p", p1Id: parabolaPending.directrixP1, p2Id: parabolaPending.directrixP2});
        parabolaPending = { focusId:null, directrixId:null, directrixP1:null, directrixP2:null };
        selected = {id:p.id};
      }
      syncOverlay(); saveToStorage();
      return;
    }

    if (tool === "ellipse"){
      pushState();
      const p = getOrCreatePointNear(w.wx,w.wy, worldTol());
      if (!ellipsePending.f1){
        ellipsePending.f1 = p.id; selected = {id:p.id};
      } else if (!ellipsePending.f2){
        ellipsePending.f2 = p.id; selected = {id:p.id};
      } else {
        createEllipse(ellipsePending.f1, ellipsePending.f2, p.id);
        ellipsePending = { f1:null, f2:null };
        selected = {id:p.id};
      }
      syncOverlay(); saveToStorage();
      return;
    }

    if (tool === "text"){
      pushState();
      const id = createText(w.wx, w.wy, (lang==="ko" ? "텍스트" : "Text") + " $x^2$");
      selected = {id};
      syncOverlay();
      saveToStorage();
      openTextEditorFor(id, e.clientX, e.clientY);
      return;
    }
  });

  cv.addEventListener("pointerup", () => {
    if (isPanning){
      isPanning = false;
      panStart = null;
      setCanvasCursor();
      return;
    }
    if (dragging){
      if (dragging.moved) pushState();
      dragging = null;
      saveToStorage();
    }
  });

  cv.addEventListener("wheel", (e) => {
    cancelFloatingTip();
    const delta = Math.sign(e.deltaY);
    const factor = (delta > 0) ? 0.92 : 1.08;

    const {sx,sy} = clientToCanvas(e.clientX, e.clientY);
    const before = screenToWorld(sx, sy);

    cam.scale = clamp(cam.scale * factor, 20, 260);

    const after = screenToWorld(sx, sy);
    cam.x += (before.wx - after.wx);
    cam.y += (before.wy - after.wy);

    saveToStorage();
    e.preventDefault();
  }, {passive:false});

  cv.addEventListener("contextmenu", (e) => e.preventDefault());

  cv.addEventListener("dblclick", (e) => {
    cancelFloatingTip();
    if (objEditor.style.display === "block" || textEditor.style.display === "block") return;

    const {sx,sy} = clientToCanvas(e.clientX, e.clientY);
    const w = screenToWorld(sx, sy);
    const id = hitTest(w.wx,w.wy);
    if (!id) return;

    selected = {id};
    syncOverlay();
    openObjEditor({id}, e.clientX, e.clientY);
    e.preventDefault();
  });

  // Enter: open properties in select mode
  window.addEventListener("keydown", (e) => {
    if (e.key !== "Enter") return;
    if (objEditor.style.display === "block" || textEditor.style.display === "block") return;
    if (tool !== "select") return;
    if (!selected?.id) return;

    const obj = getById(selected.id);
    if (!obj) return;

    openObjEditor({id: obj.id}, lastMouseClient.cx ?? 200, lastMouseClient.cy ?? 120);
    e.preventDefault();
  });

  // Loop
  function loop(){
    updateDependentPoints();
    const {w,h} = canvasSizeCSS();
    ctx.clearRect(0,0,w,h);
    drawGrid();
    drawAxes();
    drawObjects();
    syncOverlay();
    requestAnimationFrame(loop);
  }

  // Init
  resize();
  loadFromStorage();
  normalizeAllPointLabels();
  syncToolUI();
  setCanvasCursor();
  syncOverlay();
  pushState();
  loop();

})();
</script>
</body>
</html>
