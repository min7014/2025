<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Math Tool - Local (Point/Segment/Line/Circle/Parabola + Intersections)</title>

  <!-- cache hint -->
  <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate, max-age=0" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />

  <style>
    html, body { height: 100%; margin: 0; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background: #0b0f14; color: #e6edf3; }

    .topbar {
      position: fixed; top: 12px; left: 12px; right: 12px;
      display: flex; gap: 8px; align-items: center; z-index: 10;
      flex-wrap: wrap;
    }
    .panel {
      background: rgba(20, 26, 34, 0.85);
      border: 1px solid rgba(255,255,255,0.08);
      backdrop-filter: blur(8px);
      border-radius: 12px;
      padding: 10px 12px;
      display: flex; gap: 10px; align-items: center;
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
    }
    button {
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.12);
      color: #e6edf3;
      padding: 8px 10px;
      border-radius: 10px;
      cursor: pointer;
      user-select: none;
      white-space: nowrap;
    }
    button:hover { background: rgba(255,255,255,0.12); }
    button.active {
      background: rgba(120, 200, 255, 0.22);
      border-color: rgba(120, 200, 255, 0.35);
    }
    .readout { opacity: 0.9; font-size: 13px; }
    canvas { display: block; width: 100%; height: 100%; touch-action: none; }

    .footer {
      position: fixed; bottom: 12px; left: 12px;
      background: rgba(20, 26, 34, 0.75);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 12px;
      padding: 10px 12px;
      font-size: 12px;
      opacity: 0.85;
      line-height: 1.35;
      z-index: 10;
      max-width: min(900px, calc(100vw - 24px));
    }
    code { background: rgba(255,255,255,0.08); padding: 2px 6px; border-radius: 8px; }

    /* tooltip */
    .tip {
      position: fixed;
      z-index: 9999;
      display: none;
      background: rgba(20, 26, 34, 0.94);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 12px;
      padding: 10px 12px;
      box-shadow: 0 18px 44px rgba(0,0,0,0.45);
      backdrop-filter: blur(10px);
      max-width: min(560px, calc(100vw - 24px));
      font-size: 13px;
      line-height: 1.35;
      opacity: 0;
      pointer-events: none;
      transform: translateY(-4px);
      transition: opacity 160ms ease, transform 160ms ease;
    }
    .tip.show { display: block; opacity: 1; transform: translateY(0); }
    .tip.hide { opacity: 0; transform: translateY(-6px); }
    .tip b { color: rgba(255, 230, 160, 0.95); }
  </style>
</head>

<body>
  <div class="topbar">
    <div class="panel">
      <button id="toolPoint" class="active" type="button">점</button>
      <button id="toolSegment" type="button">선분</button>
      <button id="toolLine" type="button">직선</button>
      <button id="toolCircle" type="button">원</button>
      <button id="toolParabola" type="button">포물선</button>
      <button id="toolSelect" type="button">선택/이동</button>
      <span class="readout" id="readout"></span>
    </div>

    <div class="panel">
      <button id="btnUndoPoint" type="button">점 되돌리기</button>
      <button id="btnUndoSeg" type="button">선분 되돌리기</button>
      <button id="btnUndoLine" type="button">직선 되돌리기</button>
      <button id="btnUndoCircle" type="button">원 되돌리기</button>
      <button id="btnUndoParabola" type="button">포물선 되돌리기</button>
      <button id="btnClearAll" type="button">전체 삭제</button>
      <button id="btnCancelStep" type="button">현재 단계 취소(ESC)</button>
    </div>
  </div>

  <canvas id="c"></canvas>

  <div class="footer">
    ✅ 상태는 <b>브라우저(localStorage)</b>에만 저장됩니다(서버 저장 0)<br/>
    ✅ <b>점 도구</b>: 교점(포물선-직선/선분/원 포함) 근처를 클릭하면 <b>교점(종속점)</b> 생성<br/>
    ✅ <b>포물선</b>: 초점(점) 선택 → 준선(직선/선분/두 점) 선택<br/>
    단축키: <code>P</code>=점, <code>G</code>=선분, <code>L</code>=직선, <code>C</code>=원, <code>A</code>=포물선, <code>V</code>=선택, <code>ESC</code>=단계취소
  </div>

  <div id="tip" class="tip" aria-live="polite"></div>

<script>
(() => {
  // =========================
  // 0) 자동 찌꺼기 삭제(빌드 버전)
  // =========================
  // 새 버전 배포 시 BUILD_ID만 바꾸면:
  // - 이전 mathlab_ 로 시작하는 localStorage 키를 자동 삭제합니다.
  const BUILD_ID = "2026-01-08-parabola-html-01";
  const BUILD_KEY = "mathlab_build_id";

  function purgeOldLocalStorageIfNeeded() {
    try {
      const prev = localStorage.getItem(BUILD_KEY);
      if (prev === BUILD_ID) return false;

      const del = [];
      for (let i = 0; i < localStorage.length; i++) {
        const k = localStorage.key(i);
        if (k && k.startsWith("mathlab_")) del.push(k);
      }
      for (const k of del) localStorage.removeItem(k);
      localStorage.setItem(BUILD_KEY, BUILD_ID);
      return true;
    } catch {
      return false;
    }
  }
  const didPurge = purgeOldLocalStorageIfNeeded();

  // -------------------------
  // DOM refs (방어)
  // -------------------------
  const canvas = document.getElementById('c');
  const ctx = canvas?.getContext?.('2d');
  const readout = document.getElementById('readout');
  const tipEl = document.getElementById('tip');

  const toolPointBtn = document.getElementById('toolPoint');
  const toolSegmentBtn = document.getElementById('toolSegment');
  const toolLineBtn = document.getElementById('toolLine');
  const toolCircleBtn = document.getElementById('toolCircle');
  const toolParabolaBtn = document.getElementById('toolParabola');
  const toolSelectBtn = document.getElementById('toolSelect');

  const btnUndoPoint = document.getElementById('btnUndoPoint');
  const btnUndoSeg = document.getElementById('btnUndoSeg');
  const btnUndoLine = document.getElementById('btnUndoLine');
  const btnUndoCircle = document.getElementById('btnUndoCircle');
  const btnUndoParabola = document.getElementById('btnUndoParabola');
  const btnClearAll = document.getElementById('btnClearAll');
  const btnCancelStep = document.getElementById('btnCancelStep');

  if (!canvas || !ctx || !readout || !tipEl ||
      !toolPointBtn || !toolSegmentBtn || !toolLineBtn || !toolCircleBtn || !toolParabolaBtn || !toolSelectBtn ||
      !btnUndoPoint || !btnUndoSeg || !btnUndoLine || !btnUndoCircle || !btnUndoParabola || !btnClearAll || !btnCancelStep) {
    alert('UI 요소 로딩에 실패했습니다. HTML이 손상되었는지 확인해 주세요.');
    return;
  }

  // -------------------------
  // Tooltip (버튼 옆)
  // -------------------------
  let tipTimer = null;
  let tipHideTimer = null;

  function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }

  function hideTip() {
    tipEl.classList.remove('show');
    tipEl.classList.add('hide');
    if (tipHideTimer) clearTimeout(tipHideTimer);
    tipHideTimer = setTimeout(() => {
      if (tipEl.classList.contains('hide')) tipEl.style.display = 'none';
    }, 200);
  }

  function positionTip(anchorEl) {
    const padding = 10, gap = 10;
    const tw = Math.max(1, tipEl.offsetWidth);
    const th = Math.max(1, tipEl.offsetHeight);

    if (!anchorEl || !anchorEl.getBoundingClientRect) {
      const left = Math.round((window.innerWidth - tw) / 2);
      const top = 72;
      tipEl.style.left = `${clamp(left, padding, window.innerWidth - padding - tw)}px`;
      tipEl.style.top  = `${clamp(top,  padding, window.innerHeight - padding - th)}px`;
      return;
    }

    const r = anchorEl.getBoundingClientRect();
    let left = r.right + gap;
    let top  = r.top + (r.height - th) / 2;

    if (left + tw > window.innerWidth - padding) left = r.left - gap - tw;

    left = clamp(left, padding, window.innerWidth - padding - tw);
    top  = clamp(top,  padding, window.innerHeight - padding - th);

    tipEl.style.left = `${Math.round(left)}px`;
    tipEl.style.top  = `${Math.round(top)}px`;
  }

  function showTip(html, anchorEl=null, ms=1600) {
    if (tipTimer) clearTimeout(tipTimer);
    tipEl.innerHTML = html;
    tipEl.style.display = 'block';
    tipEl.classList.remove('hide');
    tipEl.classList.add('show');
    requestAnimationFrame(() => positionTip(anchorEl));
    tipTimer = setTimeout(hideTip, ms);
  }

  window.addEventListener('resize', hideTip);
  window.addEventListener('scroll', hideTip, true);

  // -------------------------
  // Storage (Local only)
  // -------------------------
  const STORAGE_KEY = "mathlab_state_geo_v1";

  function safeNum(x, fallback=0) {
    const n = Number(x);
    return Number.isFinite(n) ? n : fallback;
  }

  function sanitizeState(obj) {
    const safe = { points: [], segments: [], lines: [], circles: [], parabolas: [] };
    if (!obj || typeof obj !== 'object') return safe;

    const pts = Array.isArray(obj.points) ? obj.points : [];
    const segs = Array.isArray(obj.segments) ? obj.segments : [];
    const lns  = Array.isArray(obj.lines) ? obj.lines : [];
    const cirs = Array.isArray(obj.circles) ? obj.circles : [];
    const pars = Array.isArray(obj.parabolas) ? obj.parabolas : [];

    for (const p of pts) {
      if (!p || typeof p !== 'object') continue;
      if (typeof p.id !== 'string' || !p.id) continue;
      const kind = (p.kind === 'intersection') ? 'intersection' : 'free';
      const base = { id: p.id, x: safeNum(p.x, 0), y: safeNum(p.y, 0), kind };
      if (kind === 'intersection') {
        const pa = p.parents?.a;
        const pb = p.parents?.b;
        if (!pa || !pb) continue;
        if (typeof pa.kind !== 'string' || typeof pa.id !== 'string') continue;
        if (typeof pb.kind !== 'string' || typeof pb.id !== 'string') continue;
        base.parents = { a: { kind: pa.kind, id: pa.id }, b: { kind: pb.kind, id: pb.id } };
      }
      safe.points.push(base);
    }

    const pointIds = new Set(safe.points.map(p => p.id));

    for (const s of segs) {
      if (!s || typeof s !== 'object') continue;
      if (typeof s.id !== 'string' || !s.id) continue;
      if (typeof s.a_id !== 'string' || typeof s.b_id !== 'string') continue;
      if (!pointIds.has(s.a_id) || !pointIds.has(s.b_id) || s.a_id === s.b_id) continue;
      safe.segments.push({ id: s.id, a_id: s.a_id, b_id: s.b_id });
    }

    for (const l of lns) {
      if (!l || typeof l !== 'object') continue;
      if (typeof l.id !== 'string' || !l.id) continue;
      if (typeof l.a_id !== 'string' || typeof l.b_id !== 'string') continue;
      if (!pointIds.has(l.a_id) || !pointIds.has(l.b_id) || l.a_id === l.b_id) continue;
      safe.lines.push({ id: l.id, a_id: l.a_id, b_id: l.b_id });
    }

    for (const c of cirs) {
      if (!c || typeof c !== 'object') continue;
      if (typeof c.id !== 'string' || !c.id) continue;
      if (typeof c.c_id !== 'string' || typeof c.p_id !== 'string') continue;
      if (!pointIds.has(c.c_id) || !pointIds.has(c.p_id) || c.c_id === c.p_id) continue;
      safe.circles.push({ id: c.id, c_id: c.c_id, p_id: c.p_id });
    }

    for (const p of pars) {
      if (!p || typeof p !== 'object') continue;
      if (typeof p.id !== 'string' || !p.id) continue;
      if (typeof p.f_id !== 'string' || !pointIds.has(p.f_id)) continue;
      if (typeof p.d_a_id !== 'string' || typeof p.d_b_id !== 'string') continue;
      if (!pointIds.has(p.d_a_id) || !pointIds.has(p.d_b_id) || p.d_a_id === p.d_b_id) continue;
      safe.parabolas.push({ id: p.id, f_id: p.f_id, d_a_id: p.d_a_id, d_b_id: p.d_b_id });
    }

    return safe;
  }

  function loadState() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return sanitizeState(null);
      return sanitizeState(JSON.parse(raw));
    } catch {
      return sanitizeState(null);
    }
  }

  function saveState() {
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify({ points, segments, lines, circles, parabolas }));
    } catch {
      showTip('저장에 실패했습니다(브라우저 설정/용량). 그래도 작업은 계속됩니다.', null, 1600);
    }
  }

  // -------------------------
  // Geometry utils
  // -------------------------
  const EPS = 1e-9;
  function v(x,y){ return {x,y}; }
  function add(a,b){ return {x:a.x+b.x, y:a.y+b.y}; }
  function sub(a,b){ return {x:a.x-b.x, y:a.y-b.y}; }
  function mul(a,k){ return {x:a.x*k, y:a.y*k}; }
  function dot(a,b){ return a.x*b.x + a.y*b.y; }
  function cross(a,b){ return a.x*b.y - a.y*b.x; }
  function len(a){ return Math.hypot(a.x,a.y); }
  function norm(a){ const L=len(a); return L<EPS? {x:1,y:0} : {x:a.x/L, y:a.y/L}; }
  function perp(a){ return {x:-a.y, y:a.x}; }

  function distPointToLine(P, A, B){
    const AB=sub(B,A);
    const n=perp(AB);
    const nn=len(n);
    if (nn<EPS) return Infinity;
    return Math.abs(dot(sub(P,A), n))/nn;
  }

  function distPointToSegment(P, A, B){
    const AB=sub(B,A);
    const ap=sub(P,A);
    const ab2=dot(AB,AB);
    if (ab2<EPS) return len(sub(P,A));
    let t=dot(ap,AB)/ab2;
    t=Math.max(0,Math.min(1,t));
    const Q=add(A,mul(AB,t));
    return len(sub(P,Q));
  }

  function lineLineIntersection(A,B,C,D){
    const r=sub(B,A), s=sub(D,C);
    const den=cross(r,s);
    if (Math.abs(den)<EPS) return null;
    const t=cross(sub(C,A), s)/den;
    return add(A,mul(r,t));
  }

  function segmentSegmentIntersection(A,B,C,D){
    const r=sub(B,A), s=sub(D,C);
    const den=cross(r,s);
    const CA=sub(C,A);
    if (Math.abs(den)<EPS) return null;
    const t=cross(CA, s)/den;
    const u=cross(CA, r)/den;
    if (t<-1e-9 || t>1+1e-9 || u<-1e-9 || u>1+1e-9) return null;
    return add(A,mul(r,t));
  }

  function circleLineIntersections(C0, r, A, B){
    const d=sub(B,A);
    const f=sub(A,C0);
    const a=dot(d,d);
    const b=2*dot(f,d);
    const c=dot(f,f)-r*r;
    const disc=b*b-4*a*c;
    if (disc < -1e-10) return [];
    if (Math.abs(disc) <= 1e-10) {
      const t=-b/(2*a);
      return [ add(A,mul(d,t)) ];
    }
    const s=Math.sqrt(Math.max(0,disc));
    const t1=(-b - s)/(2*a);
    const t2=(-b + s)/(2*a);
    return [ add(A,mul(d,t1)), add(A,mul(d,t2)) ];
  }

  function circleCircleIntersections(C1,r1,C2,r2){
    const d=len(sub(C2,C1));
    if (d<EPS) return [];
    if (d>r1+r2+1e-10) return [];
    if (d<Math.abs(r1-r2)-1e-10) return [];
    const a=(r1*r1 - r2*r2 + d*d)/(2*d);
    const h2=r1*r1 - a*a;
    if (h2 < -1e-10) return [];
    const h=Math.sqrt(Math.max(0,h2));
    const u=mul(sub(C2,C1), 1/d);
    const P=add(C1, mul(u,a));
    const w=perp(u);
    if (h < 1e-8) return [P];
    return [ add(P, mul(w,h)), add(P, mul(w,-h)) ];
  }

  // Parabola basis (focus F, directrix line through A,B)
  function parabolaParams(F, A, B){
    const d0=sub(B,A);
    const d=norm(d0);
    let n=norm(perp(d));
    let vF=dot(sub(F,A), n);
    if (vF < 0) { n=mul(n,-1); vF=-vF; }
    const uF=dot(sub(F,A), d);
    return { A, d, n, uF, vF };
  }

  function worldToUV(X, par){
    return { u: dot(sub(X,par.A), par.d), v: dot(sub(X,par.A), par.n) };
  }
  function uvToWorld(u, v0, par){
    return add(par.A, add(mul(par.d,u), mul(par.n,v0)));
  }
  function parabolaV(u, par){
    const vF=par.vF;
    if (vF < 1e-9) return null;
    const t=u-par.uF;
    return (t*t + vF*vF)/(2*vF);
  }

  function parabolaLineIntersections(par, P0, P1, restrict01=false){
    const uv0=worldToUV(P0, par);
    const uv1=worldToUV(P1, par);
    const du=uv1.u-uv0.u;
    const dv=uv1.v-uv0.v;

    const a = du*du;
    const b = 2*(uv0.u-par.uF)*du - 2*par.vF*dv;
    const c = (uv0.u-par.uF)*(uv0.u-par.uF) + par.vF*par.vF - 2*par.vF*uv0.v;

    const disc=b*b - 4*a*c;

    if (Math.abs(a) < 1e-12) {
      if (Math.abs(b) < 1e-12) return [];
      const t = -c/b;
      if (restrict01 && (t < -1e-9 || t > 1+1e-9)) return [];
      return [ add(P0, mul(sub(P1,P0), t)) ];
    }

    if (disc < -1e-10) return [];
    if (Math.abs(disc) <= 1e-10) {
      const t=-b/(2*a);
      if (restrict01 && (t < -1e-9 || t > 1+1e-9)) return [];
      return [ add(P0, mul(sub(P1,P0), t)) ];
    }

    const s=Math.sqrt(Math.max(0,disc));
    const t1=(-b - s)/(2*a);
    const t2=(-b + s)/(2*a);

    const out=[];
    for (const t of [t1,t2]) {
      if (restrict01 && (t < -1e-9 || t > 1+1e-9)) continue;
      out.push(add(P0, mul(sub(P1,P0), t)));
    }
    return out;
  }

  function parabolaCircleIntersections(par, C0, r, uMin, uMax){
    const N = 220;
    const tol = 1e-5;
    const roots = [];

    function f(u){
      const vv = parabolaV(u, par);
      if (vv === null) return NaN;
      const X = uvToWorld(u, vv, par);
      const dx = X.x - C0.x;
      const dy = X.y - C0.y;
      return (dx*dx + dy*dy) - r*r;
    }

    const step = (uMax - uMin) / N;
    let uPrev = uMin;
    let fPrev = f(uPrev);

    for (let i=1;i<=N;i++){
      const uCur = uMin + step*i;
      const fCur = f(uCur);

      if (Number.isFinite(fPrev) && Math.abs(fPrev) < tol) roots.push(uPrev);
      if (Number.isFinite(fCur) && Math.abs(fCur) < tol) roots.push(uCur);

      if (Number.isFinite(fPrev) && Number.isFinite(fCur) && fPrev*fCur < 0){
        let a=uPrev, b=uCur;
        let fa=fPrev, fb=fCur;
        for (let k=0;k<40;k++){
          const m=(a+b)/2;
          const fm=f(m);
          if (!Number.isFinite(fm)) break;
          if (fa*fm <= 0){ b=m; fb=fm; }
          else { a=m; fa=fm; }
        }
        roots.push((a+b)/2);
      }

      uPrev=uCur;
      fPrev=fCur;
    }

    roots.sort((x,y)=>x-y);
    const uniq=[];
    for (const u of roots){
      if (!uniq.length || Math.abs(u-uniq[uniq.length-1]) > 1e-3) uniq.push(u);
    }

    const pts=[];
    for (const u of uniq){
      const vv = parabolaV(u, par);
      if (vv === null) continue;
      pts.push(uvToWorld(u, vv, par));
    }
    return pts;
  }

  // -------------------------
  // View / World
  // -------------------------
  let scale = 40;
  let origin = { x: 0, y: 0 };

  function worldToScreen(wx, wy) { return { x: origin.x + wx * scale, y: origin.y - wy * scale }; }
  function screenToWorld(sx, sy) { return { x: (sx - origin.x) / scale, y: (origin.y - sy) / scale }; }

  function resize() {
    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.floor(window.innerWidth * dpr);
    canvas.height = Math.floor(window.innerHeight * dpr);
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    origin.x = window.innerWidth / 2;
    origin.y = window.innerHeight / 2;
    draw();
  }

  function viewWorldBounds(){
    const w=window.innerWidth, h=window.innerHeight;
    const p1=screenToWorld(0,0);
    const p2=screenToWorld(w,h);
    return {
      minx: Math.min(p1.x,p2.x), maxx: Math.max(p1.x,p2.x),
      miny: Math.min(p1.y,p2.y), maxy: Math.max(p1.y,p2.y)
    };
  }

  // -------------------------
  // State
  // -------------------------
  let st = loadState();
  let points = st.points;
  let segments = st.segments;
  let lines = st.lines;
  let circles = st.circles;
  let parabolas = st.parabolas;

  function uid(prefix='') { return prefix + Date.now().toString(36) + '-' + Math.random().toString(36).slice(2, 8); }

  function getPoint(pid){ return points.find(p=>p.id===pid) || null; }
  function getSegment(sid){ return segments.find(s=>s.id===sid) || null; }
  function getLine(lid){ return lines.find(l=>l.id===lid) || null; }
  function getCircle(cid){ return circles.find(c=>c.id===cid) || null; }
  function getParabola(pid){ return parabolas.find(p=>p.id===pid) || null; }

  function cleanupAll(){
    const pids=new Set(points.map(p=>p.id));
    segments = segments.filter(s => pids.has(s.a_id) && pids.has(s.b_id) && s.a_id!==s.b_id);
    lines = lines.filter(l => pids.has(l.a_id) && pids.has(l.b_id) && l.a_id!==l.b_id);
    circles = circles.filter(c => pids.has(c.c_id) && pids.has(c.p_id) && c.c_id!==c.p_id);
    parabolas = parabolas.filter(p => pids.has(p.f_id) && pids.has(p.d_a_id) && pids.has(p.d_b_id) && p.d_a_id!==p.d_b_id);

    const exists = (ref) => {
      if (!ref) return false;
      if (ref.kind === 'segment') return !!getSegment(ref.id);
      if (ref.kind === 'line') return !!getLine(ref.id);
      if (ref.kind === 'circle') return !!getCircle(ref.id);
      if (ref.kind === 'parabola') return !!getParabola(ref.id);
      return false;
    };
    points = points.filter(p => {
      if (p.kind !== 'intersection') return true;
      return exists(p.parents?.a) && exists(p.parents?.b);
    });
  }

  // -------------------------
  // Tools & step states
  // -------------------------
  let tool = 'point'; // point | segment | line | circle | parabola | select
  let selectedPointId = null;

  let stepA = null;             // segment/line first point
  let circleCenterId = null;    // circle center
  let parabolaFocusId = null;   // parabola focus
  let parabolaDirFirstId = null;// directrix by two points (first)

  let mouseWorld = {x:0,y:0};

  let dragging=false;
  let dragPointerId=null;
  let dragOffset={x:0,y:0};

  const HIT_R = 10; // px for points

  function setTool(t, anchor=null){
    tool=t;
    toolPointBtn.classList.toggle('active', t==='point');
    toolSegmentBtn.classList.toggle('active', t==='segment');
    toolLineBtn.classList.toggle('active', t==='line');
    toolCircleBtn.classList.toggle('active', t==='circle');
    toolParabolaBtn.classList.toggle('active', t==='parabola');
    toolSelectBtn.classList.toggle('active', t==='select');

    cancelStep(false);

    const msg = {
      point: '<b>점</b>: 빈 곳 클릭=자유점, 교점 근처 클릭=<b>교점(종속점)</b> 생성',
      segment: '<b>선분</b>: 첫 점 → 둘째 점 (2점씩 짝지어 생성)',
      line: '<b>직선</b>: 첫 점 → 둘째 점 (무한 직선)',
      circle: '<b>원</b>: 중심점 → 원 위의 점',
      parabola: '<b>포물선</b>: 초점(점) → 준선(직선/선분/두 점)',
      select: '<b>선택/이동</b>: 자유점을 드래그하여 이동'
    }[t] || '';
    showTip(msg, anchor, 1800);
    draw();
  }

  function cancelStep(showMsg=true){
    stepA=null;
    circleCenterId=null;
    parabolaFocusId=null;
    parabolaDirFirstId=null;
    if (showMsg) showTip('현재 단계가 취소되었습니다.', btnCancelStep, 1100);
    draw();
  }

  // -------------------------
  // Hit tests
  // -------------------------
  function getCanvasLocalXY(e){
    const rect = canvas.getBoundingClientRect();
    return { sx: e.clientX - rect.left, sy: e.clientY - rect.top };
  }

  function hitPoint(sx,sy){
    let best=null, bestD2=Infinity;
    for (const p of points){
      const s = worldToScreen(p.x, p.y);
      const dx=s.x-sx, dy=s.y-sy;
      const d2=dx*dx+dy*dy;
      if (d2<bestD2){ bestD2=d2; best=p; }
    }
    return (best && bestD2 <= HIT_R*HIT_R) ? best : null;
  }

  function hitSegmentObj(sx,sy){
    let best=null, bestDist=Infinity;
    const P=screenToWorld(sx,sy);
    for (const seg of segments){
      const a=getPoint(seg.a_id), b=getPoint(seg.b_id);
      if (!a||!b) continue;
      const d=distPointToSegment(P, v(a.x,a.y), v(b.x,b.y));
      const dp = d * scale;
      if (dp < bestDist){ bestDist = dp; best = seg; }
    }
    return (best && bestDist <= 10) ? best : null;
  }

  function hitLineObj(sx,sy){
    let best=null, bestDist=Infinity;
    const P=screenToWorld(sx,sy);
    for (const ln of lines){
      const a=getPoint(ln.a_id), b=getPoint(ln.b_id);
      if (!a||!b) continue;
      const d=distPointToLine(P, v(a.x,a.y), v(b.x,b.y));
      const dp=d*scale;
      if (dp < bestDist){ bestDist=dp; best=ln; }
    }
    return (best && bestDist <= 10) ? best : null;
  }

  // -------------------------
  // Create primitives
  // -------------------------
  function addFreePoint(wx,wy){
    const p={ id: uid('p-'), x: wx, y: wy, kind:'free' };
    points.push(p);
    cleanupAll();
    saveState();
    draw();
    return p.id;
  }

  function addIntersectionPoint(wx,wy, refA, refB){
    const p={
      id: uid('ip-'),
      x: wx, y: wy,
      kind: 'intersection',
      parents: { a: refA, b: refB }
    };
    points.push(p);
    cleanupAll();
    saveState();
    draw();
    return p.id;
  }

  function addSegment(a_id,b_id){ segments.push({ id: uid('s-'), a_id, b_id }); cleanupAll(); saveState(); draw(); }
  function addLine(a_id,b_id){ lines.push({ id: uid('l-'), a_id, b_id }); cleanupAll(); saveState(); draw(); }
  function addCircle(c_id,p_id){ circles.push({ id: uid('c-'), c_id, p_id }); cleanupAll(); saveState(); draw(); }
  function addParabola(f_id, d_a_id, d_b_id){ parabolas.push({ id: uid('pa-'), f_id, d_a_id, d_b_id }); cleanupAll(); saveState(); draw(); }

  // -------------------------
  // Intersections
  // -------------------------
  function getLinePtsFromLineObj(ln){
    const A=getPoint(ln.a_id), B=getPoint(ln.b_id);
    if (!A||!B) return null;
    return {A:v(A.x,A.y), B:v(B.x,B.y)};
  }
  function getLinePtsFromSegmentObj(seg){
    const A=getPoint(seg.a_id), B=getPoint(seg.b_id);
    if (!A||!B) return null;
    return {A:v(A.x,A.y), B:v(B.x,B.y)};
  }
  function getCircleGeom(c){
    const C=getPoint(c.c_id), P=getPoint(c.p_id);
    if (!C||!P) return null;
    const CC=v(C.x,C.y), PP=v(P.x,P.y);
    return {C:CC, r: len(sub(PP,CC))};
  }
  function getParabolaGeom(pb){
    const F=getPoint(pb.f_id);
    const A=getPoint(pb.d_a_id);
    const B=getPoint(pb.d_b_id);
    if (!F||!A||!B) return null;
    return {F:v(F.x,F.y), A:v(A.x,A.y), B:v(B.x,B.y)};
  }

  function intersectionsBetween(ref1, ref2){
    const k1=ref1.kind, k2=ref2.kind;
    const pair=[k1,k2].sort().join('|');

    if (pair==='line|line'){
      const l1 = (k1==='line') ? getLine(ref1.id) : getLine(ref2.id);
      const l2 = (k1==='line') ? getLine(ref2.id) : getLine(ref1.id);
      if (!l1||!l2) return [];
      const p1=getLinePtsFromLineObj(l1), p2=getLinePtsFromLineObj(l2);
      if (!p1||!p2) return [];
      const X=lineLineIntersection(p1.A,p1.B,p2.A,p2.B);
      return X ? [X] : [];
    }

    if (pair==='segment|segment'){
      const s1 = (k1==='segment') ? getSegment(ref1.id) : getSegment(ref2.id);
      const s2 = (k1==='segment') ? getSegment(ref2.id) : getSegment(ref1.id);
      if (!s1||!s2) return [];
      const p1=getLinePtsFromSegmentObj(s1), p2=getLinePtsFromSegmentObj(s2);
      if (!p1||!p2) return [];
      const X=segmentSegmentIntersection(p1.A,p1.B,p2.A,p2.B);
      return X ? [X] : [];
    }

    if (pair==='line|segment'){
      const ln = (k1==='line') ? getLine(ref1.id) : getLine(ref2.id);
      const sg = (k1==='segment') ? getSegment(ref1.id) : getSegment(ref2.id);
      if (!ln||!sg) return [];
      const pL=getLinePtsFromLineObj(ln);
      const pS=getLinePtsFromSegmentObj(sg);
      if (!pL||!pS) return [];
      const X=lineLineIntersection(pL.A,pL.B,pS.A,pS.B);
      if (!X) return [];
      return (distPointToSegment(X,pS.A,pS.B) < 1e-7) ? [X] : [];
    }

    if (pair==='circle|line'){
      const cir = (k1==='circle') ? getCircle(ref1.id) : getCircle(ref2.id);
      const ln  = (k1==='line') ? getLine(ref1.id) : getLine(ref2.id);
      if (!cir||!ln) return [];
      const cg=getCircleGeom(cir);
      const lp=getLinePtsFromLineObj(ln);
      if (!cg||!lp) return [];
      return circleLineIntersections(cg.C, cg.r, lp.A, lp.B);
    }

    if (pair==='circle|segment'){
      const cir = (k1==='circle') ? getCircle(ref1.id) : getCircle(ref2.id);
      const sg  = (k1==='segment') ? getSegment(ref1.id) : getSegment(ref2.id);
      if (!cir||!sg) return [];
      const cg=getCircleGeom(cir);
      const sp=getLinePtsFromSegmentObj(sg);
      if (!cg||!sp) return [];
      const pts=circleLineIntersections(cg.C, cg.r, sp.A, sp.B);
      return pts.filter(X => distPointToSegment(X, sp.A, sp.B) < 1e-7);
    }

    if (pair==='circle|circle'){
      const c1 = getCircle((k1==='circle')?ref1.id:ref2.id);
      const c2 = getCircle((k1==='circle')?ref2.id:ref1.id);
      if (!c1||!c2) return [];
      const g1=getCircleGeom(c1), g2=getCircleGeom(c2);
      if (!g1||!g2) return [];
      return circleCircleIntersections(g1.C,g1.r,g2.C,g2.r);
    }

    if (pair==='line|parabola'){
      const pb = (k1==='parabola') ? getParabola(ref1.id) : getParabola(ref2.id);
      const ln = (k1==='line') ? getLine(ref1.id) : getLine(ref2.id);
      if (!pb||!ln) return [];
      const pg=getParabolaGeom(pb);
      const lp=getLinePtsFromLineObj(ln);
      if (!pg||!lp) return [];
      const par=parabolaParams(pg.F, pg.A, pg.B);
      return parabolaLineIntersections(par, lp.A, lp.B, false);
    }

    if (pair==='parabola|segment'){
      const pb = (k1==='parabola') ? getParabola(ref1.id) : getParabola(ref2.id);
      const sg = (k1==='segment') ? getSegment(ref1.id) : getSegment(ref2.id);
      if (!pb||!sg) return [];
      const pg=getParabolaGeom(pb);
      const sp=getLinePtsFromSegmentObj(sg);
      if (!pg||!sp) return [];
      const par=parabolaParams(pg.F, pg.A, pg.B);
      return parabolaLineIntersections(par, sp.A, sp.B, true);
    }

    if (pair==='circle|parabola'){
      const pb = (k1==='parabola') ? getParabola(ref1.id) : getParabola(ref2.id);
      const cir= (k1==='circle') ? getCircle(ref1.id) : getCircle(ref2.id);
      if (!pb||!cir) return [];
      const pg=getParabolaGeom(pb);
      const cg=getCircleGeom(cir);
      if (!pg||!cg) return [];
      const par=parabolaParams(pg.F, pg.A, pg.B);

      const vb=viewWorldBounds();
      const corners=[v(vb.minx,vb.miny), v(vb.minx,vb.maxy), v(vb.maxx,vb.miny), v(vb.maxx,vb.maxy)];
      const us=corners.map(c=>dot(sub(c,par.A), par.d));
      let uMin=Math.min(...us)-4, uMax=Math.max(...us)+4;

      return parabolaCircleIntersections(par, cg.C, cg.r, uMin, uMax);
    }

    return [];
  }

  function computeAllIntersections(){
    const refs = [];
    for (const s of segments) refs.push({kind:'segment', id:s.id});
    for (const l of lines) refs.push({kind:'line', id:l.id});
    for (const c of circles) refs.push({kind:'circle', id:c.id});
    for (const p of parabolas) refs.push({kind:'parabola', id:p.id});

    const out=[];
    for (let i=0;i<refs.length;i++){
      for (let j=i+1;j<refs.length;j++){
        const a=refs[i], b=refs[j];
        const pts = intersectionsBetween(a,b);
        for (const X of pts){
          out.push({ x:X.x, y:X.y, a, b });
        }
      }
    }
    return out;
  }

  function updateIntersectionPoints(){
    for (const p of points){
      if (p.kind !== 'intersection') continue;
      const a=p.parents?.a, b=p.parents?.b;
      const pts = intersectionsBetween(a,b);
      if (!pts.length) continue;
      let best=pts[0], bestD=Infinity;
      for (const X of pts){
        const d=(X.x-p.x)*(X.x-p.x)+(X.y-p.y)*(X.y-p.y);
        if (d<bestD){ bestD=d; best=X; }
      }
      p.x = best.x;
      p.y = best.y;
    }
  }

  // -------------------------
  // Point tool: create intersection if near
  // -------------------------
  function tryCreateIntersectionAtClick(sx,sy){
    const candidates = computeAllIntersections();
    let best=null, bestD2=Infinity;
    for (const it of candidates){
      const s = worldToScreen(it.x, it.y);
      const dx=s.x-sx, dy=s.y-sy;
      const d2=dx*dx+dy*dy;
      if (d2 < bestD2){ bestD2=d2; best=it; }
    }
    if (best && bestD2 <= (12*12)){
      addIntersectionPoint(best.x, best.y, best.a, best.b);
      showTip('교점이 생성되었습니다(종속점).', toolPointBtn, 1200);
      return true;
    }
    return false;
  }

  // -------------------------
  // Draw
  // -------------------------
  function drawGrid(){
    const w = window.innerWidth, h = window.innerHeight;
    ctx.fillStyle = '#0b0f14';
    ctx.fillRect(0, 0, w, h);

    const minor = scale, major = scale * 5;

    function drawLines(step, alpha) {
      ctx.strokeStyle = `rgba(230, 237, 243, ${alpha})`;
      ctx.lineWidth = 1;

      let x0 = origin.x % step;
      for (let x = x0; x <= w; x += step) {
        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke();
      }

      let y0 = origin.y % step;
      for (let y = y0; y <= h; y += step) {
        ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke();
      }
    }

    drawLines(minor, 0.06);
    drawLines(major, 0.12);

    ctx.strokeStyle = 'rgba(230, 237, 243, 0.55)';
    ctx.lineWidth = 2;

    // axes
    ctx.beginPath(); ctx.moveTo(0, origin.y); ctx.lineTo(w, origin.y); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(origin.x, 0); ctx.lineTo(origin.x, h); ctx.stroke();

    function drawArrowhead(x, y, dir) {
      const size = 10;
      ctx.fillStyle = 'rgba(230, 237, 243, 0.75)';
      ctx.beginPath();
      if (dir === 'right') { ctx.moveTo(x, y); ctx.lineTo(x - size, y - size * 0.55); ctx.lineTo(x - size, y + size * 0.55); }
      if (dir === 'left')  { ctx.moveTo(x, y); ctx.lineTo(x + size, y - size * 0.55); ctx.lineTo(x + size, y + size * 0.55); }
      if (dir === 'up')    { ctx.moveTo(x, y); ctx.lineTo(x - size * 0.55, y + size); ctx.lineTo(x + size * 0.55, y + size); }
      if (dir === 'down')  { ctx.moveTo(x, y); ctx.lineTo(x - size * 0.55, y - size); ctx.lineTo(x + size * 0.55, y - size); }
      ctx.closePath(); ctx.fill();
    }
    drawArrowhead(w, origin.y, 'right');
    drawArrowhead(0, origin.y, 'left');
    drawArrowhead(origin.x, 0, 'up');
    drawArrowhead(origin.x, h, 'down');

    ctx.fillStyle = 'rgba(230, 237, 243, 0.75)';
    ctx.font = '12px system-ui';
    ctx.fillText('x', w - 18, origin.y - 10);
    ctx.fillText('y', origin.x + 10, 16);

    ctx.fillStyle = 'rgba(230, 237, 243, 0.85)';
    ctx.fillText('0', origin.x + 6, origin.y + 14);
  }

  function drawSegments(){
    ctx.lineWidth = 3;
    ctx.strokeStyle = 'rgba(180, 220, 255, 0.75)';
    for (const seg of segments){
      const a=getPoint(seg.a_id), b=getPoint(seg.b_id);
      if (!a||!b) continue;
      const sa=worldToScreen(a.x,a.y);
      const sb=worldToScreen(b.x,b.y);
      ctx.beginPath(); ctx.moveTo(sa.x,sa.y); ctx.lineTo(sb.x,sb.y); ctx.stroke();
    }
  }

  function drawLines(){
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.35)';
    const w=window.innerWidth, h=window.innerHeight;

    for (const ln of lines){
      const a=getPoint(ln.a_id), b=getPoint(ln.b_id);
      if (!a||!b) continue;
      const A=worldToScreen(a.x,a.y);
      const B=worldToScreen(b.x,b.y);

      const dx=B.x-A.x, dy=B.y-A.y;
      if (Math.hypot(dx,dy) < 1e-6) continue;

      const candidates=[];
      function addIfValid(t){
        const x=A.x+dx*t, y=A.y+dy*t;
        if (x>=-1 && x<=w+1 && y>=-1 && y<=h+1) candidates.push({x,y});
      }
      if (Math.abs(dx)>1e-9){ addIfValid((0-A.x)/dx); addIfValid((w-A.x)/dx); }
      if (Math.abs(dy)>1e-9){ addIfValid((0-A.y)/dy); addIfValid((h-A.y)/dy); }
      if (candidates.length < 2) continue;

      let p0=candidates[0], p1=candidates[1], best=0;
      for (let i=0;i<candidates.length;i++){
        for (let j=i+1;j<candidates.length;j++){
          const dd=(candidates[i].x-candidates[j].x)**2+(candidates[i].y-candidates[j].y)**2;
          if (dd>best){ best=dd; p0=candidates[i]; p1=candidates[j]; }
        }
      }

      ctx.beginPath();
      ctx.moveTo(p0.x,p0.y);
      ctx.lineTo(p1.x,p1.y);
      ctx.stroke();
    }
  }

  function drawCircles(){
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(200, 255, 200, 0.45)';
    for (const c of circles){
      const C=getPoint(c.c_id), P=getPoint(c.p_id);
      if (!C||!P) continue;
      const r=len(sub(v(P.x,P.y), v(C.x,C.y)));
      const sC=worldToScreen(C.x,C.y);
      ctx.beginPath();
      ctx.arc(sC.x,sC.y, r*scale, 0, Math.PI*2);
      ctx.stroke();
    }
  }

  function drawParabolas(){
    ctx.lineWidth = 2.5;
    ctx.strokeStyle = 'rgba(255, 200, 120, 0.65)';

    const vb=viewWorldBounds();
    for (const pb of parabolas){
      const F=getPoint(pb.f_id);
      const A=getPoint(pb.d_a_id);
      const B=getPoint(pb.d_b_id);
      if (!F||!A||!B) continue;

      const par=parabolaParams(v(F.x,F.y), v(A.x,A.y), v(B.x,B.y));
      const corners=[v(vb.minx,vb.miny), v(vb.minx,vb.maxy), v(vb.maxx,vb.miny), v(vb.maxx,vb.maxy)];
      const us=corners.map(c=>dot(sub(c,par.A), par.d));
      let uMin=Math.min(...us)-2, uMax=Math.max(...us)+2;

      const N=180;
      let started=false;
      ctx.beginPath();
      for (let i=0;i<=N;i++){
        const ucur=uMin + (uMax-uMin)*i/N;
        const vv=parabolaV(ucur, par);
        if (vv===null) continue;
        const X=uvToWorld(ucur, vv, par);
        const s=worldToScreen(X.x,X.y);
        if (!started){ ctx.moveTo(s.x,s.y); started=true; }
        else ctx.lineTo(s.x,s.y);
      }
      if (started) ctx.stroke();
    }
  }

  function drawPoints(){
    for (const p of points){
      const s=worldToScreen(p.x,p.y);
      const isSel = (p.id === selectedPointId);
      const r = isSel ? 7 : 5;

      ctx.beginPath();
      ctx.arc(s.x,s.y, r, 0, Math.PI*2);

      if (p.kind === 'intersection') ctx.fillStyle = 'rgba(120, 255, 160, 0.95)';
      else ctx.fillStyle = 'rgba(120, 200, 255, 0.95)';
      if (isSel) ctx.fillStyle = 'rgba(255, 220, 120, 0.95)';

      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgba(255,255,255,0.35)';
      ctx.stroke();
    }
  }

  function drawStepPreview(){
    const P = mouseWorld;

    if (tool==='segment' && stepA){
      const a=getPoint(stepA); if (!a) return;
      const sa=worldToScreen(a.x,a.y);
      const sb=worldToScreen(P.x,P.y);
      ctx.setLineDash([6,6]);
      ctx.strokeStyle='rgba(255,255,255,0.35)';
      ctx.lineWidth=2;
      ctx.beginPath(); ctx.moveTo(sa.x,sa.y); ctx.lineTo(sb.x,sb.y); ctx.stroke();
      ctx.setLineDash([]);
    }

    if (tool==='line' && stepA){
      const a=getPoint(stepA); if (!a) return;
      const A=worldToScreen(a.x,a.y);
      const B=worldToScreen(P.x,P.y);
      const dx=B.x-A.x, dy=B.y-A.y;
      if (Math.hypot(dx,dy)<1e-6) return;
      const w=window.innerWidth, h=window.innerHeight;
      const candidates=[];
      function addIfValid(t){
        const x=A.x+dx*t, y=A.y+dy*t;
        if (x>=-1 && x<=w+1 && y>=-1 && y<=h+1) candidates.push({x,y});
      }
      if (Math.abs(dx)>1e-9){ addIfValid((0-A.x)/dx); addIfValid((w-A.x)/dx); }
      if (Math.abs(dy)>1e-9){ addIfValid((0-A.y)/dy); addIfValid((h-A.y)/dy); }
      if (candidates.length<2) return;
      let p0=candidates[0], p1=candidates[1], best=0;
      for (let i=0;i<candidates.length;i++){
        for (let j=i+1;j<candidates.length;j++){
          const dd=(candidates[i].x-candidates[j].x)**2+(candidates[i].y-candidates[j].y)**2;
          if (dd>best){ best=dd; p0=candidates[i]; p1=candidates[j]; }
        }
      }
      ctx.setLineDash([6,6]);
      ctx.strokeStyle='rgba(255,255,255,0.35)';
      ctx.lineWidth=2;
      ctx.beginPath(); ctx.moveTo(p0.x,p0.y); ctx.lineTo(p1.x,p1.y); ctx.stroke();
      ctx.setLineDash([]);
    }

    if (tool==='circle' && circleCenterId){
      const c=getPoint(circleCenterId); if (!c) return;
      const r=len(sub(v(P.x,P.y), v(c.x,c.y)));
      const sc=worldToScreen(c.x,c.y);
      ctx.setLineDash([6,6]);
      ctx.strokeStyle='rgba(200,255,200,0.35)';
      ctx.lineWidth=2;
      ctx.beginPath(); ctx.arc(sc.x,sc.y, r*scale, 0, Math.PI*2); ctx.stroke();
      ctx.setLineDash([]);
    }
  }

  function draw(){
    updateIntersectionPoints();
    cleanupAll();
    drawGrid();
    drawLines();
    drawSegments();
    drawCircles();
    drawParabolas();
    drawStepPreview();
    drawPoints();
  }

  // -------------------------
  // Click helpers
  // -------------------------
  function pickOrCreatePoint(sx,sy){
    const hit=hitPoint(sx,sy);
    if (hit) return hit.id;
    const w=screenToWorld(sx,sy);
    return addFreePoint(w.x,w.y);
  }

  // -------------------------
  // Events
  // -------------------------
  canvas.addEventListener('pointermove', (e) => {
    const {sx,sy}=getCanvasLocalXY(e);
    const w=screenToWorld(sx,sy);
    mouseWorld=w;
    readout.textContent = `마우스: (${w.x.toFixed(2)}, ${w.y.toFixed(2)})`;
    if ((tool==='segment' && stepA) || (tool==='line' && stepA) || (tool==='circle' && circleCenterId)) draw();
  });

  canvas.addEventListener('click', (e) => {
    const {sx,sy}=getCanvasLocalXY(e);

    if (tool==='point'){
      if (hitPoint(sx,sy)) return;
      if (tryCreateIntersectionAtClick(sx,sy)) return;
      const w=screenToWorld(sx,sy);
      addFreePoint(w.x,w.y);
      return;
    }

    if (tool==='segment'){
      const pid=pickOrCreatePoint(sx,sy);
      if (!stepA){
        stepA=pid;
        showTip('선분: 첫 점 선택됨 → 둘째 점을 선택하세요.', toolSegmentBtn, 1300);
        draw();
        return;
      }
      if (stepA===pid){
        stepA=null;
        showTip('선분: 첫 점 선택 취소', toolSegmentBtn, 1100);
        draw();
        return;
      }
      addSegment(stepA, pid);
      stepA=null; // pair reset
      showTip('선분 생성 완료', toolSegmentBtn, 900);
      return;
    }

    if (tool==='line'){
      const pid=pickOrCreatePoint(sx,sy);
      if (!stepA){
        stepA=pid;
        showTip('직선: 첫 점 선택됨 → 둘째 점을 선택하세요.', toolLineBtn, 1300);
        draw();
        return;
      }
      if (stepA===pid){
        stepA=null;
        showTip('직선: 첫 점 선택 취소', toolLineBtn, 1100);
        draw();
        return;
      }
      addLine(stepA, pid);
      stepA=null;
      showTip('직선 생성 완료', toolLineBtn, 900);
      return;
    }

    if (tool==='circle'){
      const pid=pickOrCreatePoint(sx,sy);
      if (!circleCenterId){
        circleCenterId=pid;
        showTip('원: 중심 선택됨 → 원 위의 점을 선택하세요.', toolCircleBtn, 1300);
        draw();
        return;
      }
      if (circleCenterId===pid){
        circleCenterId=null;
        showTip('원: 중심 선택 취소', toolCircleBtn, 1100);
        draw();
        return;
      }
      addCircle(circleCenterId, pid);
      circleCenterId=null;
      showTip('원 생성 완료', toolCircleBtn, 900);
      return;
    }

    if (tool==='parabola'){
      if (!parabolaFocusId){
        parabolaFocusId = pickOrCreatePoint(sx,sy);
        showTip('포물선: 초점 선택됨 → 준선을 선택하세요(직선/선분/두 점).', toolParabolaBtn, 1500);
        draw();
        return;
      }

      // choose directrix by clicking line or segment
      const hitL = hitLineObj(sx,sy);
      if (hitL){
        addParabola(parabolaFocusId, hitL.a_id, hitL.b_id);
        parabolaFocusId=null;
        parabolaDirFirstId=null;
        showTip('포물선 생성 완료(준선=직선).', toolParabolaBtn, 1200);
        return;
      }

      const hitS = hitSegmentObj(sx,sy);
      if (hitS){
        addParabola(parabolaFocusId, hitS.a_id, hitS.b_id);
        parabolaFocusId=null;
        parabolaDirFirstId=null;
        showTip('포물선 생성 완료(준선=선분의 연장선).', toolParabolaBtn, 1400);
        return;
      }

      // else: directrix by two points
      const pid = pickOrCreatePoint(sx,sy);
      if (!parabolaDirFirstId){
        parabolaDirFirstId=pid;
        showTip('포물선: 준선 첫 점 선택됨 → 준선 둘째 점을 선택하세요.', toolParabolaBtn, 1500);
        draw();
        return;
      }
      if (parabolaDirFirstId===pid){
        parabolaDirFirstId=null;
        showTip('포물선: 준선 첫 점 선택 취소', toolParabolaBtn, 1200);
        draw();
        return;
      }

      addParabola(parabolaFocusId, parabolaDirFirstId, pid);
      parabolaFocusId=null;
      parabolaDirFirstId=null;
      showTip('포물선 생성 완료(준선=두 점을 잇는 직선).', toolParabolaBtn, 1400);
      return;
    }
  });

  // -------------------------
  // Select/Move tool
  // -------------------------
  canvas.addEventListener('pointerdown', (e) => {
    if (tool !== 'select') return;
    const {sx,sy}=getCanvasLocalXY(e);
    const hit=hitPoint(sx,sy);

    if (!hit){ selectedPointId=null; draw(); return; }
    selectedPointId = hit.id;

    if (hit.kind === 'intersection') {
      showTip('교점(종속점)은 이동할 수 없습니다.', toolSelectBtn, 1200);
      draw();
      return;
    }

    dragging=true;
    dragPointerId=e.pointerId;

    const w=screenToWorld(sx,sy);
    dragOffset.x = w.x - hit.x;
    dragOffset.y = w.y - hit.y;

    try { canvas.setPointerCapture(e.pointerId); } catch {}
    showTip('자유점 선택됨. 드래그하여 이동하세요.', toolSelectBtn, 1000);
    draw();
  });

  canvas.addEventListener('pointermove', (e) => {
    if (tool !== 'select') return;
    if (!dragging) return;
    if (e.pointerId !== dragPointerId) return;
    if (!selectedPointId) return;

    const p=getPoint(selectedPointId);
    if (!p || p.kind !== 'free') return;

    const {sx,sy}=getCanvasLocalXY(e);
    const w=screenToWorld(sx,sy);
    p.x = w.x - dragOffset.x;
    p.y = w.y - dragOffset.y;

    draw();
  });

  function endDrag(e){
    if (tool !== 'select') return;
    if (!dragging) return;
    if (e.pointerId !== dragPointerId) return;

    dragging=false;
    try { canvas.releasePointerCapture(e.pointerId); } catch {}
    dragPointerId=null;

    saveState();
    showTip('이동이 저장되었습니다.', toolSelectBtn, 900);
  }
  canvas.addEventListener('pointerup', endDrag);
  canvas.addEventListener('pointercancel', endDrag);

  // -------------------------
  // Undo / Clear
  // -------------------------
  function undoPoint(){
    if (!points.length){ showTip('되돌릴 점이 없습니다.', btnUndoPoint, 900); return; }
    points.pop();
    cleanupAll(); saveState(); draw();
    showTip('점 되돌리기 완료', btnUndoPoint, 900);
  }
  function undoSeg(){
    if (!segments.length){ showTip('되돌릴 선분이 없습니다.', btnUndoSeg, 900); return; }
    segments.pop();
    cleanupAll(); saveState(); draw();
    showTip('선분 되돌리기 완료', btnUndoSeg, 900);
  }
  function undoLine(){
    if (!lines.length){ showTip('되돌릴 직선이 없습니다.', btnUndoLine, 900); return; }
    lines.pop();
    cleanupAll(); saveState(); draw();
    showTip('직선 되돌리기 완료', btnUndoLine, 900);
  }
  function undoCircle(){
    if (!circles.length){ showTip('되돌릴 원이 없습니다.', btnUndoCircle, 900); return; }
    circles.pop();
    cleanupAll(); saveState(); draw();
    showTip('원 되돌리기 완료', btnUndoCircle, 900);
  }
  function undoParabola(){
    if (!parabolas.length){ showTip('되돌릴 포물선이 없습니다.', btnUndoParabola, 900); return; }
    parabolas.pop();
    cleanupAll(); saveState(); draw();
    showTip('포물선 되돌리기 완료', btnUndoParabola, 900);
  }
  function clearAll(){
    points=[]; segments=[]; lines=[]; circles=[]; parabolas=[];
    selectedPointId=null;
    cancelStep(false);
    saveState(); draw();
    showTip('전체 삭제 완료', btnClearAll, 900);
  }

  // -------------------------
  // Buttons
  // -------------------------
  toolPointBtn.addEventListener('click', () => setTool('point', toolPointBtn));
  toolSegmentBtn.addEventListener('click', () => setTool('segment', toolSegmentBtn));
  toolLineBtn.addEventListener('click', () => setTool('line', toolLineBtn));
  toolCircleBtn.addEventListener('click', () => setTool('circle', toolCircleBtn));
  toolParabolaBtn.addEventListener('click', () => setTool('parabola', toolParabolaBtn));
  toolSelectBtn.addEventListener('click', () => setTool('select', toolSelectBtn));

  btnUndoPoint.addEventListener('click', undoPoint);
  btnUndoSeg.addEventListener('click', undoSeg);
  btnUndoLine.addEventListener('click', undoLine);
  btnUndoCircle.addEventListener('click', undoCircle);
  btnUndoParabola.addEventListener('click', undoParabola);
  btnClearAll.addEventListener('click', clearAll);
  btnCancelStep.addEventListener('click', () => cancelStep(true));

  // Shortcuts
  window.addEventListener('keydown', (e) => {
    const k = e.key.toLowerCase();
    if (k === 'p') setTool('point', null);
    if (k === 'g') setTool('segment', null);
    if (k === 'l') setTool('line', null);
    if (k === 'c') setTool('circle', null);
    if (k === 'a') setTool('parabola', null);
    if (k === 'v') setTool('select', null);
    if (k === 'escape') cancelStep(true);
  });

  // init
  cleanupAll();
  saveState();
  window.addEventListener('resize', resize);
  resize();
  draw();

  if (didPurge) showTip('이전 찌꺼기를 자동 삭제하고 새 버전으로 시작합니다.', null, 1800);
  else showTip('HTML 단일 파일 버전입니다. (포물선 + 교점 생성 포함)', null, 1800);
})();
</script>
</body>
</html>
