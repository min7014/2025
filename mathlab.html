<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Math Tool - Local (i18n KO/EN)</title>
  <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate, max-age=0" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <style>
    html, body { height: 100%; margin: 0; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background: #0b0f14; color: #e6edf3; }
    .topbar { position: fixed; top: 12px; left: 12px; right: 12px; display:flex; gap:8px; align-items:center; z-index:10; flex-wrap:wrap; }
    .panel { background: rgba(20,26,34,0.85); border: 1px solid rgba(255,255,255,0.08); backdrop-filter: blur(8px);
      border-radius: 12px; padding: 10px 12px; display:flex; gap:10px; align-items:center; box-shadow: 0 10px 30px rgba(0,0,0,0.35); }
    button { background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.12); color:#e6edf3; padding:8px 10px; border-radius:10px;
      cursor:pointer; user-select:none; white-space:nowrap; }
    button:hover { background: rgba(255,255,255,0.12); }
    button.active { background: rgba(120,200,255,0.22); border-color: rgba(120,200,255,0.35); }
    .readout { opacity:0.9; font-size:13px; }
    canvas { display:block; width:100%; height:100%; touch-action:none; }
    .footer { position:fixed; bottom:12px; left:12px; background: rgba(20,26,34,0.75); border:1px solid rgba(255,255,255,0.08);
      border-radius:12px; padding:10px 12px; font-size:12px; opacity:0.88; line-height:1.35; z-index:10;
      max-width:min(980px, calc(100vw - 24px)); }
    code { background: rgba(255,255,255,0.08); padding:2px 6px; border-radius:8px; }

    /* language "tab" feel */
    .langWrap { display:flex; gap:0; overflow:hidden; border-radius: 10px; border: 1px solid rgba(255,255,255,0.12); }
    .langWrap button { border-radius:0; border:none; background: rgba(255,255,255,0.06); padding:8px 12px; }
    .langWrap button + button { border-left: 1px solid rgba(255,255,255,0.12); }
    .langWrap button.active { background: rgba(255,255,255,0.14); }

    .tip { position:fixed; z-index:9999; display:none; background: rgba(20,26,34,0.94); border:1px solid rgba(255,255,255,0.10);
      border-radius:12px; padding:10px 12px; box-shadow: 0 18px 44px rgba(0,0,0,0.45); backdrop-filter: blur(10px);
      max-width:min(560px, calc(100vw - 24px)); font-size:13px; line-height:1.35; opacity:0; pointer-events:none;
      transform: translateY(-4px); transition: opacity 160ms ease, transform 160ms ease; }
    .tip.show { display:block; opacity:1; transform: translateY(0); }
    .tip.hide { opacity:0; transform: translateY(-6px); }
    .tip b { color: rgba(255,230,160,0.95); }
  </style>
</head>
<body>
  <div class="topbar">
    <div class="panel">
      <button id="toolPoint" class="active" type="button">점</button>
      <button id="toolSegment" type="button">선분</button>
      <button id="toolLine" type="button">직선</button>
      <button id="toolCircle" type="button">원</button>
      <button id="toolParabola" type="button">포물선</button>
      <button id="toolSelect" type="button">선택/이동</button>
      <span class="readout" id="readout"></span>
    </div>

    <!-- ✅ Language selection tab -->
    <div class="panel">
      <div class="langWrap" role="tablist" aria-label="Language">
        <button id="langKo" class="active" type="button" role="tab" aria-selected="true">한국어</button>
        <button id="langEn" type="button" role="tab" aria-selected="false">English</button>
      </div>
    </div>

    <div class="panel">
      <button id="btnUndoPoint" type="button">점 되돌리기</button>
      <button id="btnUndoSeg" type="button">선분 되돌리기</button>
      <button id="btnUndoLine" type="button">직선 되돌리기</button>
      <button id="btnUndoCircle" type="button">원 되돌리기</button>
      <button id="btnUndoParabola" type="button">포물선 되돌리기</button>
      <button id="btnClearAll" type="button">전체 삭제</button>
      <button id="btnCancelStep" type="button">현재 단계 취소(ESC)</button>
    </div>
  </div>

  <canvas id="c"></canvas>

  <div class="footer" id="footer"></div>

  <div id="tip" class="tip" aria-live="polite"></div>

<script>
(() => {
  // =================
  // 0) 찌꺼기 삭제
  // =================
  const BUILD_ID = "2026-01-08-i18n-tabs-01";
  const BUILD_KEY = "mathlab_build_id";

  function purgeOldLocalStorageIfNeeded() {
    try {
      const prev = localStorage.getItem(BUILD_KEY);
      if (prev === BUILD_ID) return false;
      const del = [];
      for (let i = 0; i < localStorage.length; i++) {
        const k = localStorage.key(i);
        if (k && k.startsWith("mathlab_")) del.push(k);
      }
      for (const k of del) localStorage.removeItem(k);
      localStorage.setItem(BUILD_KEY, BUILD_ID);
      return true;
    } catch { return false; }
  }
  const didPurge = purgeOldLocalStorageIfNeeded();

  // DOM
  const canvas = document.getElementById('c');
  const ctx = canvas?.getContext?.('2d');
  const readout = document.getElementById('readout');
  const tipEl = document.getElementById('tip');
  const footerEl = document.getElementById('footer');

  const toolPointBtn = document.getElementById('toolPoint');
  const toolSegmentBtn = document.getElementById('toolSegment');
  const toolLineBtn = document.getElementById('toolLine');
  const toolCircleBtn = document.getElementById('toolCircle');
  const toolParabolaBtn = document.getElementById('toolParabola');
  const toolSelectBtn = document.getElementById('toolSelect');

  const langKoBtn = document.getElementById('langKo');
  const langEnBtn = document.getElementById('langEn');

  const btnUndoPoint = document.getElementById('btnUndoPoint');
  const btnUndoSeg = document.getElementById('btnUndoSeg');
  const btnUndoLine = document.getElementById('btnUndoLine');
  const btnUndoCircle = document.getElementById('btnUndoCircle');
  const btnUndoParabola = document.getElementById('btnUndoParabola');
  const btnClearAll = document.getElementById('btnClearAll');
  const btnCancelStep = document.getElementById('btnCancelStep');

  if (!canvas || !ctx || !readout || !tipEl || !footerEl ||
      !toolPointBtn || !toolSegmentBtn || !toolLineBtn || !toolCircleBtn || !toolParabolaBtn || !toolSelectBtn ||
      !langKoBtn || !langEnBtn ||
      !btnUndoPoint || !btnUndoSeg || !btnUndoLine || !btnUndoCircle || !btnUndoParabola || !btnClearAll || !btnCancelStep) {
    alert('UI 요소 로딩에 실패했습니다. HTML이 손상되었는지 확인해 주세요.');
    return;
  }

  // =================
  // 1) i18n (KO/EN)
  // =================
  const LANG_KEY = "mathlab_lang";
  let lang = (localStorage.getItem(LANG_KEY) === "en") ? "en" : "ko";

  const I18N = {
    ko: {
      // buttons
      toolPoint: "점",
      toolSegment: "선분",
      toolLine: "직선",
      toolCircle: "원",
      toolParabola: "포물선",
      toolSelect: "선택/이동",
      undoPoint: "점 되돌리기",
      undoSeg: "선분 되돌리기",
      undoLine: "직선 되돌리기",
      undoCircle: "원 되돌리기",
      undoParabola: "포물선 되돌리기",
      clearAll: "전체 삭제",
      cancelStep: "현재 단계 취소(ESC)",
      mouse: "마우스",

      // tool tips (html)
      tooltip_point: "<b>점</b>: (1) 교점 근처 클릭=교점 생성, (2) 도형 위 클릭=구속점 생성, (3) 빈 곳 클릭=자유점",
      tooltip_segment: "<b>선분</b>: 첫 점 → 둘째 점 (2점씩 짝지어 생성)",
      tooltip_line: "<b>직선</b>: 첫 점 → 둘째 점",
      tooltip_circle: "<b>원</b>: 중심 → 원 위의 점",
      tooltip_parabola: "<b>포물선</b>: 초점(점) → 준선(직선/선분/두 점)",
      tooltip_select: "<b>선택/이동</b>: 자유점/구속점 이동 가능(구속점은 도형 위로만), 교점은 이동 불가",

      // footer (html)
      footer_html:
        "✅ 상태는 <b>브라우저(localStorage)</b>에만 저장됩니다(서버 저장 0)<br/>" +
        "✅ <b>점 도구</b>: (1) 교점 근처 클릭 → <b>교점(종속점)</b> 생성 (포물선-포물선 포함)<br/>" +
        "✅ <b>점 도구</b>: (2) 선분/직선/원/포물선 위 클릭 → <b>구속점</b> 생성(해당 도형 위에서만 이동)<br/>" +
        "✅ <b>선택/이동</b>: 자유점/구속점은 이동 가능, 교점은 이동 불가<br/>" +
        "단축키: <code>P</code>=점, <code>G</code>=선분, <code>L</code>=직선, <code>C</code>=원, <code>A</code>=포물선, <code>V</code>=선택, <code>ESC</code>=단계취소",

      // messages
      step_cancelled: "현재 단계가 취소되었습니다.",
      intersection_created: "교점이 생성되었습니다(종속점).",
      constrained_created: "구속점이 생성되었습니다(도형 위에서만 이동).",
      seg_first: "선분: 첫 점 선택됨 → 둘째 점을 선택하세요.",
      seg_first_cancel: "선분: 첫 점 선택 취소",
      seg_done: "선분 생성 완료",
      line_first: "직선: 첫 점 선택됨 → 둘째 점을 선택하세요.",
      line_first_cancel: "직선: 첫 점 선택 취소",
      line_done: "직선 생성 완료",
      circle_center: "원: 중심 선택됨 → 원 위의 점을 선택하세요.",
      circle_center_cancel: "원: 중심 선택 취소",
      circle_done: "원 생성 완료",
      parabola_focus: "포물선: 초점 선택됨 → 준선을 선택하세요(직선/선분/두 점).",
      parabola_dir_first: "포물선: 준선 첫 점 선택됨 → 준선 둘째 점을 선택하세요.",
      parabola_dir_first_cancel: "포물선: 준선 첫 점 선택 취소",
      parabola_done_line: "포물선 생성 완료(준선=직선).",
      parabola_done_segment: "포물선 생성 완료(준선=선분의 연장선).",
      parabola_done_2pts: "포물선 생성 완료(준선=두 점을 잇는 직선).",
      intersection_immovable: "교점(종속점)은 이동할 수 없습니다.",
      free_selected: "자유점 선택됨. 드래그하여 이동하세요.",
      constrained_selected: "구속점 선택됨. 도형 위에서만 이동합니다.",
      moved_saved: "이동이 저장되었습니다.",
      nothing_undo_point: "되돌릴 점이 없습니다.",
      nothing_undo_seg: "되돌릴 선분이 없습니다.",
      nothing_undo_line: "되돌릴 직선이 없습니다.",
      nothing_undo_circle: "되돌릴 원이 없습니다.",
      nothing_undo_parabola: "되돌릴 포물선이 없습니다.",
      undo_point_done: "점 되돌리기 완료",
      undo_seg_done: "선분 되돌리기 완료",
      undo_line_done: "직선 되돌리기 완료",
      undo_circle_done: "원 되돌리기 완료",
      undo_parabola_done: "포물선 되돌리기 완료",
      cleared: "전체 삭제 완료",
      init_purged: "이전 찌꺼기를 자동 삭제하고 새 버전으로 시작합니다.",
      init_ok: "언어 선택 탭(KO/EN) 지원 버전입니다.",
      lang_switched: "언어가 변경되었습니다."
    },
    en: {
      // buttons
      toolPoint: "Point",
      toolSegment: "Segment",
      toolLine: "Line",
      toolCircle: "Circle",
      toolParabola: "Parabola",
      toolSelect: "Select/Move",
      undoPoint: "Undo Point",
      undoSeg: "Undo Segment",
      undoLine: "Undo Line",
      undoCircle: "Undo Circle",
      undoParabola: "Undo Parabola",
      clearAll: "Clear All",
      cancelStep: "Cancel Step (ESC)",
      mouse: "Mouse",

      // tool tips (html)
      tooltip_point: "<b>Point</b>: (1) Click near an intersection → intersection point, (2) Click on an object → constrained point, (3) Click empty space → free point",
      tooltip_segment: "<b>Segment</b>: first point → second point (creates in pairs)",
      tooltip_line: "<b>Line</b>: first point → second point",
      tooltip_circle: "<b>Circle</b>: center → point on circle",
      tooltip_parabola: "<b>Parabola</b>: focus(point) → directrix(line/segment/two points)",
      tooltip_select: "<b>Select/Move</b>: free & constrained points are draggable (constrained stays on object), intersections are not draggable",

      // footer (html)
      footer_html:
        "✅ State is stored <b>only in your browser (localStorage)</b> (no server storage)<br/>" +
        "✅ <b>Point tool</b>: (1) Click near an intersection → <b>dependent intersection point</b> (includes parabola–parabola)<br/>" +
        "✅ <b>Point tool</b>: (2) Click on segment/line/circle/parabola → <b>constrained point</b> (moves only on that object)<br/>" +
        "✅ <b>Select/Move</b>: free & constrained points can move; intersection points cannot<br/>" +
        "Shortcuts: <code>P</code>=Point, <code>G</code>=Segment, <code>L</code>=Line, <code>C</code>=Circle, <code>A</code>=Parabola, <code>V</code>=Select, <code>ESC</code>=Cancel",

      // messages
      step_cancelled: "Current step has been cancelled.",
      intersection_created: "Intersection point created (dependent).",
      constrained_created: "Constrained point created (moves only on the object).",
      seg_first: "Segment: first point selected → choose the second point.",
      seg_first_cancel: "Segment: first point selection cancelled.",
      seg_done: "Segment created.",
      line_first: "Line: first point selected → choose the second point.",
      line_first_cancel: "Line: first point selection cancelled.",
      line_done: "Line created.",
      circle_center: "Circle: center selected → choose a point on the circle.",
      circle_center_cancel: "Circle: center selection cancelled.",
      circle_done: "Circle created.",
      parabola_focus: "Parabola: focus selected → choose the directrix (line/segment/two points).",
      parabola_dir_first: "Parabola: first directrix point selected → choose the second point.",
      parabola_dir_first_cancel: "Parabola: first directrix point selection cancelled.",
      parabola_done_line: "Parabola created (directrix = line).",
      parabola_done_segment: "Parabola created (directrix = extension of segment).",
      parabola_done_2pts: "Parabola created (directrix = line through two points).",
      intersection_immovable: "Intersection (dependent) points cannot be dragged.",
      free_selected: "Free point selected. Drag to move.",
      constrained_selected: "Constrained point selected. It stays on the object.",
      moved_saved: "Move saved.",
      nothing_undo_point: "No point to undo.",
      nothing_undo_seg: "No segment to undo.",
      nothing_undo_line: "No line to undo.",
      nothing_undo_circle: "No circle to undo.",
      nothing_undo_parabola: "No parabola to undo.",
      undo_point_done: "Point undone.",
      undo_seg_done: "Segment undone.",
      undo_line_done: "Line undone.",
      undo_circle_done: "Circle undone.",
      undo_parabola_done: "Parabola undone.",
      cleared: "Cleared.",
      init_purged: "Old leftovers were removed and a fresh version started.",
      init_ok: "This version supports the language tabs (KO/EN).",
      lang_switched: "Language switched."
    }
  };

  function t(key){ return (I18N[lang] && I18N[lang][key]) || I18N.ko[key] || key; }

  function applyLanguageToUI(){
    // html lang
    document.documentElement.lang = (lang === "en") ? "en" : "ko";

    // tool buttons
    toolPointBtn.textContent = t("toolPoint");
    toolSegmentBtn.textContent = t("toolSegment");
    toolLineBtn.textContent = t("toolLine");
    toolCircleBtn.textContent = t("toolCircle");
    toolParabolaBtn.textContent = t("toolParabola");
    toolSelectBtn.textContent = t("toolSelect");

    // action buttons
    btnUndoPoint.textContent = t("undoPoint");
    btnUndoSeg.textContent = t("undoSeg");
    btnUndoLine.textContent = t("undoLine");
    btnUndoCircle.textContent = t("undoCircle");
    btnUndoParabola.textContent = t("undoParabola");
    btnClearAll.textContent = t("clearAll");
    btnCancelStep.textContent = t("cancelStep");

    // footer
    footerEl.innerHTML = t("footer_html");

    // lang tabs visual
    langKoBtn.classList.toggle("active", lang === "ko");
    langEnBtn.classList.toggle("active", lang === "en");
    langKoBtn.setAttribute("aria-selected", lang === "ko" ? "true" : "false");
    langEnBtn.setAttribute("aria-selected", lang === "en" ? "true" : "false");
  }

  function setLang(newLang, anchor=null){
    lang = (newLang === "en") ? "en" : "ko";
    localStorage.setItem(LANG_KEY, lang);
    applyLanguageToUI();
    showTip(t("lang_switched"), anchor, 900);
    draw();
  }

  // Tooltip
  let tipTimer=null, tipHideTimer=null;
  const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
  function hideTip(){
    tipEl.classList.remove('show'); tipEl.classList.add('hide');
    if (tipHideTimer) clearTimeout(tipHideTimer);
    tipHideTimer=setTimeout(()=>{ if (tipEl.classList.contains('hide')) tipEl.style.display='none'; }, 200);
  }
  function positionTip(anchorEl){
    const padding=10, gap=10;
    const tw=Math.max(1, tipEl.offsetWidth), th=Math.max(1, tipEl.offsetHeight);
    if (!anchorEl || !anchorEl.getBoundingClientRect){
      const left=Math.round((window.innerWidth - tw)/2), top=72;
      tipEl.style.left=`${clamp(left,padding,window.innerWidth-padding-tw)}px`;
      tipEl.style.top =`${clamp(top ,padding,window.innerHeight-padding-th)}px`;
      return;
    }
    const r=anchorEl.getBoundingClientRect();
    let left=r.right+gap, top=r.top+(r.height-th)/2;
    if (left+tw > window.innerWidth-padding) left = r.left-gap-tw;
    left=clamp(left,padding,window.innerWidth-padding-tw);
    top =clamp(top ,padding,window.innerHeight-padding-th);
    tipEl.style.left=`${Math.round(left)}px`;
    tipEl.style.top =`${Math.round(top)}px`;
  }
  function showTip(html, anchorEl=null, ms=1600){
    if (tipTimer) clearTimeout(tipTimer);
    tipEl.innerHTML=html;
    tipEl.style.display='block';
    tipEl.classList.remove('hide'); tipEl.classList.add('show');
    requestAnimationFrame(()=>positionTip(anchorEl));
    tipTimer=setTimeout(hideTip, ms);
  }
  window.addEventListener('resize', hideTip);
  window.addEventListener('scroll', hideTip, true);

  // Storage
  const STORAGE_KEY="mathlab_state_geo_v2";
  const safeNum = (x,f=0)=> (Number.isFinite(Number(x)) ? Number(x) : f);

  function sanitizeState(obj){
    const safe={ points:[], segments:[], lines:[], circles:[], parabolas:[] };
    if (!obj || typeof obj!=='object') return safe;

    const pts = Array.isArray(obj.points)?obj.points:[];
    const segs= Array.isArray(obj.segments)?obj.segments:[];
    const lns = Array.isArray(obj.lines)?obj.lines:[];
    const cirs= Array.isArray(obj.circles)?obj.circles:[];
    const pars= Array.isArray(obj.parabolas)?obj.parabolas:[];

    for (const p of pts){
      if (!p || typeof p!=='object') continue;
      if (typeof p.id!=='string' || !p.id) continue;

      let kind = 'free';
      if (p.kind==='intersection') kind='intersection';
      else if (p.kind==='constrained') kind='constrained';

      const base={ id:p.id, x:safeNum(p.x,0), y:safeNum(p.y,0), kind };

      if (kind==='intersection'){
        const pa=p.parents?.a, pb=p.parents?.b;
        if (!pa||!pb) continue;
        if (typeof pa.kind!=='string'||typeof pa.id!=='string') continue;
        if (typeof pb.kind!=='string'||typeof pb.id!=='string') continue;
        base.parents={ a:{kind:pa.kind,id:pa.id}, b:{kind:pb.kind,id:pb.id} };
      }

      if (kind==='constrained'){
        const c=p.constraint;
        if (!c || typeof c!=='object') continue;
        if (typeof c.kind!=='string' || typeof c.id!=='string') continue;
        const k=c.kind;
        const out={ kind:k, id:c.id, param:{} };
        if (k==='segment' || k==='line'){
          out.param.t = safeNum(c.param?.t, 0);
        } else if (k==='circle'){
          out.param.ang = safeNum(c.param?.ang, 0);
        } else if (k==='parabola'){
          out.param.u = safeNum(c.param?.u, 0);
        } else continue;
        base.constraint=out;
      }

      safe.points.push(base);
    }

    const pointIds=new Set(safe.points.map(p=>p.id));

    for (const s of segs){
      if (!s||typeof s!=='object') continue;
      if (typeof s.id!=='string'||!s.id) continue;
      if (typeof s.a_id!=='string'||typeof s.b_id!=='string') continue;
      if (!pointIds.has(s.a_id)||!pointIds.has(s.b_id)||s.a_id===s.b_id) continue;
      safe.segments.push({ id:s.id, a_id:s.a_id, b_id:s.b_id });
    }
    for (const l of lns){
      if (!l||typeof l!=='object') continue;
      if (typeof l.id!=='string'||!l.id) continue;
      if (typeof l.a_id!=='string'||typeof l.b_id!=='string') continue;
      if (!pointIds.has(l.a_id)||!pointIds.has(l.b_id)||l.a_id===l.b_id) continue;
      safe.lines.push({ id:l.id, a_id:l.a_id, b_id:l.b_id });
    }
    for (const c of cirs){
      if (!c||typeof c!=='object') continue;
      if (typeof c.id!=='string'||!c.id) continue;
      if (typeof c.c_id!=='string'||typeof c.p_id!=='string') continue;
      if (!pointIds.has(c.c_id)||!pointIds.has(c.p_id)||c.c_id===c.p_id) continue;
      safe.circles.push({ id:c.id, c_id:c.c_id, p_id:c.p_id });
    }
    for (const p of pars){
      if (!p||typeof p!=='object') continue;
      if (typeof p.id!=='string'||!p.id) continue;
      if (typeof p.f_id!=='string'||!pointIds.has(p.f_id)) continue;
      if (typeof p.d_a_id!=='string'||typeof p.d_b_id!=='string') continue;
      if (!pointIds.has(p.d_a_id)||!pointIds.has(p.d_b_id)||p.d_a_id===p.d_b_id) continue;
      safe.parabolas.push({ id:p.id, f_id:p.f_id, d_a_id:p.d_a_id, d_b_id:p.d_b_id });
    }

    return safe;
  }

  function loadState(){
    try{
      const raw=localStorage.getItem(STORAGE_KEY);
      if (!raw) return sanitizeState(null);
      return sanitizeState(JSON.parse(raw));
    }catch{ return sanitizeState(null); }
  }
  function saveState(){
    try{ localStorage.setItem(STORAGE_KEY, JSON.stringify({points,segments,lines,circles,parabolas})); }
    catch{ showTip('Storage error.', null, 1600); }
  }

  // Geometry
  const EPS=1e-9;
  const v=(x,y)=>({x,y});
  const add=(a,b)=>({x:a.x+b.x,y:a.y+b.y});
  const sub=(a,b)=>({x:a.x-b.x,y:a.y-b.y});
  const mul=(a,k)=>({x:a.x*k,y:a.y*k});
  const dot=(a,b)=>a.x*b.x+a.y*b.y;
  const cross=(a,b)=>a.x*b.y-a.y*b.x;
  const len=(a)=>Math.hypot(a.x,a.y);
  const norm=(a)=>{ const L=len(a); return L<EPS?{x:1,y:0}:{x:a.x/L,y:a.y/L}; };
  const perp=(a)=>({x:-a.y,y:a.x});

  function distPointToLine(P,A,B){
    const AB=sub(B,A), n=perp(AB), nn=len(n);
    if (nn<EPS) return Infinity;
    return Math.abs(dot(sub(P,A), n))/nn;
  }
  function distPointToSegment(P,A,B){
    const AB=sub(B,A), ap=sub(P,A), ab2=dot(AB,AB);
    if (ab2<EPS) return len(sub(P,A));
    let t=dot(sub(P,A),AB)/ab2; t=Math.max(0,Math.min(1,t));
    const Q=add(A,mul(AB,t));
    return len(sub(P,Q));
  }
  function closestPointOnLine(P,A,B){
    const AB=sub(B,A), ab2=dot(AB,AB);
    if (ab2<EPS) return {Q:A, t:0};
    const t=dot(sub(P,A), AB)/ab2;
    return {Q:add(A,mul(AB,t)), t};
  }
  function closestPointOnSegment(P,A,B){
    const AB=sub(B,A), ab2=dot(AB,AB);
    if (ab2<EPS) return {Q:A, t:0};
    let t=dot(sub(P,A), AB)/ab2; t=Math.max(0,Math.min(1,t));
    return {Q:add(A,mul(AB,t)), t};
  }
  function closestPointOnCircle(P,C,r){
    const d=sub(P,C);
    let ang=Math.atan2(d.y,d.x);
    if (!Number.isFinite(ang)) ang=0;
    const Q=add(C, v(r*Math.cos(ang), r*Math.sin(ang)));
    return {Q, ang};
  }

  function lineLineIntersection(A,B,C,D){
    const r=sub(B,A), s=sub(D,C);
    const den=cross(r,s);
    if (Math.abs(den)<EPS) return null;
    const t=cross(sub(C,A), s)/den;
    return add(A,mul(r,t));
  }
  function segmentSegmentIntersection(A,B,C,D){
    const r=sub(B,A), s=sub(D,C);
    const den=cross(r,s);
    const CA=sub(C,A);
    if (Math.abs(den)<EPS) return null;
    const t=cross(CA, s)/den;
    const u=cross(CA, r)/den;
    if (t<-1e-9 || t>1+1e-9 || u<-1e-9 || u>1+1e-9) return null;
    return add(A,mul(r,t));
  }

  function circleLineIntersections(C0,r,A,B){
    const d=sub(B,A), f=sub(A,C0);
    const a=dot(d,d), b=2*dot(f,d), c=dot(f,f)-r*r;
    const disc=b*b-4*a*c;
    if (disc<-1e-10) return [];
    if (Math.abs(disc)<=1e-10){
      const t=-b/(2*a);
      return [ add(A,mul(d,t)) ];
    }
    const s=Math.sqrt(Math.max(0,disc));
    const t1=(-b - s)/(2*a), t2=(-b + s)/(2*a);
    return [ add(A,mul(d,t1)), add(A,mul(d,t2)) ];
  }

  function circleCircleIntersections(C1,r1,C2,r2){
    const d=len(sub(C2,C1));
    if (d<EPS) return [];
    if (d>r1+r2+1e-10) return [];
    if (d<Math.abs(r1-r2)-1e-10) return [];
    const a=(r1*r1 - r2*r2 + d*d)/(2*d);
    const h2=r1*r1 - a*a;
    if (h2<-1e-10) return [];
    const h=Math.sqrt(Math.max(0,h2));
    const u=mul(sub(C2,C1), 1/d);
    const P=add(C1, mul(u,a));
    const w=perp(u);
    if (h<1e-8) return [P];
    return [ add(P,mul(w,h)), add(P,mul(w,-h)) ];
  }

  // Parabola
  function parabolaParams(F,A,B){
    const d0=sub(B,A);
    const d=norm(d0);
    let n=norm(perp(d));
    let vF=dot(sub(F,A), n);
    if (vF<0){ n=mul(n,-1); vF=-vF; }
    const uF=dot(sub(F,A), d);
    return { A, d, n, uF, vF };
  }
  function worldToUV(X,par){ return { u: dot(sub(X,par.A), par.d), v: dot(sub(X,par.A), par.n) }; }
  function uvToWorld(u,v0,par){ return add(par.A, add(mul(par.d,u), mul(par.n,v0))); }
  function parabolaV(u,par){
    const vF=par.vF;
    if (vF<1e-9) return null;
    const t=u-par.uF;
    return (t*t + vF*vF)/(2*vF);
  }

  function parabolaLineIntersections(par,P0,P1,restrict01=false){
    const uv0=worldToUV(P0,par), uv1=worldToUV(P1,par);
    const du=uv1.u-uv0.u, dv=uv1.v-uv0.v;
    const a=du*du;
    const b=2*(uv0.u-par.uF)*du - 2*par.vF*dv;
    const c=(uv0.u-par.uF)*(uv0.u-par.uF) + par.vF*par.vF - 2*par.vF*uv0.v;
    const disc=b*b-4*a*c;

    if (Math.abs(a)<1e-12){
      if (Math.abs(b)<1e-12) return [];
      const t=-c/b;
      if (restrict01 && (t<-1e-9 || t>1+1e-9)) return [];
      return [ add(P0, mul(sub(P1,P0), t)) ];
    }

    if (disc<-1e-10) return [];
    if (Math.abs(disc)<=1e-10){
      const t=-b/(2*a);
      if (restrict01 && (t<-1e-9 || t>1+1e-9)) return [];
      return [ add(P0, mul(sub(P1,P0), t)) ];
    }

    const s=Math.sqrt(Math.max(0,disc));
    const t1=(-b - s)/(2*a), t2=(-b + s)/(2*a);
    const out=[];
    for (const t of [t1,t2]){
      if (restrict01 && (t<-1e-9 || t>1+1e-9)) continue;
      out.push(add(P0, mul(sub(P1,P0), t)));
    }
    return out;
  }

  function parabolaCircleIntersections(par,C0,r,uMin,uMax, quality='fast'){
    const N = (quality==='accurate') ? 220 : 140;
    const tol = 1e-5;
    const roots=[];

    function f(u){
      const vv=parabolaV(u,par);
      if (vv===null) return NaN;
      const X=uvToWorld(u,vv,par);
      const dx=X.x-C0.x, dy=X.y-C0.y;
      return (dx*dx+dy*dy)-r*r;
    }

    const step=(uMax-uMin)/N;
    let uPrev=uMin, fPrev=f(uPrev);

    for (let i=1;i<=N;i++){
      const uCur=uMin+step*i, fCur=f(uCur);

      if (Number.isFinite(fPrev) && Math.abs(fPrev)<tol) roots.push(uPrev);
      if (Number.isFinite(fCur) && Math.abs(fCur)<tol) roots.push(uCur);

      if (Number.isFinite(fPrev) && Number.isFinite(fCur) && fPrev*fCur<0){
        let a=uPrev,b=uCur, fa=fPrev, fb=fCur;
        for (let k=0;k<35;k++){
          const m=(a+b)/2, fm=f(m);
          if (!Number.isFinite(fm)) break;
          if (fa*fm<=0){ b=m; fb=fm; } else { a=m; fa=fm; }
        }
        roots.push((a+b)/2);
      }

      uPrev=uCur; fPrev=fCur;
    }

    roots.sort((x,y)=>x-y);
    const uniq=[];
    for (const u of roots){
      if (!uniq.length || Math.abs(u-uniq[uniq.length-1])>1e-3) uniq.push(u);
    }

    const pts=[];
    for (const u of uniq){
      const vv=parabolaV(u,par);
      if (vv===null) continue;
      pts.push(uvToWorld(u,vv,par));
    }
    return pts;
  }

  function closestPointOnParabola(P, par, uMin, uMax){
    const N=90;
    let bestU=uMin, bestD=Infinity;
    for (let i=0;i<=N;i++){
      const u=uMin+(uMax-uMin)*i/N;
      const vv=parabolaV(u,par);
      if (vv===null) continue;
      const X=uvToWorld(u,vv,par);
      const d2=(X.x-P.x)**2 + (X.y-P.y)**2;
      if (d2<bestD){ bestD=d2; bestU=u; }
    }
    const step=(uMax-uMin)/N;
    let a=Math.max(uMin, bestU-step), b=Math.min(uMax, bestU+step);
    function D(u){
      const vv=parabolaV(u,par);
      if (vv===null) return Infinity;
      const X=uvToWorld(u,vv,par);
      return (X.x-P.x)**2 + (X.y-P.y)**2;
    }
    for (let k=0;k<28;k++){
      const m1=a+(b-a)/3, m2=b-(b-a)/3;
      if (D(m1) < D(m2)) b=m2; else a=m1;
    }
    const u=(a+b)/2;
    const vv=parabolaV(u,par);
    const Q=(vv===null) ? P : uvToWorld(u,vv,par);
    return {Q, u};
  }

  // View
  let scale=40;
  let origin={x:0,y:0};
  function worldToScreen(wx,wy){ return {x:origin.x+wx*scale, y:origin.y-wy*scale}; }
  function screenToWorld(sx,sy){ return {x:(sx-origin.x)/scale, y:(origin.y-sy)/scale}; }

  function resize(){
    const dpr=window.devicePixelRatio||1;
    canvas.width=Math.floor(window.innerWidth*dpr);
    canvas.height=Math.floor(window.innerHeight*dpr);
    canvas.style.width=window.innerWidth+'px';
    canvas.style.height=window.innerHeight+'px';
    ctx.setTransform(dpr,0,0,dpr,0,0);
    origin.x=window.innerWidth/2;
    origin.y=window.innerHeight/2;
    draw();
  }
  function viewWorldBounds(){
    const w=window.innerWidth,h=window.innerHeight;
    const p1=screenToWorld(0,0), p2=screenToWorld(w,h);
    return { minx:Math.min(p1.x,p2.x), maxx:Math.max(p1.x,p2.x), miny:Math.min(p1.y,p2.y), maxy:Math.max(p1.y,p2.y) };
  }

  // State
  const st=loadState();
  let points=st.points, segments=st.segments, lines=st.lines, circles=st.circles, parabolas=st.parabolas;
  const uid=(prefix='')=> prefix + Date.now().toString(36) + '-' + Math.random().toString(36).slice(2,8);

  const getPoint=(pid)=> points.find(p=>p.id===pid)||null;
  const getSegment=(sid)=> segments.find(s=>s.id===sid)||null;
  const getLine=(lid)=> lines.find(l=>l.id===lid)||null;
  const getCircle=(cid)=> circles.find(c=>c.id===cid)||null;
  const getParabola=(pid)=> parabolas.find(p=>p.id===pid)||null;

  function cleanupAll(){
    const pids=new Set(points.map(p=>p.id));
    segments = segments.filter(s=> pids.has(s.a_id)&&pids.has(s.b_id)&&s.a_id!==s.b_id);
    lines    = lines.filter(l=> pids.has(l.a_id)&&pids.has(l.b_id)&&l.a_id!==l.b_id);
    circles  = circles.filter(c=> pids.has(c.c_id)&&pids.has(c.p_id)&&c.c_id!==c.p_id);
    parabolas= parabolas.filter(p=> pids.has(p.f_id)&&pids.has(p.d_a_id)&&pids.has(p.d_b_id)&&p.d_a_id!==p.d_b_id);

    const existsRef=(ref)=>{
      if (!ref) return false;
      if (ref.kind==='segment') return !!getSegment(ref.id);
      if (ref.kind==='line') return !!getLine(ref.id);
      if (ref.kind==='circle') return !!getCircle(ref.id);
      if (ref.kind==='parabola') return !!getParabola(ref.id);
      return false;
    };

    points = points.filter(p=>{
      if (p.kind==='intersection') return existsRef(p.parents?.a) && existsRef(p.parents?.b);
      if (p.kind==='constrained') return existsRef(p.constraint);
      return true;
    });
  }

  // Tools
  let tool='point';
  let selectedPointId=null;

  let stepA=null;
  let circleCenterId=null;
  let parabolaFocusId=null;
  let parabolaDirFirstId=null;

  let mouseWorld={x:0,y:0};

  let dragging=false;
  let dragPointerId=null;
  let dragOffset={x:0,y:0};

  const HIT_R=10;

  function cancelStep(showMsg=true){
    stepA=null; circleCenterId=null; parabolaFocusId=null; parabolaDirFirstId=null;
    if (showMsg) showTip(t("step_cancelled"), btnCancelStep, 1100);
    draw();
  }

  function setTool(tname, anchor=null){
    tool=tname;
    toolPointBtn.classList.toggle('active', tname==='point');
    toolSegmentBtn.classList.toggle('active', tname==='segment');
    toolLineBtn.classList.toggle('active', tname==='line');
    toolCircleBtn.classList.toggle('active', tname==='circle');
    toolParabolaBtn.classList.toggle('active', tname==='parabola');
    toolSelectBtn.classList.toggle('active', tname==='select');

    cancelStep(false);

    const msg = {
      point: t("tooltip_point"),
      segment: t("tooltip_segment"),
      line: t("tooltip_line"),
      circle: t("tooltip_circle"),
      parabola: t("tooltip_parabola"),
      select: t("tooltip_select")
    }[tname] || "";

    showTip(msg, anchor, 1800);
    draw();
  }

  // Hit tests
  function getCanvasLocalXY(e){
    const rect=canvas.getBoundingClientRect();
    return { sx:e.clientX-rect.left, sy:e.clientY-rect.top };
  }
  function hitPoint(sx,sy){
    let best=null, bestD2=Infinity;
    for (const p of points){
      const s=worldToScreen(p.x,p.y);
      const dx=s.x-sx, dy=s.y-sy;
      const d2=dx*dx+dy*dy;
      if (d2<bestD2){ bestD2=d2; best=p; }
    }
    return (best && bestD2<=HIT_R*HIT_R) ? best : null;
  }

  // Create points/objects
  function addFreePoint(wx,wy){
    const p={ id:uid('p-'), x:wx, y:wy, kind:'free' };
    points.push(p); cleanupAll(); saveState(); draw(); return p.id;
  }
  function addIntersectionPoint(wx,wy, refA, refB){
    const p={ id:uid('ip-'), x:wx, y:wy, kind:'intersection', parents:{a:refA,b:refB} };
    points.push(p); cleanupAll(); saveState(); draw(); return p.id;
  }
  function addConstrainedPoint(kind, objId, paramObj, wx, wy){
    const p={ id:uid('cp-'), x:wx, y:wy, kind:'constrained', constraint:{ kind, id:objId, param:paramObj } };
    points.push(p); cleanupAll(); saveState(); draw(); return p.id;
  }
  const addSegment=(a_id,b_id)=>{ segments.push({id:uid('s-'),a_id,b_id}); cleanupAll(); saveState(); draw(); };
  const addLine=(a_id,b_id)=>{ lines.push({id:uid('l-'),a_id,b_id}); cleanupAll(); saveState(); draw(); };
  const addCircle=(c_id,p_id)=>{ circles.push({id:uid('c-'),c_id,p_id}); cleanupAll(); saveState(); draw(); };
  const addParabola=(f_id, d_a_id, d_b_id)=>{ parabolas.push({id:uid('pa-'),f_id,d_a_id,d_b_id}); cleanupAll(); saveState(); draw(); };

  // Geometry getters
  const getLinePtsFromLineObj=(ln)=>{ const A=getPoint(ln.a_id),B=getPoint(ln.b_id); return (A&&B)?{A:v(A.x,A.y),B:v(B.x,B.y)}:null; };
  const getLinePtsFromSegmentObj=(sg)=>{ const A=getPoint(sg.a_id),B=getPoint(sg.b_id); return (A&&B)?{A:v(A.x,A.y),B:v(B.x,B.y)}:null; };
  const getCircleGeom=(c)=>{ const C=getPoint(c.c_id),P=getPoint(c.p_id); if(!C||!P) return null; const CC=v(C.x,C.y), PP=v(P.x,P.y); return {C:CC, r:len(sub(PP,CC))}; };
  const getParabolaGeom=(pb)=>{ const F=getPoint(pb.f_id),A=getPoint(pb.d_a_id),B=getPoint(pb.d_b_id); return (F&&A&&B)?{F:v(F.x,F.y),A:v(A.x,A.y),B:v(B.x,B.y)}:null; };

  // parabola-parabola (polyline)
  function parabolaPolyline(par, uMin, uMax, N){
    const pts=[];
    for (let i=0;i<=N;i++){
      const u=uMin+(uMax-uMin)*i/N;
      const vv=parabolaV(u,par);
      if (vv===null) continue;
      pts.push(uvToWorld(u,vv,par));
    }
    return pts;
  }
  function parabolaParabolaIntersections(par1, uMin1, uMax1, par2, uMin2, uMax2, quality='fast'){
    const N = (quality==='accurate') ? 140 : 70;
    const P1=parabolaPolyline(par1,uMin1,uMax1,N);
    const P2=parabolaPolyline(par2,uMin2,uMax2,N);
    const out=[];
    for (let i=0;i<P1.length-1;i++){
      const A=P1[i], B=P1[i+1];
      for (let j=0;j<P2.length-1;j++){
        const C=P2[j], D=P2[j+1];
        const X=segmentSegmentIntersection(A,B,C,D);
        if (X) out.push(X);
      }
    }
    out.sort((p,q)=>p.x-q.x || p.y-q.y);
    const uniq=[];
    for (const X of out){
      if (!uniq.length) { uniq.push(X); continue; }
      const Y=uniq[uniq.length-1];
      if ((X.x-Y.x)**2 + (X.y-Y.y)**2 > 1e-6) uniq.push(X);
    }
    return uniq;
  }

  function intersectionsBetween(ref1, ref2, mode='fast'){
    const k1=ref1.kind, k2=ref2.kind;
    const pair=[k1,k2].sort().join('|');

    if (pair==='line|line'){
      const l1=getLine((k1==='line')?ref1.id:ref2.id);
      const l2=getLine((k1==='line')?ref2.id:ref1.id);
      if(!l1||!l2) return [];
      const p1=getLinePtsFromLineObj(l1), p2=getLinePtsFromLineObj(l2);
      if(!p1||!p2) return [];
      const X=lineLineIntersection(p1.A,p1.B,p2.A,p2.B);
      return X?[X]:[];
    }

    if (pair==='segment|segment'){
      const s1=getSegment((k1==='segment')?ref1.id:ref2.id);
      const s2=getSegment((k1==='segment')?ref2.id:ref1.id);
      if(!s1||!s2) return [];
      const p1=getLinePtsFromSegmentObj(s1), p2=getLinePtsFromSegmentObj(s2);
      if(!p1||!p2) return [];
      const X=segmentSegmentIntersection(p1.A,p1.B,p2.A,p2.B);
      return X?[X]:[];
    }

    if (pair==='line|segment'){
      const ln=getLine((k1==='line')?ref1.id:ref2.id);
      const sg=getSegment((k1==='segment')?ref1.id:ref2.id);
      if(!ln||!sg) return [];
      const pL=getLinePtsFromLineObj(ln), pS=getLinePtsFromSegmentObj(sg);
      if(!pL||!pS) return [];
      const X=lineLineIntersection(pL.A,pL.B,pS.A,pS.B);
      if(!X) return [];
      return (distPointToSegment(X,pS.A,pS.B)<1e-7) ? [X] : [];
    }

    if (pair==='circle|line'){
      const cir=getCircle((k1==='circle')?ref1.id:ref2.id);
      const ln =getLine((k1==='line')?ref1.id:ref2.id);
      if(!cir||!ln) return [];
      const cg=getCircleGeom(cir), lp=getLinePtsFromLineObj(ln);
      if(!cg||!lp) return [];
      return circleLineIntersections(cg.C,cg.r,lp.A,lp.B);
    }

    if (pair==='circle|segment'){
      const cir=getCircle((k1==='circle')?ref1.id:ref2.id);
      const sg =getSegment((k1==='segment')?ref1.id:ref2.id);
      if(!cir||!sg) return [];
      const cg=getCircleGeom(cir), sp=getLinePtsFromSegmentObj(sg);
      if(!cg||!sp) return [];
      const pts=circleLineIntersections(cg.C,cg.r,sp.A,sp.B);
      return pts.filter(X=>distPointToSegment(X,sp.A,sp.B)<1e-7);
    }

    if (pair==='circle|circle'){
      const c1=getCircle((k1==='circle')?ref1.id:ref2.id);
      const c2=getCircle((k1==='circle')?ref2.id:ref1.id);
      if(!c1||!c2) return [];
      const g1=getCircleGeom(c1), g2=getCircleGeom(c2);
      if(!g1||!g2) return [];
      return circleCircleIntersections(g1.C,g1.r,g2.C,g2.r);
    }

    if (pair==='line|parabola'){
      const pb=getParabola((k1==='parabola')?ref1.id:ref2.id);
      const ln=getLine((k1==='line')?ref1.id:ref2.id);
      if(!pb||!ln) return [];
      const pg=getParabolaGeom(pb), lp=getLinePtsFromLineObj(ln);
      if(!pg||!lp) return [];
      const par=parabolaParams(pg.F,pg.A,pg.B);
      return parabolaLineIntersections(par, lp.A, lp.B, false);
    }

    if (pair==='parabola|segment'){
      const pb=getParabola((k1==='parabola')?ref1.id:ref2.id);
      const sg=getSegment((k1==='segment')?ref1.id:ref2.id);
      if(!pb||!sg) return [];
      const pg=getParabolaGeom(pb), sp=getLinePtsFromSegmentObj(sg);
      if(!pg||!sp) return [];
      const par=parabolaParams(pg.F,pg.A,pg.B);
      return parabolaLineIntersections(par, sp.A, sp.B, true);
    }

    if (pair==='circle|parabola'){
      const pb=getParabola((k1==='parabola')?ref1.id:ref2.id);
      const cir=getCircle((k1==='circle')?ref1.id:ref2.id);
      if(!pb||!cir) return [];
      const pg=getParabolaGeom(pb), cg=getCircleGeom(cir);
      if(!pg||!cg) return [];
      const par=parabolaParams(pg.F,pg.A,pg.B);

      const vb=viewWorldBounds();
      const corners=[v(vb.minx,vb.miny),v(vb.minx,vb.maxy),v(vb.maxx,vb.miny),v(vb.maxx,vb.maxy)];
      const us=corners.map(c=>dot(sub(c,par.A),par.d));
      const uMin=Math.min(...us)-4, uMax=Math.max(...us)+4;

      return parabolaCircleIntersections(par, cg.C, cg.r, uMin, uMax, (mode==='accurate'?'accurate':'fast'));
    }

    if (pair==='parabola|parabola'){
      const pb1=getParabola(ref1.id);
      const pb2=getParabola(ref2.id);
      if(!pb1||!pb2) return [];
      const g1=getParabolaGeom(pb1), g2=getParabolaGeom(pb2);
      if(!g1||!g2) return [];
      const par1=parabolaParams(g1.F,g1.A,g1.B);
      const par2=parabolaParams(g2.F,g2.A,g2.B);

      const vb=viewWorldBounds();
      const corners=[v(vb.minx,vb.miny),v(vb.minx,vb.maxy),v(vb.maxx,vb.miny),v(vb.maxx,vb.maxy)];
      const us1=corners.map(c=>dot(sub(c,par1.A),par1.d));
      const us2=corners.map(c=>dot(sub(c,par2.A),par2.d));
      const uMin1=Math.min(...us1)-4, uMax1=Math.max(...us1)+4;
      const uMin2=Math.min(...us2)-4, uMax2=Math.max(...us2)+4;

      return parabolaParabolaIntersections(par1,uMin1,uMax1,par2,uMin2,uMax2, (mode==='accurate'?'accurate':'fast'));
    }

    return [];
  }

  function computeAllIntersections(){
    const refs=[];
    for (const s of segments) refs.push({kind:'segment', id:s.id});
    for (const l of lines) refs.push({kind:'line', id:l.id});
    for (const c of circles) refs.push({kind:'circle', id:c.id});
    for (const p of parabolas) refs.push({kind:'parabola', id:p.id});

    const out=[];
    for (let i=0;i<refs.length;i++){
      for (let j=i+1;j<refs.length;j++){
        const a=refs[i], b=refs[j];
        const pts=intersectionsBetween(a,b,'accurate');
        for (const X of pts) out.push({x:X.x,y:X.y,a,b});
      }
    }
    return out;
  }

  function updateIntersectionPoints(){
    for (const p of points){
      if (p.kind!=='intersection') continue;
      const a=p.parents?.a, b=p.parents?.b;
      const pts=intersectionsBetween(a,b,'fast');
      if (!pts.length) continue;
      let best=pts[0], bestD=Infinity;
      for (const X of pts){
        const d=(X.x-p.x)**2 + (X.y-p.y)**2;
        if (d<bestD){ bestD=d; best=X; }
      }
      p.x=best.x; p.y=best.y;
    }
  }

  function updateConstrainedPoints(){
    for (const p of points){
      if (p.kind!=='constrained') continue;
      const c=p.constraint;
      if (!c) continue;

      if (c.kind==='segment'){
        const sg=getSegment(c.id); if (!sg) continue;
        const sp=getLinePtsFromSegmentObj(sg); if (!sp) continue;
        const t0 = c.param?.t ?? 0;
        const t1 = Math.max(0,Math.min(1,t0));
        const Q = add(sp.A, mul(sub(sp.B,sp.A), t1));
        p.x=Q.x; p.y=Q.y;
      }

      if (c.kind==='line'){
        const ln=getLine(c.id); if (!ln) continue;
        const lp=getLinePtsFromLineObj(ln); if (!lp) continue;
        const t = c.param?.t ?? 0;
        const Q = add(lp.A, mul(sub(lp.B,lp.A), t));
        p.x=Q.x; p.y=Q.y;
      }

      if (c.kind==='circle'){
        const cir=getCircle(c.id); if (!cir) continue;
        const cg=getCircleGeom(cir); if (!cg) continue;
        const ang = c.param?.ang ?? 0;
        const Q = add(cg.C, v(cg.r*Math.cos(ang), cg.r*Math.sin(ang)));
        p.x=Q.x; p.y=Q.y;
      }

      if (c.kind==='parabola'){
        const pb=getParabola(c.id); if (!pb) continue;
        const pg=getParabolaGeom(pb); if (!pg) continue;
        const par=parabolaParams(pg.F,pg.A,pg.B);
        const u = c.param?.u ?? 0;
        const vv=parabolaV(u,par);
        if (vv===null) continue;
        const Q=uvToWorld(u,vv,par);
        p.x=Q.x; p.y=Q.y;
      }
    }
  }

  function tryCreateIntersectionAtClick(sx,sy){
    const candidates=computeAllIntersections();
    let best=null, bestD2=Infinity;
    for (const it of candidates){
      const s=worldToScreen(it.x,it.y);
      const dx=s.x-sx, dy=s.y-sy;
      const d2=dx*dx+dy*dy;
      if (d2<bestD2){ bestD2=d2; best=it; }
    }
    if (best && bestD2 <= 12*12){
      addIntersectionPoint(best.x,best.y,best.a,best.b);
      showTip(t("intersection_created"), toolPointBtn, 1200);
      return true;
    }
    return false;
  }

  function bestConstraintCandidate(sx,sy){
    const P=screenToWorld(sx,sy);
    let best={kind:null, id:null, distPx:Infinity, Q:null, param:null};

    for (const sg of segments){
      const sp=getLinePtsFromSegmentObj(sg); if (!sp) continue;
      const {Q,t}=closestPointOnSegment(P, sp.A, sp.B);
      const dp = len(sub(Q,P)) * scale;
      if (dp<best.distPx){ best={kind:'segment', id:sg.id, distPx:dp, Q, param:{t}}; }
    }
    for (const ln of lines){
      const lp=getLinePtsFromLineObj(ln); if (!lp) continue;
      const {Q,t}=closestPointOnLine(P, lp.A, lp.B);
      const dp = len(sub(Q,P)) * scale;
      if (dp<best.distPx){ best={kind:'line', id:ln.id, distPx:dp, Q, param:{t}}; }
    }
    for (const cir of circles){
      const cg=getCircleGeom(cir); if (!cg) continue;
      const {Q, ang}=closestPointOnCircle(P, cg.C, cg.r);
      const dp = len(sub(Q,P)) * scale;
      if (dp<best.distPx){ best={kind:'circle', id:cir.id, distPx:dp, Q, param:{ang}}; }
    }
    const vb=viewWorldBounds();
    for (const pb of parabolas){
      const pg=getParabolaGeom(pb); if (!pg) continue;
      const par=parabolaParams(pg.F,pg.A,pg.B);
      const corners=[v(vb.minx,vb.miny),v(vb.minx,vb.maxy),v(vb.maxx,vb.miny),v(vb.maxx,vb.maxy)];
      const us=corners.map(c=>dot(sub(c,par.A),par.d));
      const uMin=Math.min(...us)-4, uMax=Math.max(...us)+4;
      const {Q,u}=closestPointOnParabola(P, par, uMin, uMax);
      const dp = len(sub(Q,P)) * scale;
      if (dp<best.distPx){ best={kind:'parabola', id:pb.id, distPx:dp, Q, param:{u}}; }
    }

    return (best.kind && best.distPx<=10) ? best : null;
  }

  function pickOrCreatePoint(sx,sy){
    const hit=hitPoint(sx,sy);
    if (hit) return hit.id;
    const w=screenToWorld(sx,sy);
    return addFreePoint(w.x,w.y);
  }

  // Draw
  function drawGrid(){
    const w=window.innerWidth,h=window.innerHeight;
    ctx.fillStyle='#0b0f14'; ctx.fillRect(0,0,w,h);
    const minor=scale, major=scale*5;

    function drawLines(step, alpha){
      ctx.strokeStyle=`rgba(230,237,243,${alpha})`;
      ctx.lineWidth=1;
      let x0=origin.x%step;
      for (let x=x0;x<=w;x+=step){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke(); }
      let y0=origin.y%step;
      for (let y=y0;y<=h;y+=step){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke(); }
    }
    drawLines(minor,0.06);
    drawLines(major,0.12);

    ctx.strokeStyle='rgba(230,237,243,0.55)'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(0,origin.y); ctx.lineTo(w,origin.y); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(origin.x,0); ctx.lineTo(origin.x,h); ctx.stroke();

    function drawArrowhead(x,y,dir){
      const size=10;
      ctx.fillStyle='rgba(230,237,243,0.75)';
      ctx.beginPath();
      if (dir==='right'){ ctx.moveTo(x,y); ctx.lineTo(x-size,y-size*0.55); ctx.lineTo(x-size,y+size*0.55); }
      if (dir==='left'){ ctx.moveTo(x,y); ctx.lineTo(x+size,y-size*0.55); ctx.lineTo(x+size,y+size*0.55); }
      if (dir==='up'){ ctx.moveTo(x,y); ctx.lineTo(x-size*0.55,y+size); ctx.lineTo(x+size*0.55,y+size); }
      if (dir==='down'){ ctx.moveTo(x,y); ctx.lineTo(x-size*0.55,y-size); ctx.lineTo(x+size*0.55,y-size); }
      ctx.closePath(); ctx.fill();
    }
    drawArrowhead(w,origin.y,'right');
    drawArrowhead(0,origin.y,'left');
    drawArrowhead(origin.x,0,'up');
    drawArrowhead(origin.x,h,'down');

    ctx.fillStyle='rgba(230,237,243,0.75)';
    ctx.font='12px system-ui';
    ctx.fillText('x', w-18, origin.y-10);
    ctx.fillText('y', origin.x+10, 16);
    ctx.fillStyle='rgba(230,237,243,0.85)';
    ctx.fillText('0', origin.x+6, origin.y+14);
  }

  function drawSegments(){
    ctx.lineWidth=3;
    ctx.strokeStyle='rgba(180,220,255,0.75)';
    for (const sg of segments){
      const a=getPoint(sg.a_id), b=getPoint(sg.b_id);
      if(!a||!b) continue;
      const A=worldToScreen(a.x,a.y), B=worldToScreen(b.x,b.y);
      ctx.beginPath(); ctx.moveTo(A.x,A.y); ctx.lineTo(B.x,B.y); ctx.stroke();
    }
  }
  function drawLines(){
    ctx.lineWidth=2;
    ctx.strokeStyle='rgba(255,255,255,0.35)';
    const w=window.innerWidth,h=window.innerHeight;

    for (const ln of lines){
      const a=getPoint(ln.a_id), b=getPoint(ln.b_id);
      if(!a||!b) continue;
      const A=worldToScreen(a.x,a.y), B=worldToScreen(b.x,b.y);
      const dx=B.x-A.x, dy=B.y-A.y;
      if (Math.hypot(dx,dy)<1e-6) continue;

      const candidates=[];
      const addIfValid=(t)=>{ const x=A.x+dx*t,y=A.y+dy*t; if(x>=-1&&x<=w+1&&y>=-1&&y<=h+1) candidates.push({x,y}); };
      if (Math.abs(dx)>1e-9){ addIfValid((0-A.x)/dx); addIfValid((w-A.x)/dx); }
      if (Math.abs(dy)>1e-9){ addIfValid((0-A.y)/dy); addIfValid((h-A.y)/dy); }
      if (candidates.length<2) continue;

      let p0=candidates[0], p1=candidates[1], best=0;
      for (let i=0;i<candidates.length;i++){
        for (let j=i+1;j<candidates.length;j++){
          const dd=(candidates[i].x-candidates[j].x)**2+(candidates[i].y-candidates[j].y)**2;
          if (dd>best){ best=dd; p0=candidates[i]; p1=candidates[j]; }
        }
      }
      ctx.beginPath(); ctx.moveTo(p0.x,p0.y); ctx.lineTo(p1.x,p1.y); ctx.stroke();
    }
  }
  function drawCircles(){
    ctx.lineWidth=2;
    ctx.strokeStyle='rgba(200,255,200,0.45)';
    for (const c of circles){
      const cg=getCircleGeom(c);
      if(!cg) continue;
      const sC=worldToScreen(cg.C.x,cg.C.y);
      ctx.beginPath(); ctx.arc(sC.x,sC.y, cg.r*scale, 0, Math.PI*2); ctx.stroke();
    }
  }
  function drawParabolas(){
    ctx.lineWidth=2.5;
    ctx.strokeStyle='rgba(255,200,120,0.65)';
    const vb=viewWorldBounds();
    for (const pb of parabolas){
      const pg=getParabolaGeom(pb); if(!pg) continue;
      const par=parabolaParams(pg.F,pg.A,pg.B);
      const corners=[v(vb.minx,vb.miny),v(vb.minx,vb.maxy),v(vb.maxx,vb.miny),v(vb.maxx,vb.maxy)];
      const us=corners.map(c=>dot(sub(c,par.A),par.d));
      let uMin=Math.min(...us)-2, uMax=Math.max(...us)+2;

      const N=180;
      let started=false;
      ctx.beginPath();
      for (let i=0;i<=N;i++){
        const u=uMin+(uMax-uMin)*i/N;
        const vv=parabolaV(u,par);
        if (vv===null) continue;
        const X=uvToWorld(u,vv,par);
        const s=worldToScreen(X.x,X.y);
        if(!started){ ctx.moveTo(s.x,s.y); started=true; }
        else ctx.lineTo(s.x,s.y);
      }
      if (started) ctx.stroke();
    }
  }

  function drawPoints(){
    for (const p of points){
      const s=worldToScreen(p.x,p.y);
      const isSel=(p.id===selectedPointId);
      const r=isSel?7:5;

      ctx.beginPath(); ctx.arc(s.x,s.y,r,0,Math.PI*2);

      if (p.kind==='intersection') ctx.fillStyle='rgba(120,255,160,0.95)';
      else if (p.kind==='constrained') ctx.fillStyle='rgba(160,190,255,0.95)';
      else ctx.fillStyle='rgba(120,200,255,0.95)';
      if (isSel) ctx.fillStyle='rgba(255,220,120,0.95)';

      ctx.fill();
      ctx.lineWidth=2;
      ctx.strokeStyle='rgba(255,255,255,0.35)';
      ctx.stroke();
    }
  }

  function drawStepPreview(){
    const P=mouseWorld;
    if (tool==='segment' && stepA){
      const a=getPoint(stepA); if(!a) return;
      const A=worldToScreen(a.x,a.y), B=worldToScreen(P.x,P.y);
      ctx.setLineDash([6,6]);
      ctx.strokeStyle='rgba(255,255,255,0.35)'; ctx.lineWidth=2;
      ctx.beginPath(); ctx.moveTo(A.x,A.y); ctx.lineTo(B.x,B.y); ctx.stroke();
      ctx.setLineDash([]);
    }
    if (tool==='line' && stepA){
      const a=getPoint(stepA); if(!a) return;
      const A=worldToScreen(a.x,a.y), B=worldToScreen(P.x,P.y);
      const dx=B.x-A.x, dy=B.y-A.y;
      if (Math.hypot(dx,dy)<1e-6) return;
      const w=window.innerWidth,h=window.innerHeight;
      const candidates=[];
      const addIfValid=(t)=>{ const x=A.x+dx*t,y=A.y+dy*t; if(x>=-1&&x<=w+1&&y>=-1&&y<=h+1) candidates.push({x,y}); };
      if (Math.abs(dx)>1e-9){ addIfValid((0-A.x)/dx); addIfValid((w-A.x)/dx); }
      if (Math.abs(dy)>1e-9){ addIfValid((0-A.y)/dy); addIfValid((h-A.y)/dy); }
      if (candidates.length<2) return;
      let p0=candidates[0], p1=candidates[1], best=0;
      for (let i=0;i<candidates.length;i++){
        for (let j=i+1;j<candidates.length;j++){
          const dd=(candidates[i].x-candidates[j].x)**2+(candidates[i].y-candidates[j].y)**2;
          if (dd>best){ best=dd; p0=candidates[i]; p1=candidates[j]; }
        }
      }
      ctx.setLineDash([6,6]);
      ctx.strokeStyle='rgba(255,255,255,0.35)'; ctx.lineWidth=2;
      ctx.beginPath(); ctx.moveTo(p0.x,p0.y); ctx.lineTo(p1.x,p1.y); ctx.stroke();
      ctx.setLineDash([]);
    }
    if (tool==='circle' && circleCenterId){
      const c=getPoint(circleCenterId); if(!c) return;
      const r=len(sub(v(P.x,P.y), v(c.x,c.y)));
      const sC=worldToScreen(c.x,c.y);
      ctx.setLineDash([6,6]);
      ctx.strokeStyle='rgba(200,255,200,0.35)'; ctx.lineWidth=2;
      ctx.beginPath(); ctx.arc(sC.x,sC.y, r*scale, 0, Math.PI*2); ctx.stroke();
      ctx.setLineDash([]);
    }
  }

  function draw(){
    updateConstrainedPoints();
    updateIntersectionPoints();
    cleanupAll();
    drawGrid();
    drawLines();
    drawSegments();
    drawCircles();
    drawParabolas();
    drawStepPreview();
    drawPoints();
  }

  // Events
  canvas.addEventListener('pointermove',(e)=>{
    const {sx,sy}=getCanvasLocalXY(e);
    const w=screenToWorld(sx,sy);
    mouseWorld=w;
    readout.textContent=`${t("mouse")}: (${w.x.toFixed(2)}, ${w.y.toFixed(2)})`;
    if ((tool==='segment'&&stepA) || (tool==='line'&&stepA) || (tool==='circle'&&circleCenterId)) draw();
  });

  canvas.addEventListener('click',(e)=>{
    const {sx,sy}=getCanvasLocalXY(e);

    if (tool==='point'){
      if (hitPoint(sx,sy)) return;

      if (tryCreateIntersectionAtClick(sx,sy)) return;

      const cand=bestConstraintCandidate(sx,sy);
      if (cand){
        addConstrainedPoint(cand.kind, cand.id, cand.param, cand.Q.x, cand.Q.y);
        showTip(t("constrained_created"), toolPointBtn, 1200);
        return;
      }

      const w=screenToWorld(sx,sy);
      addFreePoint(w.x,w.y);
      return;
    }

    if (tool==='segment'){
      const pid=pickOrCreatePoint(sx,sy);
      if (!stepA){ stepA=pid; showTip(t("seg_first"), toolSegmentBtn, 1300); draw(); return; }
      if (stepA===pid){ stepA=null; showTip(t("seg_first_cancel"), toolSegmentBtn, 1100); draw(); return; }
      addSegment(stepA,pid);
      stepA=null;
      showTip(t("seg_done"), toolSegmentBtn, 900);
      return;
    }

    if (tool==='line'){
      const pid=pickOrCreatePoint(sx,sy);
      if (!stepA){ stepA=pid; showTip(t("line_first"), toolLineBtn, 1300); draw(); return; }
      if (stepA===pid){ stepA=null; showTip(t("line_first_cancel"), toolLineBtn, 1100); draw(); return; }
      addLine(stepA,pid);
      stepA=null;
      showTip(t("line_done"), toolLineBtn, 900);
      return;
    }

    if (tool==='circle'){
      const pid=pickOrCreatePoint(sx,sy);
      if (!circleCenterId){ circleCenterId=pid; showTip(t("circle_center"), toolCircleBtn, 1300); draw(); return; }
      if (circleCenterId===pid){ circleCenterId=null; showTip(t("circle_center_cancel"), toolCircleBtn, 1100); draw(); return; }
      addCircle(circleCenterId,pid);
      circleCenterId=null;
      showTip(t("circle_done"), toolCircleBtn, 900);
      return;
    }

    if (tool==='parabola'){
      if (!parabolaFocusId){
        parabolaFocusId=pickOrCreatePoint(sx,sy);
        showTip(t("parabola_focus"), toolParabolaBtn, 1500);
        draw();
        return;
      }

      const cand=bestConstraintCandidate(sx,sy);
      if (cand && (cand.kind==='line' || cand.kind==='segment')){
        if (cand.kind==='line'){
          const ln=getLine(cand.id);
          if (ln){ addParabola(parabolaFocusId, ln.a_id, ln.b_id); parabolaFocusId=null; parabolaDirFirstId=null;
            showTip(t("parabola_done_line"), toolParabolaBtn, 1200); return; }
        }
        if (cand.kind==='segment'){
          const sg=getSegment(cand.id);
          if (sg){ addParabola(parabolaFocusId, sg.a_id, sg.b_id); parabolaFocusId=null; parabolaDirFirstId=null;
            showTip(t("parabola_done_segment"), toolParabolaBtn, 1400); return; }
        }
      }

      const pid=pickOrCreatePoint(sx,sy);
      if (!parabolaDirFirstId){
        parabolaDirFirstId=pid;
        showTip(t("parabola_dir_first"), toolParabolaBtn, 1500);
        draw();
        return;
      }
      if (parabolaDirFirstId===pid){
        parabolaDirFirstId=null;
        showTip(t("parabola_dir_first_cancel"), toolParabolaBtn, 1200);
        draw();
        return;
      }
      addParabola(parabolaFocusId, parabolaDirFirstId, pid);
      parabolaFocusId=null; parabolaDirFirstId=null;
      showTip(t("parabola_done_2pts"), toolParabolaBtn, 1400);
      return;
    }
  });

  // Select/Move
  canvas.addEventListener('pointerdown',(e)=>{
    if (tool!=='select') return;
    const {sx,sy}=getCanvasLocalXY(e);
    const hit=hitPoint(sx,sy);
    if (!hit){ selectedPointId=null; draw(); return; }
    selectedPointId=hit.id;

    if (hit.kind==='intersection'){
      showTip(t("intersection_immovable"), toolSelectBtn, 1200);
      draw();
      return;
    }

    dragging=true;
    dragPointerId=e.pointerId;

    const w=screenToWorld(sx,sy);
    dragOffset.x = w.x - hit.x;
    dragOffset.y = w.y - hit.y;

    try{ canvas.setPointerCapture(e.pointerId); }catch{}
    showTip(hit.kind==='constrained' ? t("constrained_selected") : t("free_selected"), toolSelectBtn, 1200);
    draw();
  });

  canvas.addEventListener('pointermove',(e)=>{
    if (tool!=='select') return;
    if (!dragging) return;
    if (e.pointerId!==dragPointerId) return;
    if (!selectedPointId) return;

    const p=getPoint(selectedPointId);
    if (!p) return;

    const {sx,sy}=getCanvasLocalXY(e);
    const w=screenToWorld(sx,sy);
    const target=v(w.x - dragOffset.x, w.y - dragOffset.y);

    if (p.kind==='free'){
      p.x=target.x; p.y=target.y;
      draw();
      return;
    }

    if (p.kind==='constrained'){
      const c=p.constraint;
      if (!c) return;

      if (c.kind==='segment'){
        const sg=getSegment(c.id); if(!sg) return;
        const sp=getLinePtsFromSegmentObj(sg); if(!sp) return;
        const {Q,t0}=closestPointOnSegment(target, sp.A, sp.B);
        c.param.t=t0; p.x=Q.x; p.y=Q.y; draw(); return;
      }
      if (c.kind==='line'){
        const ln=getLine(c.id); if(!ln) return;
        const lp=getLinePtsFromLineObj(ln); if(!lp) return;
        const {Q,t0}=closestPointOnLine(target, lp.A, lp.B);
        c.param.t=t0; p.x=Q.x; p.y=Q.y; draw(); return;
      }
      if (c.kind==='circle'){
        const cir=getCircle(c.id); if(!cir) return;
        const cg=getCircleGeom(cir); if(!cg) return;
        const {Q,ang}=closestPointOnCircle(target, cg.C, cg.r);
        c.param.ang=ang; p.x=Q.x; p.y=Q.y; draw(); return;
      }
      if (c.kind==='parabola'){
        const pb=getParabola(c.id); if(!pb) return;
        const pg=getParabolaGeom(pb); if(!pg) return;
        const par=parabolaParams(pg.F,pg.A,pg.B);
        const vb=viewWorldBounds();
        const corners=[v(vb.minx,vb.miny),v(vb.minx,vb.maxy),v(vb.maxx,vb.miny),v(vb.maxx,vb.maxy)];
        const us=corners.map(cc=>dot(sub(cc,par.A),par.d));
        const uMin=Math.min(...us)-4, uMax=Math.max(...us)+4;
        const {Q,u}=closestPointOnParabola(target, par, uMin, uMax);
        c.param.u=u; p.x=Q.x; p.y=Q.y; draw(); return;
      }
    }
  });

  function endDrag(e){
    if (tool!=='select') return;
    if (!dragging) return;
    if (e.pointerId!==dragPointerId) return;
    dragging=false;
    try{ canvas.releasePointerCapture(e.pointerId); }catch{}
    dragPointerId=null;
    saveState();
    showTip(t("moved_saved"), toolSelectBtn, 900);
  }
  canvas.addEventListener('pointerup', endDrag);
  canvas.addEventListener('pointercancel', endDrag);

  // Undo/Clear
  function undoPoint(){ if(!points.length){ showTip(t("nothing_undo_point"), btnUndoPoint, 900); return; } points.pop(); cleanupAll(); saveState(); draw(); showTip(t("undo_point_done"), btnUndoPoint, 900); }
  function undoSeg(){ if(!segments.length){ showTip(t("nothing_undo_seg"), btnUndoSeg, 900); return; } segments.pop(); cleanupAll(); saveState(); draw(); showTip(t("undo_seg_done"), btnUndoSeg, 900); }
  function undoLine(){ if(!lines.length){ showTip(t("nothing_undo_line"), btnUndoLine, 900); return; } lines.pop(); cleanupAll(); saveState(); draw(); showTip(t("undo_line_done"), btnUndoLine, 900); }
  function undoCircle(){ if(!circles.length){ showTip(t("nothing_undo_circle"), btnUndoCircle, 900); return; } circles.pop(); cleanupAll(); saveState(); draw(); showTip(t("undo_circle_done"), btnUndoCircle, 900); }
  function undoParabola(){ if(!parabolas.length){ showTip(t("nothing_undo_parabola"), btnUndoParabola, 900); return; } parabolas.pop(); cleanupAll(); saveState(); draw(); showTip(t("undo_parabola_done"), btnUndoParabola, 900); }
  function clearAll(){
    points=[]; segments=[]; lines=[]; circles=[]; parabolas=[];
    selectedPointId=null; cancelStep(false);
    saveState(); draw(); showTip(t("cleared"), btnClearAll, 900);
  }

  // Buttons
  toolPointBtn.addEventListener('click',()=>setTool('point', toolPointBtn));
  toolSegmentBtn.addEventListener('click',()=>setTool('segment', toolSegmentBtn));
  toolLineBtn.addEventListener('click',()=>setTool('line', toolLineBtn));
  toolCircleBtn.addEventListener('click',()=>setTool('circle', toolCircleBtn));
  toolParabolaBtn.addEventListener('click',()=>setTool('parabola', toolParabolaBtn));
  toolSelectBtn.addEventListener('click',()=>setTool('select', toolSelectBtn));

  langKoBtn.addEventListener('click', ()=> setLang("ko", langKoBtn));
  langEnBtn.addEventListener('click', ()=> setLang("en", langEnBtn));

  btnUndoPoint.addEventListener('click', undoPoint);
  btnUndoSeg.addEventListener('click', undoSeg);
  btnUndoLine.addEventListener('click', undoLine);
  btnUndoCircle.addEventListener('click', undoCircle);
  btnUndoParabola.addEventListener('click', undoParabola);
  btnClearAll.addEventListener('click', clearAll);
  btnCancelStep.addEventListener('click', ()=>cancelStep(true));

  // Shortcuts
  window.addEventListener('keydown',(e)=>{
    const k=e.key.toLowerCase();
    if (k==='p') setTool('point', null);
    if (k==='g') setTool('segment', null);
    if (k==='l') setTool('line', null);
    if (k==='c') setTool('circle', null);
    if (k==='a') setTool('parabola', null);
    if (k==='v') setTool('select', null);
    if (k==='escape') cancelStep(true);
  });

  // init
  applyLanguageToUI();
  cleanupAll();
  saveState();
  window.addEventListener('resize', resize);
  resize();
  draw();

  if (didPurge) showTip(t("init_purged"), null, 1900);
  else showTip(t("init_ok"), null, 1900);
})();
</script>
</body>
</html>
