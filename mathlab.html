<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Math Tool (Dynamic Intersections + Circle)</title>
  <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate, max-age=0" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <style>
    html, body { height: 100%; margin: 0; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background: #0b0f14; color: #e6edf3; }

    .topbar {
      position: fixed; top: 12px; left: 12px; right: 12px;
      display: flex; gap: 8px; align-items: center; z-index: 10;
      flex-wrap: wrap;
    }
    .panel {
      background: rgba(20, 26, 34, 0.85);
      border: 1px solid rgba(255,255,255,0.08);
      backdrop-filter: blur(8px);
      border-radius: 12px;
      padding: 10px 12px;
      display: flex; gap: 10px; align-items: center;
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
    }
    button {
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.12);
      color: #e6edf3;
      padding: 8px 10px;
      border-radius: 10px;
      cursor: pointer;
      user-select: none;
      white-space: nowrap;
    }
    button:hover { background: rgba(255,255,255,0.12); }
    button.active {
      background: rgba(120, 200, 255, 0.22);
      border-color: rgba(120, 200, 255, 0.35);
    }
    .readout { opacity: 0.9; font-size: 13px; }
    canvas { display: block; width: 100%; height: 100%; touch-action: none; }

    .footer {
      position: fixed; bottom: 12px; left: 12px;
      background: rgba(20, 26, 34, 0.75);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 12px;
      padding: 10px 12px;
      font-size: 12px;
      opacity: 0.85;
      line-height: 1.35;
      z-index: 10;
      max-width: min(1200px, calc(100vw - 24px));
    }
    code { background: rgba(255,255,255,0.08); padding: 2px 6px; border-radius: 8px; }

    .tip {
      position: fixed;
      z-index: 9999;
      display: none;
      background: rgba(20, 26, 34, 0.94);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 12px;
      padding: 10px 12px;
      box-shadow: 0 18px 44px rgba(0,0,0,0.45);
      backdrop-filter: blur(10px);
      max-width: min(520px, calc(100vw - 24px));
      font-size: 13px;
      line-height: 1.35;
      opacity: 0;
      pointer-events: none;
      transform: translateY(-4px);
      transition: opacity 160ms ease, transform 160ms ease;
    }
    .tip.show { display: block; opacity: 1; transform: translateY(0); }
    .tip.hide { opacity: 0; transform: translateY(-6px); }
    .tip b { color: rgba(255, 230, 160, 0.95); }
  </style>
</head>
<body>
  <div class="topbar">
    <div class="panel">
      <button id="toolPoint" class="active" type="button">점 도구</button>
      <button id="toolSegment" type="button">선분 도구</button>
      <button id="toolLine" type="button">직선 도구</button>
      <button id="toolCircle" type="button">원 도구</button>
      <button id="toolSelect" type="button">선택/이동 도구</button>
      <span class="readout" id="readout"></span>
    </div>

    <div class="panel">
      <button id="btnUndoPoint" type="button">점 되돌리기</button>
      <button id="btnUndoSeg" type="button">선분 되돌리기</button>
      <button id="btnUndoLine" type="button">직선 되돌리기</button>
      <button id="btnUndoCircle" type="button">원 되돌리기</button>
      <button id="btnClearAll" type="button">전체 삭제</button>
      <button id="btnCancelFirst" type="button">2단계 1단계 취소</button>
    </div>
  </div>

  <canvas id="c"></canvas>

  <div class="footer">
    ✅ 데이터는 브라우저(localStorage)에만 저장(서버 저장 0)<br/>
    선분/직선: (1-2), (3-4), (5-6)… <b>2점씩 짝지어</b> 생성<br/>
    ⭐ 점 도구(P): 교점 근처 클릭 → <b>동적 교점(종속점)</b> 생성 (직선/선분/원 포함)<br/>
    ⭐ 원 도구(C): ① 중심점 선택/생성 → ② 점 선택/생성(반지름) 또는 선분 선택(선분 길이 반지름)<br/>
    ⛔ 종속점(교점)은 직접 드래그 이동 불가(부모가 움직이면 같이 이동)<br/>
    단축키: <code>P</code>=점, <code>S</code>=선분, <code>L</code>=직선, <code>C</code>=원, <code>V</code>=선택, <code>ESC</code>=1단계 취소
  </div>

  <div id="tip" class="tip" aria-live="polite"></div>

<script>
(() => {
  // =========================
  // 0) 자동 찌꺼기 삭제 정책
  // =========================
  const BUILD_ID = "2026-01-06-build-06-circle-intersections";
  const BUILD_KEY = "mathlab_build_id";

  function purgeOldLocalStorageIfNeeded() {
    try {
      const prev = localStorage.getItem(BUILD_KEY);
      if (prev === BUILD_ID) return false;

      const keysToDelete = [];
      for (let i = 0; i < localStorage.length; i++) {
        const k = localStorage.key(i);
        if (!k) continue;
        if (k.startsWith("mathlab_state_") || k.startsWith("mathlab_")) keysToDelete.push(k);
      }
      for (const k of keysToDelete) localStorage.removeItem(k);

      localStorage.setItem(BUILD_KEY, BUILD_ID);
      return true;
    } catch { return false; }
  }
  const didPurge = purgeOldLocalStorageIfNeeded();

  // -------------------------
  // Element refs (방어)
  // -------------------------
  const canvas = document.getElementById('c');
  const ctx = canvas?.getContext?.('2d');
  const readout = document.getElementById('readout');
  const tipEl = document.getElementById('tip');

  const toolPointBtn = document.getElementById('toolPoint');
  const toolSegmentBtn = document.getElementById('toolSegment');
  const toolLineBtn = document.getElementById('toolLine');
  const toolCircleBtn = document.getElementById('toolCircle');
  const toolSelectBtn = document.getElementById('toolSelect');

  const btnUndoPoint = document.getElementById('btnUndoPoint');
  const btnUndoSeg   = document.getElementById('btnUndoSeg');
  const btnUndoLine  = document.getElementById('btnUndoLine');
  const btnUndoCircle = document.getElementById('btnUndoCircle');
  const btnClearAll  = document.getElementById('btnClearAll');
  const btnCancelFirst = document.getElementById('btnCancelFirst');

  if (!canvas || !ctx || !readout || !tipEl ||
      !toolPointBtn || !toolSegmentBtn || !toolLineBtn || !toolCircleBtn || !toolSelectBtn ||
      !btnUndoPoint || !btnUndoSeg || !btnUndoLine || !btnUndoCircle || !btnClearAll || !btnCancelFirst) {
    alert('UI 요소 로딩에 실패했습니다. HTML이 손상되었는지 확인해 주세요.');
    return;
  }

  // -------------------------
  // Tooltip
  // -------------------------
  let tipTimer = null;
  let tipHideTimer = null;

  function hideTip() {
    tipEl.classList.remove('show');
    tipEl.classList.add('hide');
    if (tipHideTimer) clearTimeout(tipHideTimer);
    tipHideTimer = setTimeout(() => {
      if (tipEl.classList.contains('hide')) tipEl.style.display = 'none';
    }, 200);
  }
  function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }
  function positionTip(anchorEl) {
    const padding = 10, gap = 10;
    const tw = Math.max(1, tipEl.offsetWidth);
    const th = Math.max(1, tipEl.offsetHeight);

    if (!anchorEl || !anchorEl.getBoundingClientRect) {
      const left = Math.round((window.innerWidth - tw) / 2);
      const top = 72;
      tipEl.style.left = `${clamp(left, padding, window.innerWidth - padding - tw)}px`;
      tipEl.style.top  = `${clamp(top,  padding, window.innerHeight - padding - th)}px`;
      return;
    }

    const r = anchorEl.getBoundingClientRect();
    let left = r.right + gap;
    let top  = r.top + (r.height - th) / 2;

    if (left + tw > window.innerWidth - padding) left = r.left - gap - tw;
    left = clamp(left, padding, window.innerWidth - padding - tw);
    top  = clamp(top,  padding, window.innerHeight - padding - th);

    tipEl.style.left = `${Math.round(left)}px`;
    tipEl.style.top  = `${Math.round(top)}px`;
  }
  function showTip(html, anchorEl=null, ms=1600) {
    if (tipTimer) clearTimeout(tipTimer);
    tipEl.innerHTML = html;
    tipEl.style.display = 'block';
    tipEl.classList.remove('hide');
    tipEl.classList.add('show');
    requestAnimationFrame(() => positionTip(anchorEl));
    tipTimer = setTimeout(hideTip, ms);
  }
  window.addEventListener('resize', hideTip);
  window.addEventListener('scroll', hideTip, true);

  // =========================
  // State
  // =========================
  const STORAGE_KEY = 'mathlab_state_safe_v7_circle_intersections';

  function sanitizeNumber(x, fallback=0) {
    const n = Number(x);
    return Number.isFinite(n) ? n : fallback;
  }

  function kindRank(k) {
    if (k === 'line') return 1;
    if (k === 'segment') return 2;
    if (k === 'circle') return 3;
    return 99;
  }

  function sanitizeState(obj) {
    const safe = { points: [], segments: [], lines: [], circles: [] };
    if (!obj || typeof obj !== 'object') return safe;

    const pts = Array.isArray(obj.points) ? obj.points : [];
    const segs = Array.isArray(obj.segments) ? obj.segments : [];
    const lns = Array.isArray(obj.lines) ? obj.lines : [];
    const cirs = Array.isArray(obj.circles) ? obj.circles : [];

    // points
    for (const p of pts) {
      if (!p || typeof p !== 'object') continue;
      if (typeof p.id !== 'string' || !p.id) continue;

      const kind = (typeof p.kind === 'string' ? p.kind : 'free');

      if (kind === 'free') {
        safe.points.push({ id: p.id, kind: 'free', x: sanitizeNumber(p.x, 0), y: sanitizeNumber(p.y, 0) });
      } else if (kind === 'intersection') {
        const ak = p.a_kind, bk = p.b_kind;
        const okKind = (k) => (k === 'line' || k === 'segment' || k === 'circle');
        if (!okKind(ak) || !okKind(bk)) continue;
        if (typeof p.a_id !== 'string' || typeof p.b_id !== 'string') continue;

        const br = Number.isFinite(Number(p.branch)) ? Number(p.branch) : 0;
        const branch = (br === 1 ? 1 : 0);

        safe.points.push({
          id: p.id,
          kind: 'intersection',
          a_kind: ak, a_id: p.a_id,
          b_kind: bk, b_id: p.b_id,
          branch
        });
      }
    }

    const pointIds = new Set(safe.points.map(p => p.id));

    // segments
    for (const s of segs) {
      if (!s || typeof s !== 'object') continue;
      if (typeof s.id !== 'string' || !s.id) continue;
      if (typeof s.a_id !== 'string' || typeof s.b_id !== 'string') continue;
      if (!pointIds.has(s.a_id) || !pointIds.has(s.b_id) || s.a_id === s.b_id) continue;
      safe.segments.push({ id: s.id, a_id: s.a_id, b_id: s.b_id });
    }

    // lines
    for (const l of lns) {
      if (!l || typeof l !== 'object') continue;
      if (typeof l.id !== 'string' || !l.id) continue;
      if (typeof l.a_id !== 'string' || typeof l.b_id !== 'string') continue;
      if (!pointIds.has(l.a_id) || !pointIds.has(l.b_id) || l.a_id === l.b_id) continue;
      safe.lines.push({ id: l.id, a_id: l.a_id, b_id: l.b_id });
    }

    const segIds = new Set(safe.segments.map(s => s.id));

    // circles
    for (const c of cirs) {
      if (!c || typeof c !== 'object') continue;
      if (typeof c.id !== 'string' || !c.id) continue;
      if (typeof c.center_id !== 'string' || !pointIds.has(c.center_id)) continue;

      const rk = c.r_kind;
      const rid = c.r_id;

      if (rk === 'point') {
        if (typeof rid !== 'string' || !pointIds.has(rid)) continue;
        safe.circles.push({ id: c.id, center_id: c.center_id, r_kind: 'point', r_id: rid });
      } else if (rk === 'segment') {
        if (typeof rid !== 'string' || !segIds.has(rid)) continue;
        safe.circles.push({ id: c.id, center_id: c.center_id, r_kind: 'segment', r_id: rid });
      }
    }

    return safe;
  }

  function loadState() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return { points: [], segments: [], lines: [], circles: [] };
      return sanitizeState(JSON.parse(raw));
    } catch {
      return { points: [], segments: [], lines: [], circles: [] };
    }
  }

  function saveState() {
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify({ points, segments, lines, circles }));
    } catch {
      showTip('저장에 실패했습니다(브라우저 설정/용량). 그래도 작업은 계속됩니다.', null, 1600);
    }
  }

  // View
  let scale = 40;
  let origin = { x: 0, y: 0 };

  let { points, segments, lines, circles } = loadState();

  let tool = 'point';
  let selectedId = null;

  // 2단계 도구(선분/직선/원) 공용: 1단계에서 잡아둔 id
  let firstId = null;
  let mouseWorld = { x: 0, y: 0 };

  // Drag
  let dragging = false;
  let dragPointerId = null;
  let dragOffset = { x: 0, y: 0 };

  const HIT_RADIUS_PX = 10;
  const INTERSECTION_HIT_PX = 12;
  const SEG_HIT_PX = 10;

  // =========================
  // Geometry core
  // =========================
  const EPS = 1e-12;

  function cross(ax, ay, bx, by) { return ax * by - ay * bx; }
  function dot(ax, ay, bx, by) { return ax * bx + ay * by; }
  function dist(ax, ay, bx, by) { const dx = ax - bx, dy = ay - by; return Math.hypot(dx, dy); }

  function uid(prefix='') {
    return prefix + Date.now().toString(36) + '-' + Math.random().toString(36).slice(2, 8);
  }

  function findPointObj(pid) { return points.find(p => p.id === pid) || null; }
  function findSegObj(sid) { return segments.find(s => s.id === sid) || null; }
  function findLineObj(lid) { return lines.find(l => l.id === lid) || null; }
  function findCircleObj(cid) { return circles.find(c => c.id === cid) || null; }

  function worldToScreen(wx, wy) { return { x: origin.x + wx * scale, y: origin.y - wy * scale }; }
  function screenToWorld(sx, sy) { return { x: (sx - origin.x) / scale, y: (origin.y - sy) / scale }; }

  function getCanvasLocalXY(e) {
    const rect = canvas.getBoundingClientRect();
    return { sx: e.clientX - rect.left, sy: e.clientY - rect.top };
  }

  // p + t r, q + u s
  function intersectParams(px, py, rx, ry, qx, qy, sx, sy) {
    const denom = cross(rx, ry, sx, sy);
    if (Math.abs(denom) < EPS) return null;
    const qmpx = qx - px, qmpy = qy - py;
    const t = cross(qmpx, qmpy, sx, sy) / denom;
    const u = cross(qmpx, qmpy, rx, ry) / denom;
    return { t, u, x: px + t * rx, y: py + t * ry };
  }

  function canonicalizePair(a_kind, a_id, b_kind, b_id) {
    const ra = kindRank(a_kind), rb = kindRank(b_kind);
    if (ra < rb) return { a_kind, a_id, b_kind, b_id, swapped: false };
    if (ra > rb) return { a_kind: b_kind, a_id: b_id, b_kind: a_kind, b_id: a_id, swapped: true };
    // same kind → id sort
    if (String(a_id) <= String(b_id)) return { a_kind, a_id, b_kind, b_id, swapped: false };
    return { a_kind: b_kind, a_id: b_id, b_kind: a_kind, b_id: a_id, swapped: true };
  }

  function intersectionKey(a_kind, a_id, b_kind, b_id, branch) {
    const c = canonicalizePair(a_kind, a_id, b_kind, b_id);
    const br = (branch === 1 ? 1 : 0);
    return `${c.a_kind}:${c.a_id}|${c.b_kind}:${c.b_id}|${br}`;
  }

  // ---- evaluation (dynamic) ----
  function evalPoint(pid, cache, stack) {
    if (cache.has(pid)) return cache.get(pid);
    if (stack.has(pid)) { cache.set(pid, null); return null; }
    stack.add(pid);

    const p = findPointObj(pid);
    if (!p) { cache.set(pid, null); stack.delete(pid); return null; }

    let res = null;

    if (!p.kind || p.kind === 'free') {
      res = { x: p.x, y: p.y };
    } else if (p.kind === 'intersection') {
      const br = (p.branch === 1 ? 1 : 0);
      const c = canonicalizePair(p.a_kind, p.a_id, p.b_kind, p.b_id);
      // (구버전 데이터 대비) swapped가 나올 수는 있지만, 원 포함에서는 branch가 뒤집힐 수 있음.
      // 여기서는 "교점 집합" 자체는 동일하므로, swapped면 branch만 1-branch로 보정.
      const branchAdj = c.swapped ? (1 - br) : br;

      const sol = computeIntersectionsCanonical(c.a_kind, c.a_id, c.b_kind, c.b_id, cache, stack);
      if (sol && sol.length) {
        const pick = sol.find(s => s.branch === branchAdj) || null;
        res = pick ? { x: pick.x, y: pick.y } : null;
      }
    }

    cache.set(pid, res);
    stack.delete(pid);
    return res;
  }

  function evalPrimitiveEndpoints(kind, id, cache, stack) {
    const obj = (kind === 'line') ? findLineObj(id) : findSegObj(id);
    if (!obj) return null;
    const a = evalPoint(obj.a_id, cache, stack);
    const b = evalPoint(obj.b_id, cache, stack);
    if (!a || !b) return null;
    if (Math.abs(a.x - b.x) < EPS && Math.abs(a.y - b.y) < EPS) return null;
    return { ax: a.x, ay: a.y, bx: b.x, by: b.y };
  }

  function evalCircleParams(cid, cache, stack) {
    const c = findCircleObj(cid);
    if (!c) return null;
    const center = evalPoint(c.center_id, cache, stack);
    if (!center) return null;

    let r = null;
    if (c.r_kind === 'point') {
      const rp = evalPoint(c.r_id, cache, stack);
      if (!rp) return null;
      r = dist(center.x, center.y, rp.x, rp.y);
    } else if (c.r_kind === 'segment') {
      const seg = evalPrimitiveEndpoints('segment', c.r_id, cache, stack);
      if (!seg) return null;
      r = dist(seg.ax, seg.ay, seg.bx, seg.by);
    }
    if (!r || r < 1e-12) return null;
    return { cx: center.x, cy: center.y, r };
  }

  // ---- intersection solver (canonical order: line < segment < circle) ----
  function computeIntersectionsCanonical(a_kind, a_id, b_kind, b_id, cache, stack) {
    const tol = 1e-9;

    // line-line
    if (a_kind === 'line' && b_kind === 'line') {
      const A = evalPrimitiveEndpoints('line', a_id, cache, stack);
      const B = evalPrimitiveEndpoints('line', b_id, cache, stack);
      if (!A || !B) return [];
      const rx = A.bx - A.ax, ry = A.by - A.ay;
      const sx = B.bx - B.ax, sy = B.by - B.ay;
      const ip = intersectParams(A.ax, A.ay, rx, ry, B.ax, B.ay, sx, sy);
      if (!ip) return [];
      return [{ x: ip.x, y: ip.y, branch: 0 }];
    }

    // segment-segment
    if (a_kind === 'segment' && b_kind === 'segment') {
      const A = evalPrimitiveEndpoints('segment', a_id, cache, stack);
      const B = evalPrimitiveEndpoints('segment', b_id, cache, stack);
      if (!A || !B) return [];
      const rx = A.bx - A.ax, ry = A.by - A.ay;
      const sx = B.bx - B.ax, sy = B.by - B.ay;
      const ip = intersectParams(A.ax, A.ay, rx, ry, B.ax, B.ay, sx, sy);
      if (!ip) return [];
      if (ip.t < -tol || ip.t > 1 + tol) return [];
      if (ip.u < -tol || ip.u > 1 + tol) return [];
      return [{ x: ip.x, y: ip.y, branch: 0 }];
    }

    // line-segment (canonical: line first)
    if (a_kind === 'line' && b_kind === 'segment') {
      const A = evalPrimitiveEndpoints('line', a_id, cache, stack);
      const B = evalPrimitiveEndpoints('segment', b_id, cache, stack);
      if (!A || !B) return [];
      const rx = A.bx - A.ax, ry = A.by - A.ay;
      const sx = B.bx - B.ax, sy = B.by - B.ay;
      const ip = intersectParams(A.ax, A.ay, rx, ry, B.ax, B.ay, sx, sy);
      if (!ip) return [];
      if (ip.u < -tol || ip.u > 1 + tol) return [];
      return [{ x: ip.x, y: ip.y, branch: 0 }];
    }

    // line-circle (canonical: line first)
    if (a_kind === 'line' && b_kind === 'circle') {
      const L = evalPrimitiveEndpoints('line', a_id, cache, stack);
      const C = evalCircleParams(b_id, cache, stack);
      if (!L || !C) return [];
      const ax = L.ax, ay = L.ay;
      const dx = L.bx - L.ax, dy = L.by - L.ay; // direction
      const fx = ax - C.cx, fy = ay - C.cy;

      const A = dot(dx, dy, dx, dy);
      const B = 2 * dot(dx, dy, fx, fy);
      const CC = dot(fx, fy, fx, fy) - C.r * C.r;

      const disc = B*B - 4*A*CC;
      if (disc < -1e-12) return [];
      if (Math.abs(disc) <= 1e-12) {
        const t = (-B) / (2*A);
        return [{ x: ax + t*dx, y: ay + t*dy, branch: 0 }];
      }
      const s = Math.sqrt(Math.max(0, disc));
      const t0 = (-B - s) / (2*A);
      const t1 = (-B + s) / (2*A);
      const p0 = { x: ax + t0*dx, y: ay + t0*dy, branch: 0 };
      const p1 = { x: ax + t1*dx, y: ay + t1*dy, branch: 1 };
      return (t0 <= t1) ? [p0, p1] : [p1, p0]; // 매우 드물지만 안전
    }

    // segment-circle (canonical: segment first)
    if (a_kind === 'segment' && b_kind === 'circle') {
      const S = evalPrimitiveEndpoints('segment', a_id, cache, stack);
      const C = evalCircleParams(b_id, cache, stack);
      if (!S || !C) return [];
      const ax = S.ax, ay = S.ay;
      const dx = S.bx - S.ax, dy = S.by - S.ay;
      const fx = ax - C.cx, fy = ay - C.cy;

      const A = dot(dx, dy, dx, dy);
      const B = 2 * dot(dx, dy, fx, fy);
      const CC = dot(fx, fy, fx, fy) - C.r * C.r;

      const disc = B*B - 4*A*CC;
      if (disc < -1e-12) return [];
      if (Math.abs(disc) <= 1e-12) {
        const t = (-B) / (2*A);
        if (t < -tol || t > 1 + tol) return [];
        return [{ x: ax + t*dx, y: ay + t*dy, branch: 0 }];
      }
      const s = Math.sqrt(Math.max(0, disc));
      const t0 = (-B - s) / (2*A);
      const t1 = (-B + s) / (2*A);

      const out = [];
      if (t0 >= -tol && t0 <= 1 + tol) out.push({ x: ax + t0*dx, y: ay + t0*dy, branch: 0 });
      if (t1 >= -tol && t1 <= 1 + tol) out.push({ x: ax + t1*dx, y: ay + t1*dy, branch: 1 });

      // 클릭 후보 생성은 "실제로 선분 위에 있는 교점"만
      return out;
    }

    // circle-circle (canonical: circle first, id sort)
    if (a_kind === 'circle' && b_kind === 'circle') {
      const C0 = evalCircleParams(a_id, cache, stack);
      const C1 = evalCircleParams(b_id, cache, stack);
      if (!C0 || !C1) return [];

      const x0 = C0.cx, y0 = C0.cy, r0 = C0.r;
      const x1 = C1.cx, y1 = C1.cy, r1 = C1.r;

      const dx = x1 - x0, dy = y1 - y0;
      const d = Math.hypot(dx, dy);
      if (d < 1e-12) return []; // 동심(무한/0교점) → 여기서는 생성 안 함

      if (d > r0 + r1 + 1e-12) return [];
      if (d < Math.abs(r0 - r1) - 1e-12) return [];

      const a = (r0*r0 - r1*r1 + d*d) / (2*d);
      const h2 = r0*r0 - a*a;
      if (h2 < -1e-12) return [];
      const xm = x0 + a * dx / d;
      const ym = y0 + a * dy / d;

      if (Math.abs(h2) <= 1e-12) {
        return [{ x: xm, y: ym, branch: 0 }]; // 접점
      }

      const h = Math.sqrt(Math.max(0, h2));
      const rx = -dy / d;
      const ry =  dx / d;

      const p0 = { x: xm + h*rx, y: ym + h*ry, branch: 0 };
      const p1 = { x: xm - h*rx, y: ym - h*ry, branch: 1 };
      return [p0, p1];
    }

    return [];
  }

  // -------------------------
  // Cleanup references
  // -------------------------
  function cleanupReferences() {
    const pointIds = new Set(points.map(p => p.id));

    segments = segments.filter(s => pointIds.has(s.a_id) && pointIds.has(s.b_id) && s.a_id !== s.b_id);
    lines = lines.filter(l => pointIds.has(l.a_id) && pointIds.has(l.b_id) && l.a_id !== l.b_id);

    const segIds = new Set(segments.map(s => s.id));
    const lineIds = new Set(lines.map(l => l.id));
    const circleIds = new Set(circles.map(c => c.id));

    // 교점 종속점: 부모 primitive가 없어지면 제거
    points = points.filter(p => {
      if (!p.kind || p.kind === 'free') return true;
      if (p.kind === 'intersection') {
        const ok = (k, id) => {
          if (k === 'segment') return segIds.has(id);
          if (k === 'line') return lineIds.has(id);
          if (k === 'circle') return circleIds.has(id);
          return false;
        };
        return ok(p.a_kind, p.a_id) && ok(p.b_kind, p.b_id);
      }
      return true;
    });

    // 원: center/radius 참조가 없어지면 제거
    const pointIds2 = new Set(points.map(p => p.id));
    const segIds2 = new Set(segments.map(s => s.id));

    circles = circles.filter(c => {
      if (!pointIds2.has(c.center_id)) return false;
      if (c.r_kind === 'point') return pointIds2.has(c.r_id);
      if (c.r_kind === 'segment') return segIds2.has(c.r_id);
      return false;
    });
  }

  // =========================
  // Intersection candidates (점도구 교점 생성)
  // =========================
  function buildIntersectionCandidates(cache, stack) {
    const cands = [];

    // 1) line-line
    for (let i = 0; i < lines.length; i++) {
      for (let j = i + 1; j < lines.length; j++) {
        const c = canonicalizePair('line', lines[i].id, 'line', lines[j].id);
        const sols = computeIntersectionsCanonical(c.a_kind, c.a_id, c.b_kind, c.b_id, cache, stack);
        for (const s of sols) cands.push({ ...s, a_kind: c.a_kind, a_id: c.a_id, b_kind: c.b_kind, b_id: c.b_id });
      }
    }

    // 2) seg-seg
    for (let i = 0; i < segments.length; i++) {
      for (let j = i + 1; j < segments.length; j++) {
        const c = canonicalizePair('segment', segments[i].id, 'segment', segments[j].id);
        const sols = computeIntersectionsCanonical(c.a_kind, c.a_id, c.b_kind, c.b_id, cache, stack);
        for (const s of sols) cands.push({ ...s, a_kind: c.a_kind, a_id: c.a_id, b_kind: c.b_kind, b_id: c.b_id });
      }
    }

    // 3) line-seg
    for (let i = 0; i < lines.length; i++) {
      for (let j = 0; j < segments.length; j++) {
        const c = canonicalizePair('line', lines[i].id, 'segment', segments[j].id); // line first by rank
        const sols = computeIntersectionsCanonical(c.a_kind, c.a_id, c.b_kind, c.b_id, cache, stack);
        for (const s of sols) cands.push({ ...s, a_kind: c.a_kind, a_id: c.a_id, b_kind: c.b_kind, b_id: c.b_id });
      }
    }

    // 4) line-circle
    for (let i = 0; i < lines.length; i++) {
      for (let j = 0; j < circles.length; j++) {
        const c = canonicalizePair('line', lines[i].id, 'circle', circles[j].id); // line first by rank
        const sols = computeIntersectionsCanonical(c.a_kind, c.a_id, c.b_kind, c.b_id, cache, stack);
        for (const s of sols) cands.push({ ...s, a_kind: c.a_kind, a_id: c.a_id, b_kind: c.b_kind, b_id: c.b_id });
      }
    }

    // 5) seg-circle
    for (let i = 0; i < segments.length; i++) {
      for (let j = 0; j < circles.length; j++) {
        const c = canonicalizePair('segment', segments[i].id, 'circle', circles[j].id); // segment first by rank
        const sols = computeIntersectionsCanonical(c.a_kind, c.a_id, c.b_kind, c.b_id, cache, stack);
        for (const s of sols) cands.push({ ...s, a_kind: c.a_kind, a_id: c.a_id, b_kind: c.b_kind, b_id: c.b_id });
      }
    }

    // 6) circle-circle
    for (let i = 0; i < circles.length; i++) {
      for (let j = i + 1; j < circles.length; j++) {
        const c = canonicalizePair('circle', circles[i].id, 'circle', circles[j].id);
        const sols = computeIntersectionsCanonical(c.a_kind, c.a_id, c.b_kind, c.b_id, cache, stack);
        for (const s of sols) cands.push({ ...s, a_kind: c.a_kind, a_id: c.a_id, b_kind: c.b_kind, b_id: c.b_id });
      }
    }

    // 너무 가까운 후보 중복 제거
    const out = [];
    const eps2 = 1e-10;
    for (const p of cands) {
      let ok = true;
      for (const q of out) {
        const dx = p.x - q.x, dy = p.y - q.y;
        if (dx*dx + dy*dy < eps2) { ok = false; break; }
      }
      if (ok) out.push(p);
    }
    return out;
  }

  function hasIntersectionPoint(a_kind, a_id, b_kind, b_id, branch) {
    const key = intersectionKey(a_kind, a_id, b_kind, b_id, branch);
    return points.some(p => p.kind === 'intersection' &&
      intersectionKey(p.a_kind, p.a_id, p.b_kind, p.b_id, p.branch) === key
    );
  }

  function findNearestIntersectionToScreen(sx, sy) {
    const cache = new Map();
    const stack = new Set();
    const cands = buildIntersectionCandidates(cache, stack);

    let best = null;
    let bestD2 = Infinity;

    for (const c of cands) {
      const sc = worldToScreen(c.x, c.y);
      const dx = sc.x - sx, dy = sc.y - sy;
      const d2 = dx*dx + dy*dy;
      if (d2 < bestD2) { bestD2 = d2; best = c; }
    }
    if (!best) return null;
    return { ...best, d2px: bestD2 };
  }

  // =========================
  // Hit tests
  // =========================
  function hitTestPoint(sx, sy) {
    const cache = new Map();
    const stack = new Set();

    let best = null;
    let bestDist2 = Infinity;

    for (const p of points) {
      const w = evalPoint(p.id, cache, stack);
      if (!w) continue;
      const s = worldToScreen(w.x, w.y);
      const dx = s.x - sx, dy = s.y - sy;
      const d2 = dx*dx + dy*dy;
      if (d2 < bestDist2) { bestDist2 = d2; best = p; }
    }

    if (best && bestDist2 <= HIT_RADIUS_PX * HIT_RADIUS_PX) return { point: best, dist2: bestDist2 };
    return null;
  }

  function hitTestSegment(sx, sy) {
    const cache = new Map();
    const stack = new Set();

    let best = null;
    let bestDist2 = Infinity;

    for (const seg of segments) {
      const A = evalPrimitiveEndpoints('segment', seg.id, cache, stack);
      if (!A) continue;

      const a = worldToScreen(A.ax, A.ay);
      const b = worldToScreen(A.bx, A.by);

      const vx = b.x - a.x, vy = b.y - a.y;
      const wx = sx - a.x, wy = sy - a.y;

      const vv = vx*vx + vy*vy;
      if (vv < 1e-9) continue;

      let t = (wx*vx + wy*vy) / vv;
      t = Math.max(0, Math.min(1, t));

      const px = a.x + t * vx;
      const py = a.y + t * vy;

      const dx = sx - px, dy = sy - py;
      const d2 = dx*dx + dy*dy;

      if (d2 < bestDist2) { bestDist2 = d2; best = seg; }
    }

    if (best && bestDist2 <= SEG_HIT_PX * SEG_HIT_PX) return { seg: best, dist2: bestDist2 };
    return null;
  }

  // =========================
  // Tools / mutations
  // =========================
  function setTool(nextTool, anchorBtn=null) {
    tool = nextTool;

    toolPointBtn.classList.toggle('active', tool === 'point');
    toolSegmentBtn.classList.toggle('active', tool === 'segment');
    toolLineBtn.classList.toggle('active', tool === 'line');
    toolCircleBtn.classList.toggle('active', tool === 'circle');
    toolSelectBtn.classList.toggle('active', tool === 'select');

    dragging = false;
    dragPointerId = null;

    if (tool !== 'segment' && tool !== 'line' && tool !== 'circle') firstId = null;

    if (tool === 'point') {
      selectedId = null; firstId = null;
      showTip('<b>점 도구</b>: 클릭하면 점 생성<br/>⭐ 교점 근처 클릭 → <b>동적 교점(종속점)</b> 생성(원 포함)', anchorBtn || toolPointBtn);
    } else if (tool === 'segment') {
      selectedId = null; firstId = null;
      showTip('<b>선분 도구</b>: ① 첫 점 → ② 둘째 점 선택/생성하면 선분 생성', anchorBtn || toolSegmentBtn);
    } else if (tool === 'line') {
      selectedId = null; firstId = null;
      showTip('<b>직선 도구</b>: ① 첫 점 → ② 둘째 점 선택/생성하면 직선 생성', anchorBtn || toolLineBtn);
    } else if (tool === 'circle') {
      selectedId = null; firstId = null;
      showTip('<b>원 도구</b>: ① 중심점 선택/생성 → ② 점(반지름) 또는 선분(길이 반지름) 선택', anchorBtn || toolCircleBtn);
    } else {
      firstId = null;
      showTip('<b>선택/이동</b>: 자유점만 드래그 이동 가능(교점=종속점 이동 불가)', anchorBtn || toolSelectBtn);
    }
    draw();
  }

  function cancelFirstStep(anchorBtn=null) {
    if (!(tool === 'segment' || tool === 'line' || tool === 'circle')) {
      showTip('2단계 도구(선분/직선/원)에서만 사용할 수 있습니다.', anchorBtn || btnCancelFirst, 1200);
      return;
    }
    if (firstId) showTip('2단계 도구: <b>1단계 선택</b>을 취소했습니다.', anchorBtn || btnCancelFirst, 1200);
    firstId = null;
    draw();
  }

  function addFreePoint(wx, wy) {
    const p = { id: uid('p-'), kind: 'free', x: wx, y: wy };
    points.push(p);
    cleanupReferences();
    saveState();
    draw();
    return p.id;
  }

  function addIntersectionPoint(a_kind, a_id, b_kind, b_id, branch) {
    const c = canonicalizePair(a_kind, a_id, b_kind, b_id);
    const br = (branch === 1 ? 1 : 0);
    const p = { id: uid('i-'), kind: 'intersection', a_kind: c.a_kind, a_id: c.a_id, b_kind: c.b_kind, b_id: c.b_id, branch: br };
    points.push(p);
    cleanupReferences();
    saveState();
    draw();
    return p.id;
  }

  function addSegment(a_id, b_id) {
    if (a_id === b_id) return;
    segments.push({ id: uid('s-'), a_id, b_id });
    cleanupReferences();
    saveState();
    draw();
  }

  function addLine(a_id, b_id) {
    if (a_id === b_id) return;
    lines.push({ id: uid('l-'), a_id, b_id });
    cleanupReferences();
    saveState();
    draw();
  }

  function addCircle(center_id, r_kind, r_id) {
    circles.push({ id: uid('c-'), center_id, r_kind, r_id });
    cleanupReferences();
    saveState();
    draw();
  }

  function updateFreePoint(pid, wx, wy) {
    const idx = points.findIndex(p => p.id === pid);
    if (idx < 0) return;
    if (points[idx].kind === 'intersection') return;
    points[idx].x = wx;
    points[idx].y = wy;
    cleanupReferences();
    saveState();
    draw();
  }

  function undoPoint() {
    if (!points.length) { showTip('되돌릴 점이 없습니다.', btnUndoPoint, 900); return; }
    const removed = points.pop();

    segments = segments.filter(s => s.a_id !== removed.id && s.b_id !== removed.id);
    lines = lines.filter(l => l.a_id !== removed.id && l.b_id !== removed.id);

    if (selectedId === removed.id) selectedId = null;
    if (firstId === removed.id) firstId = null;

    cleanupReferences();
    saveState();
    draw();
    showTip('점 되돌리기 완료', btnUndoPoint, 900);
  }

  function undoSegment() {
    if (!segments.length) { showTip('되돌릴 선분이 없습니다.', btnUndoSeg, 900); return; }
    segments.pop();
    cleanupReferences();
    saveState();
    draw();
    showTip('선분 되돌리기 완료', btnUndoSeg, 900);
  }

  function undoLine() {
    if (!lines.length) { showTip('되돌릴 직선이 없습니다.', btnUndoLine, 900); return; }
    lines.pop();
    cleanupReferences();
    saveState();
    draw();
    showTip('직선 되돌리기 완료', btnUndoLine, 900);
  }

  function undoCircle() {
    if (!circles.length) { showTip('되돌릴 원이 없습니다.', btnUndoCircle, 900); return; }
    circles.pop();
    cleanupReferences();
    saveState();
    draw();
    showTip('원 되돌리기 완료', btnUndoCircle, 900);
  }

  function clearAll() {
    points = []; segments = []; lines = []; circles = [];
    selectedId = null; firstId = null;
    saveState();
    draw();
    showTip('전체 삭제 완료', btnClearAll, 900);
  }

  // =========================
  // Drawing
  // =========================
  function resize() {
    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.floor(window.innerWidth * dpr);
    canvas.height = Math.floor(window.innerHeight * dpr);
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    origin.x = window.innerWidth / 2;
    origin.y = window.innerHeight / 2;
    draw();
  }

  function drawGrid() {
    const w = window.innerWidth, h = window.innerHeight;
    ctx.fillStyle = '#0b0f14';
    ctx.fillRect(0, 0, w, h);

    const minor = scale, major = scale * 5;

    function drawLines(step, alpha) {
      ctx.strokeStyle = `rgba(230, 237, 243, ${alpha})`;
      ctx.lineWidth = 1;

      let x0 = origin.x % step;
      for (let x = x0; x <= w; x += step) {
        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke();
      }
      let y0 = origin.y % step;
      for (let y = y0; y <= h; y += step) {
        ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke();
      }
    }

    drawLines(minor, 0.06);
    drawLines(major, 0.12);

    ctx.strokeStyle = 'rgba(230, 237, 243, 0.55)';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(0, origin.y); ctx.lineTo(w, origin.y); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(origin.x, 0); ctx.lineTo(origin.x, h); ctx.stroke();

    ctx.fillStyle = 'rgba(230, 237, 243, 0.75)';
    ctx.font = '12px system-ui';
    ctx.fillText('x', w - 18, origin.y - 10);
    ctx.fillText('y', origin.x + 10, 16);

    ctx.fillStyle = 'rgba(230, 237, 243, 0.85)';
    ctx.fillText('0', origin.x + 6, origin.y + 14);
  }

  function getWorldBounds() {
    const w = window.innerWidth, h = window.innerHeight;
    const tl = screenToWorld(0, 0);
    const br = screenToWorld(w, h);
    return {
      xmin: Math.min(tl.x, br.x),
      xmax: Math.max(tl.x, br.x),
      ymin: Math.min(tl.y, br.y),
      ymax: Math.max(tl.y, br.y),
    };
  }

  function clipInfiniteLineToWorldRect(ax, ay, bx, by, rect) {
    const dx = bx - ax;
    const dy = by - ay;
    const pts = [];

    function addIfValid(x, y, t) {
      if (x < rect.xmin - 1e-9 || x > rect.xmax + 1e-9) return;
      if (y < rect.ymin - 1e-9 || y > rect.ymax + 1e-9) return;
      pts.push({ x, y, t });
    }

    if (Math.abs(dx) > 1e-12) {
      let t = (rect.xmin - ax) / dx;
      addIfValid(rect.xmin, ay + t * dy, t);
      t = (rect.xmax - ax) / dx;
      addIfValid(rect.xmax, ay + t * dy, t);
    }

    if (Math.abs(dy) > 1e-12) {
      let t = (rect.ymin - ay) / dy;
      addIfValid(ax + t * dx, rect.ymin, t);
      t = (rect.ymax - ay) / dy;
      addIfValid(ax + t * dx, rect.ymax, t);
    }

    const uniq = [];
    for (const p of pts) {
      const hit = uniq.find(q => (p.x - q.x)**2 + (p.y - q.y)**2 < 1e-10);
      if (!hit) uniq.push(p);
    }
    if (uniq.length < 2) return null;

    uniq.sort((p, q) => p.t - q.t);
    return { p1: uniq[0], p2: uniq[uniq.length - 1] };
  }

  function drawLinesInfinite() {
    const rect = getWorldBounds();
    const cache = new Map();
    const stack = new Set();

    ctx.lineWidth = 2.5;
    ctx.strokeStyle = 'rgba(255, 190, 120, 0.65)';

    for (const ln of lines) {
      const A = evalPrimitiveEndpoints('line', ln.id, cache, stack);
      if (!A) continue;

      const clipped = clipInfiniteLineToWorldRect(A.ax, A.ay, A.bx, A.by, rect);
      if (!clipped) continue;

      const s1 = worldToScreen(clipped.p1.x, clipped.p1.y);
      const s2 = worldToScreen(clipped.p2.x, clipped.p2.y);

      ctx.beginPath(); ctx.moveTo(s1.x, s1.y); ctx.lineTo(s2.x, s2.y); ctx.stroke();
    }
  }

  function drawSegments() {
    const cache = new Map();
    const stack = new Set();

    ctx.lineWidth = 3;
    ctx.strokeStyle = 'rgba(180, 220, 255, 0.75)';

    for (const seg of segments) {
      const A = evalPrimitiveEndpoints('segment', seg.id, cache, stack);
      if (!A) continue;
      const sa = worldToScreen(A.ax, A.ay);
      const sb = worldToScreen(A.bx, A.by);
      ctx.beginPath(); ctx.moveTo(sa.x, sa.y); ctx.lineTo(sb.x, sb.y); ctx.stroke();
    }
  }

  function drawCircles() {
    const cache = new Map();
    const stack = new Set();

    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(120, 255, 180, 0.55)';

    for (const c of circles) {
      const cp = evalCircleParams(c.id, cache, stack);
      if (!cp) continue;

      const sc = worldToScreen(cp.cx, cp.cy);
      const rr = cp.r * scale;

      ctx.beginPath();
      ctx.arc(sc.x, sc.y, rr, 0, Math.PI * 2);
      ctx.stroke();
    }
  }

  function drawTwoStepPreview() {
    if (!firstId) return;
    if (!(tool === 'segment' || tool === 'line' || tool === 'circle')) return;

    const cache = new Map();
    const stack = new Set();
    const a = evalPoint(firstId, cache, stack);
    if (!a) return;

    if (tool === 'segment' || tool === 'line') {
      const sa = worldToScreen(a.x, a.y);
      const sb = worldToScreen(mouseWorld.x, mouseWorld.y);

      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.35)';
      ctx.setLineDash([6, 6]);
      ctx.beginPath(); ctx.moveTo(sa.x, sa.y); ctx.lineTo(sb.x, sb.y); ctx.stroke();
      ctx.setLineDash([]);
      return;
    }

    if (tool === 'circle') {
      const r = dist(a.x, a.y, mouseWorld.x, mouseWorld.y);
      if (r < 1e-10) return;

      const sc = worldToScreen(a.x, a.y);
      const rr = r * scale;

      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgba(120, 255, 180, 0.25)';
      ctx.setLineDash([6, 6]);
      ctx.beginPath(); ctx.arc(sc.x, sc.y, rr, 0, Math.PI * 2); ctx.stroke();
      ctx.setLineDash([]);
      return;
    }
  }

  function drawPoints() {
    const cache = new Map();
    const stack = new Set();

    for (const p of points) {
      const w = evalPoint(p.id, cache, stack);
      if (!w) continue;

      const s = worldToScreen(w.x, w.y);
      const isSelected = (p.id === selectedId);
      const isFirst = ((tool === 'segment' || tool === 'line' || tool === 'circle') && p.id === firstId);
      const isIntersection = (p.kind === 'intersection');

      let radius = 5;
      if (isSelected) radius = 7;
      if (isFirst) radius = 8;
      if (isIntersection) radius = Math.max(radius, 6);

      ctx.beginPath();
      ctx.arc(s.x, s.y, radius, 0, Math.PI * 2);

      ctx.fillStyle =
        isSelected ? 'rgba(255, 220, 120, 0.95)' :
        isFirst ? 'rgba(255, 200, 120, 0.85)' :
        isIntersection ? 'rgba(120, 255, 180, 0.92)' :
        'rgba(120, 200, 255, 0.95)';
      ctx.fill();

      ctx.lineWidth = 2;
      ctx.strokeStyle = isSelected ? 'rgba(255, 255, 255, 0.55)' : 'rgba(255, 255, 255, 0.35)';
      ctx.stroke();

      const tag = isIntersection ? 'I' : '';
      const label = `${tag}(${w.x.toFixed(2)}, ${w.y.toFixed(2)})`;
      ctx.font = '12px system-ui';
      ctx.fillStyle = 'rgba(230, 237, 243, 0.85)';
      ctx.fillText(label, s.x + 10, s.y - 10);
    }
  }

  function draw() {
    drawGrid();
    drawLinesInfinite();
    drawSegments();
    drawCircles();
    drawTwoStepPreview();
    drawPoints();
  }

  // =========================
  // Events
  // =========================
  canvas.addEventListener('pointermove', (e) => {
    const { sx, sy } = getCanvasLocalXY(e);
    const w = screenToWorld(sx, sy);
    mouseWorld = w;
    readout.textContent = `마우스: (${w.x.toFixed(2)}, ${w.y.toFixed(2)})`;
    if (firstId && (tool === 'segment' || tool === 'line' || tool === 'circle')) draw();
  });

  canvas.addEventListener('click', (e) => {
    const { sx, sy } = getCanvasLocalXY(e);
    const w = screenToWorld(sx, sy);

    // 점 도구: 교점이면 종속점 생성 (원 포함)
    if (tool === 'point') {
      const hit = hitTestPoint(sx, sy);
      if (hit) { showTip('이미 점이 있습니다.', toolPointBtn, 900); return; }

      const nearest = findNearestIntersectionToScreen(sx, sy);
      if (nearest && nearest.d2px <= INTERSECTION_HIT_PX * INTERSECTION_HIT_PX) {
        if (!hasIntersectionPoint(nearest.a_kind, nearest.a_id, nearest.b_kind, nearest.b_id, nearest.branch)) {
          addIntersectionPoint(nearest.a_kind, nearest.a_id, nearest.b_kind, nearest.b_id, nearest.branch);
          showTip('⭐ 동적 교점(종속점) 생성 완료', toolPointBtn, 1100);
        } else {
          showTip('이미 같은 교점(종속점)이 있습니다.', toolPointBtn, 1100);
        }
        return;
      }

      addFreePoint(w.x, w.y);
      return;
    }

    // 2단계 도구: 선분/직선
    if (tool === 'segment' || tool === 'line') {
      const hit = hitTestPoint(sx, sy);
      const pid = hit ? hit.point.id : addFreePoint(w.x, w.y);

      if (!firstId) {
        firstId = pid;
        showTip('2단계: <b>1단계(첫 점)</b> 선택됨 → 2단계를 선택하세요.',
          tool === 'segment' ? toolSegmentBtn : toolLineBtn, 1400);
        draw();
        return;
      }

      if (firstId === pid) {
        firstId = null;
        showTip('2단계: 1단계 선택을 <b>취소</b>했습니다.',
          tool === 'segment' ? toolSegmentBtn : toolLineBtn, 1200);
        draw();
        return;
      }

      if (tool === 'segment') {
        addSegment(firstId, pid);
        showTip('선분 생성 완료. 다음은 다시 1단계부터.', toolSegmentBtn, 1400);
      } else {
        addLine(firstId, pid);
        showTip('직선 생성 완료. 다음은 다시 1단계부터.', toolLineBtn, 1400);
      }
      firstId = null;
      draw();
      return;
    }

    // 2단계 도구: 원
    if (tool === 'circle') {
      if (!firstId) {
        const hit = hitTestPoint(sx, sy);
        const centerId = hit ? hit.point.id : addFreePoint(w.x, w.y);
        firstId = centerId;
        showTip('원 도구: <b>중심</b> 선택됨 → 2단계로 반지름을 결정하세요.<br/>(점 선택/생성 또는 선분 선택)',
          toolCircleBtn, 1700);
        draw();
        return;
      }

      const hitP = hitTestPoint(sx, sy);
      if (hitP) {
        const rimId = hitP.point.id;
        if (rimId === firstId) {
          showTip('중심과 같은 점은 반지름 점이 될 수 없습니다. 다른 점을 선택해 주세요.', toolCircleBtn, 1600);
          return;
        }
        addCircle(firstId, 'point', rimId);
        firstId = null;
        showTip('원 생성 완료(반지름=중심~점 거리). 다음은 다시 중심부터.', toolCircleBtn, 1500);
        draw();
        return;
      }

      const hitS = hitTestSegment(sx, sy);
      if (hitS) {
        addCircle(firstId, 'segment', hitS.seg.id);
        firstId = null;
        showTip('원 생성 완료(반지름=선분 길이). 다음은 다시 중심부터.', toolCircleBtn, 1500);
        draw();
        return;
      }

      const rimId = addFreePoint(w.x, w.y);
      addCircle(firstId, 'point', rimId);
      firstId = null;
      showTip('원 생성 완료(반지름 점을 새로 생성). 다음은 다시 중심부터.', toolCircleBtn, 1500);
      draw();
      return;
    }
  });

  // Select tool drag (자유점만 이동)
  canvas.addEventListener('pointerdown', (e) => {
    if (tool !== 'select') return;

    const { sx, sy } = getCanvasLocalXY(e);
    const hit = hitTestPoint(sx, sy);

    if (!hit) { selectedId = null; draw(); return; }

    const p = hit.point;
    selectedId = p.id;

    if (p.kind === 'intersection') {
      showTip('⛔ 교점은 <b>종속점</b>이라 직접 이동할 수 없습니다.<br/>부모 선/선분/원의 점을 이동해 주세요.', toolSelectBtn, 1700);
      draw();
      return;
    }

    dragging = true;
    dragPointerId = e.pointerId;

    const w = screenToWorld(sx, sy);
    dragOffset.x = w.x - p.x;
    dragOffset.y = w.y - p.y;

    try { canvas.setPointerCapture(e.pointerId); } catch {}
    showTip('자유점 선택됨. 드래그해서 이동하세요.', toolSelectBtn, 1100);
    draw();
  });

  canvas.addEventListener('pointermove', (e) => {
    if (tool !== 'select' || !dragging || e.pointerId !== dragPointerId || !selectedId) return;

    const pobj = findPointObj(selectedId);
    if (!pobj || pobj.kind === 'intersection') return;

    const { sx, sy } = getCanvasLocalXY(e);
    const w = screenToWorld(sx, sy);

    pobj.x = w.x - dragOffset.x;
    pobj.y = w.y - dragOffset.y;
    draw();
  });

  function endDrag(e) {
    if (tool !== 'select' || !dragging || e.pointerId !== dragPointerId) return;

    dragging = false;
    try { canvas.releasePointerCapture(e.pointerId); } catch {}
    dragPointerId = null;

    if (!selectedId) return;
    const p = findPointObj(selectedId);
    if (!p || p.kind === 'intersection') return;

    updateFreePoint(selectedId, p.x, p.y);
    showTip('이동 저장됨', toolSelectBtn, 900);
  }
  canvas.addEventListener('pointerup', endDrag);
  canvas.addEventListener('pointercancel', endDrag);

  // Buttons
  toolPointBtn.addEventListener('click', () => setTool('point', toolPointBtn));
  toolSegmentBtn.addEventListener('click', () => setTool('segment', toolSegmentBtn));
  toolLineBtn.addEventListener('click', () => setTool('line', toolLineBtn));
  toolCircleBtn.addEventListener('click', () => setTool('circle', toolCircleBtn));
  toolSelectBtn.addEventListener('click', () => setTool('select', toolSelectBtn));

  btnUndoPoint.addEventListener('click', undoPoint);
  btnUndoSeg.addEventListener('click', undoSegment);
  btnUndoLine.addEventListener('click', undoLine);
  btnUndoCircle.addEventListener('click', undoCircle);
  btnClearAll.addEventListener('click', clearAll);
  btnCancelFirst.addEventListener('click', () => cancelFirstStep(btnCancelFirst));

  // Shortcuts
  window.addEventListener('keydown', (e) => {
    const k = e.key.toLowerCase();
    if (k === 'p') setTool('point', null);
    if (k === 's') setTool('segment', null);
    if (k === 'l') setTool('line', null);
    if (k === 'c') setTool('circle', null);
    if (k === 'v') setTool('select', null);
    if (k === 'escape') cancelFirstStep(null);
  });

  window.addEventListener('resize', resize);

  // init
  cleanupReferences();
  saveState();
  resize();
  draw();

  if (didPurge) {
    showTip('이전 저장 찌꺼기를 <b>자동 삭제</b>하고 새 버전으로 시작합니다.', null, 1800);
  } else {
    showTip('점 도구(P): 이제 <b>원-직선/원-선분/원-원</b> 교점도 클릭해서 종속점 생성 가능합니다.', null, 1900);
  }
})();
</script>
</body>
</html>
