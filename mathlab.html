<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>mathlab</title>

  <!-- KaTeX (LaTeX 렌더링). 오프라인이면 로드 실패할 수 있으나, 그 경우 일반 텍스트로 표시됩니다. -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>

  <style>
    :root{
      --bg:#0b0f14;
      --border:#24314a;
      --text:#e8eefc;
      --muted:#aab6d1;
      --accent:#5aa2ff;
      --danger:#ff5a7a;
      --shadow:0 12px 40px rgba(0,0,0,.45);
      --btnRadius:12px;
      --font: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans KR", Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    html,body{ margin:0; height:100%; background:var(--bg); color:var(--text); font-family:var(--font); overflow:hidden; user-select:none; }
    #app{ position:fixed; inset:0; display:flex; flex-direction:column; }

    #topbar{
      display:flex; align-items:center; gap:10px;
      padding:10px 12px;
      background:linear-gradient(180deg, rgba(18,24,38,.95), rgba(18,24,38,.70));
      border-bottom:1px solid var(--border);
      backdrop-filter: blur(10px);
      z-index:10;
    }

    .group{
      display:flex; gap:8px; align-items:center;
      padding:6px;
      background:rgba(15,21,34,.55);
      border:1px solid rgba(36,49,74,.65);
      border-radius:16px;
      position:relative;
    }

    .btn{
      appearance:none;
      border:1px solid rgba(36,49,74,.9);
      background:rgba(18,24,38,.65);
      color:var(--text);
      padding:9px 10px;
      border-radius:var(--btnRadius);
      cursor:pointer;
      font-size:13px;
      line-height:1;
      display:inline-flex;
      align-items:center;
      gap:8px;
      transition: transform .05s ease, background .15s ease, border-color .15s ease;
      white-space:nowrap;
    }
    .btn:hover{ background:rgba(24,32,52,.75); border-color:rgba(90,162,255,.6); }
    .btn:active{ transform: translateY(1px); }
    .btn.active{
      border-color: rgba(90,162,255,.9);
      box-shadow: 0 0 0 2px rgba(90,162,255,.18) inset;
      background: rgba(90,162,255,.12);
    }
    .btn.danger{ border-color: rgba(255,90,122,.55); }
    .btn.danger:hover{ border-color: rgba(255,90,122,.9); background: rgba(255,90,122,.12); }

    .sep{ width:1px; height:26px; background:rgba(36,49,74,.75); margin:0 4px; }

    #hint{ margin-left:auto; color:var(--muted); font-size:12px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width: 44vw; }

    #canvasWrap{ position:relative; flex:1; overflow:hidden; }

    svg{
      position:absolute; inset:0;
      width:100%; height:100%;
      display:block;
      touch-action:none;
    }

    /* dropdown */
    #toolsMenu{
      position:absolute;
      top: calc(100% + 6px);
      left: 6px;
      min-width: 170px;
      background: rgba(18,24,38,.96);
      border:1px solid rgba(36,49,74,.95);
      border-radius: 14px;
      box-shadow: var(--shadow);
      padding:6px;
      display:none;
      z-index:40;
    }
    #toolsMenu .mBtn{ width:100%; justify-content:flex-start; }

    #floatingTip{
      position:fixed;
      z-index:50;
      max-width: 360px;
      background: rgba(18,24,38,.92);
      border:1px solid rgba(36,49,74,.9);
      border-radius: 14px;
      padding:10px 12px;
      box-shadow: var(--shadow);
      display:none;
      font-size:12px;
      color: var(--text);
      pointer-events:none;
    }
    #floatingTip .t{ font-weight:700; margin-bottom:6px; font-size:12px; }
    #floatingTip .d{ color: var(--muted); line-height:1.35; }

    .panel{
      position:fixed;
      z-index:60;
      width: 340px;
      background: rgba(18,24,38,.96);
      border:1px solid rgba(36,49,74,.95);
      border-radius: 16px;
      box-shadow: var(--shadow);
      padding:12px;
      display:none;
      user-select:text;
    }
    .panel h3{ margin:0 0 8px 0; font-size:14px; color: var(--text); }

    .row{ display:flex; gap:8px; align-items:center; margin:8px 0; }
    .row label{ width:88px; color: var(--muted); font-size:12px; }
    .row input, .row textarea{
      flex:1;
      background: rgba(15,21,34,.85);
      border:1px solid rgba(36,49,74,.85);
      color: var(--text);
      border-radius: 12px;
      padding:8px 10px;
      font-size:12px;
      outline:none;
    }
    .row textarea{ min-height: 80px; resize: vertical; font-family: var(--font); }
    .actions{ display:flex; gap:8px; justify-content:flex-end; margin-top:10px; }
    .mini{ font-size:12px; padding:8px 10px; border-radius: 12px; }

    #siteLink{ position:fixed; left:12px; bottom:12px; z-index:20; text-decoration:none; }

    /* SVG foreignObject inner styling */
    .foText, .foLabel{ overflow:visible; }

    .textItem{
      pointer-events:auto;
      white-space:pre-wrap;
      color:var(--text);
      font-size:16px;
      line-height:1.25;
      padding:4px 6px;
      border-radius:10px;
      background: rgba(18,24,38,.0);
      border:1px solid rgba(0,0,0,0);
      transform: translate(-50%, -50%);
      display:inline-block;
    }
    .textItem.selected{
      background: rgba(90,162,255,.10);
      border-color: rgba(90,162,255,.50);
      box-shadow: 0 0 0 2px rgba(90,162,255,.12) inset;
    }

    .labelItem{
      pointer-events:none;
      transform: translate(-50%, -50%);
      font-size:13px;
      color: rgba(232,238,252,.92);
      background: rgba(18,24,38,.55);
      border: 1px solid rgba(36,49,74,.7);
      border-radius:10px;
      padding:3px 6px;
      box-shadow: 0 10px 26px rgba(0,0,0,.30);
      white-space:nowrap;
      display:inline-block;
    }

    @media (max-width: 820px){
      #hint{ display:none; }
      .panel{ width: 90vw; }
    }
  </style>
</head>

<body>
<div id="app">
  <div id="topbar">
    <div class="group" id="toolGroup">
      <button class="btn" data-tool="select" id="btnSelect">선택/이동</button>

      <div class="group" style="padding:0; background:transparent; border:none;">
        <button class="btn" id="btnTools">도구 ▾</button>
        <div id="toolsMenu" aria-hidden="true">
          <button class="btn mBtn" data-tool="point">점</button>
          <button class="btn mBtn" data-tool="segment">선분</button>
          <button class="btn mBtn" data-tool="line">직선</button>
          <button class="btn mBtn" data-tool="circle">원</button>
          <button class="btn mBtn" data-tool="parabola">포물선</button>
          <button class="btn mBtn" data-tool="ellipse">타원</button>
          <button class="btn mBtn" data-tool="hyperbola">쌍곡선</button>
        </div>
      </div>

      <button class="btn" data-tool="text" id="btnText">텍스트</button>
    </div>

    <div class="group">
      <button class="btn" id="btnUndo">이전(Undo)</button>
      <button class="btn" id="btnRedo">다음(Redo)</button>
      <div class="sep"></div>
      <button class="btn" id="btnLang">KO</button>
    </div>

    <div id="hint"></div>
  </div>

  <div id="canvasWrap">
    <svg id="sv" xmlns="http://www.w3.org/2000/svg"></svg>
  </div>
</div>

<a id="siteLink" class="btn" href="https://min7014.github.io" target="_blank" rel="noopener">min7014.github.io</a>

<div id="floatingTip">
  <div class="t" id="tipTitle"></div>
  <div class="d" id="tipDesc"></div>
</div>

<div class="panel" id="objEditor">
  <h3 id="objTitle">객체 속성</h3>
  <div class="row"><label id="lblKind">종류</label><input id="objKind" readonly /></div>
  <div class="row"><label>ID</label><input id="objId" readonly /></div>
  <div class="row"><label id="lblName">이름</label><input id="objName" placeholder="예: A, l1, c1 ..." /></div>
  <div class="row"><label id="lblCaption">캡션</label><textarea id="objCaption" placeholder="예: $\mathrm{A}$ 또는 $y=x^2$"></textarea></div>
  <div class="row" id="rowX"><label>X</label><input id="objX" /></div>
  <div class="row" id="rowY"><label>Y</label><input id="objY" /></div>
  <div class="actions">
    <button class="btn mini danger" id="btnObjCancel">취소</button>
    <button class="btn mini" id="btnObjSave">저장</button>
  </div>
</div>

<div class="panel" id="textEditor">
  <h3 id="textTitle">텍스트 편집</h3>
  <div class="row"><label id="lblText">내용</label><textarea id="textContent" placeholder="텍스트. $...$ 안은 LaTeX로 렌더링됩니다."></textarea></div>
  <div class="actions">
    <button class="btn mini danger" id="btnTextCancel">취소</button>
    <button class="btn mini" id="btnTextSave">저장</button>
  </div>
</div>

<script>
(() => {
  "use strict";

  // =========================
  // 0) localStorage "찌꺼기" 정리(버전 변경 시)
  // =========================
  const BUILD_ID = "2026-01-20-svg-smooth-v1";
  const BUILD_KEY = "mathlab_build_id";
  try{
    const prev = localStorage.getItem(BUILD_KEY);
    if (prev !== BUILD_ID){
      const del = [];
      for (let i=0;i<localStorage.length;i++){
        const k = localStorage.key(i);
        if (!k) continue;
        if (k.startsWith("mathlab_state_v1_") || k === "mathlab_session_id_v1") del.push(k);
      }
      for (const k of del) localStorage.removeItem(k);
      localStorage.setItem(BUILD_KEY, BUILD_ID);
    }
  }catch(e){}

  const I18N = {
    ko: {
      tools: {
        select: { name:"선택/이동", desc:"객체 선택 후 드래그로 이동합니다. 빈 공간을 드래그하면 좌표평면이 이동합니다. 선택된 객체에서 Enter 키를 누르면 속성창이 열립니다." },
        point:  { name:"점", desc:"클릭으로 점 생성. 도형 위 클릭이면 그 위에서만 움직이는 종속점 생성. 교점도 생성 가능." },
        segment:{ name:"선분", desc:"첫 점 선택/생성 → 둘째 점 선택/생성하면 선분 생성. 선분 1개 생성 후 다음 클릭은 새 선분의 첫 점입니다." },
        line:   { name:"직선", desc:"두 점 선택/생성하면 그 두 점을 지나는 직선 생성." },
        circle: { name:"원", desc:"중심점 선택/생성 → 원 위 점 선택/생성으로 원 생성." },
        parabola:{ name:"포물선", desc:"초점 점 선택/생성 → 준선(직선/선분) 선택 또는 두 점으로 준선 지정 시 포물선 생성." },
        ellipse:{ name:"타원", desc:"초점1 → 초점2 → 타원 위 점(3번째 점)으로 타원 생성." },
        hyperbola:{ name:"쌍곡선", desc:"초점1 → 초점2 → 쌍곡선 위 점(3번째 점)으로 쌍곡선 생성." },
        text:   { name:"텍스트", desc:"클릭 위치에 텍스트 생성. $...$ 내부는 LaTeX로 렌더링됩니다." },
      },
      ui: {
        hint:"팁: 선택도구에서 빈 공간 드래그 → 좌표평면 이동 / 객체 선택 후 Enter → 속성창 / 텍스트 더블클릭 → 내용 편집 / Shift+더블클릭 → 속성창",
        objTitle:"객체 속성",
        kind:"종류",
        name:"이름",
        caption:"캡션",
        textTitle:"텍스트 편집",
        content:"내용",
        undo:"이전(Undo)",
        redo:"다음(Redo)",
        tools:"도구",
      }
    },
    en: {
      tools: {
        select: { name:"Select/Move", desc:"Select and drag to move objects. Drag empty space to pan the plane. Press Enter on a selected object to open properties." },
        point:  { name:"Point", desc:"Click to create a point. Click on objects to create constrained points (also intersections)." },
        segment:{ name:"Segment", desc:"Pick/create first point → pick/create second point to create a segment. Then it resets for a new segment." },
        line:   { name:"Line", desc:"Pick/create two points to create a line." },
        circle: { name:"Circle", desc:"Pick/create center → pick/create a point on circle." },
        parabola:{ name:"Parabola", desc:"Pick/create focus → choose directrix (line/segment) or define by two points." },
        ellipse:{ name:"Ellipse", desc:"Focus1 → Focus2 → a point on the ellipse." },
        hyperbola:{ name:"Hyperbola", desc:"Focus1 → Focus2 → a point on the hyperbola." },
        text:   { name:"Text", desc:"Click to create text. Anything inside $...$ is rendered as LaTeX." },
      },
      ui: {
        hint:"Tip: In Select tool, drag empty space to pan / Enter opens properties / Double-click text edits content / Shift+Double-click opens properties",
        objTitle:"Object Properties",
        kind:"Kind",
        name:"Name",
        caption:"Caption",
        textTitle:"Edit Text",
        content:"Content",
        undo:"Undo",
        redo:"Redo",
        tools:"Tools",
      }
    }
  };

  let lang = "ko";
  const t = () => I18N[lang];
  const $ = (id) => document.getElementById(id);
  const rndId = () => Math.random().toString(36).slice(2, 10);
  const clamp = (v,a,b) => Math.max(a, Math.min(b, v));
  const dist2 = (ax,ay,bx,by) => (ax-bx)*(ax-bx)+(ay-by)*(ay-by);
  const dist = (ax,ay,bx,by) => Math.hypot(ax-bx, ay-by);
  const deepClone = (o) => JSON.parse(JSON.stringify(o));

  function escapeHtml(s){
    return s.replace(/[&<>"']/g, (c) => ({"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"}[c]));
  }

  function renderMixedLatex(raw){
    if (!raw) return "";
    const hasKaTeX = typeof katex !== "undefined" && katex.renderToString;
    if (!hasKaTeX) return escapeHtml(raw);

    let out = "";
    let i = 0;
    while (i < raw.length){
      const s = raw.indexOf("$", i);
      if (s === -1){ out += escapeHtml(raw.slice(i)); break; }
      const e = raw.indexOf("$", s+1);
      if (e === -1){ out += escapeHtml(raw.slice(i)); break; }

      out += escapeHtml(raw.slice(i, s));
      const latex = raw.slice(s+1, e);
      try{
        out += katex.renderToString(latex, {throwOnError:false, displayMode:false});
      }catch(err){
        out += "<span style='color:rgba(255,90,122,.95)'>" + escapeHtml("$"+latex+"$") + "</span>";
      }
      i = e+1;
    }
    return out;
  }

  // =========================
  // per-session separation (탭/사용자별 분리)
  // =========================
  const SESSION_KEY = "mathlab_session_id_v1";
  let sessionId = sessionStorage.getItem(SESSION_KEY);
  if (!sessionId) {
    sessionId = "s_" + rndId();
    sessionStorage.setItem(SESSION_KEY, sessionId);
  }
  const STORE_KEY = "mathlab_state_v1_" + sessionId;

  // =========================
  // state
  // =========================
  let objects = [];
  let tool = "select";
  let selected = null;

  let dragging = null; // {id, kind}
  let isPanning = false;
  let panStart = null; // {sx, sy, camX, camY, scale}

  let segmentPending = null;
  let linePending = null;
  let circlePending = null;
  let parabolaPending = { focusId:null, directrixP1:null, directrixP2:null };
  let ellipsePending = { f1:null, f2:null };
  let hyperbolaPending = { f1:null, f2:null };

  const cam = { x:0, y:0, scale:70 };
  let lastMouseClient = { cx: 200, cy: 120 };

  const undoStack = [];
  const redoStack = [];

  // =========================
  // storage
  // =========================
  function saveToStorage(){
    try{
      localStorage.setItem(STORE_KEY, JSON.stringify({
        objects, cam, tool, selected,
        segmentPending, linePending, circlePending,
        parabolaPending, ellipsePending, hyperbolaPending
      }));
    }catch(e){}
  }

  function loadFromStorage(){
    try{
      const raw = localStorage.getItem(STORE_KEY);
      if (!raw) return false;
      const st = JSON.parse(raw);
      objects = st.objects || [];
      cam.x = st.cam?.x ?? 0;
      cam.y = st.cam?.y ?? 0;
      cam.scale = st.cam?.scale ?? 70;
      tool = st.tool || "select";
      selected = st.selected || null;

      segmentPending = st.segmentPending ?? null;
      linePending = st.linePending ?? null;
      circlePending = st.circlePending ?? null;
      parabolaPending = st.parabolaPending || { focusId:null, directrixP1:null, directrixP2:null };
      ellipsePending = st.ellipsePending || { f1:null, f2:null };
      hyperbolaPending = st.hyperbolaPending || { f1:null, f2:null };
      return true;
    }catch(e){
      return false;
    }
  }

  function pushState(){
    undoStack.push({
      objects: deepClone(objects),
      cam: deepClone(cam),
      tool,
      selected: selected ? deepClone(selected) : null,
      segmentPending, linePending, circlePending,
      parabolaPending: deepClone(parabolaPending),
      ellipsePending: deepClone(ellipsePending),
      hyperbolaPending: deepClone(hyperbolaPending)
    });
    if (undoStack.length > 80) undoStack.shift();
    redoStack.length = 0;
    saveToStorage();
    sceneDirty = true;
  }

  function applyState(st){
    objects = deepClone(st.objects || []);
    cam.x = st.cam?.x ?? 0;
    cam.y = st.cam?.y ?? 0;
    cam.scale = st.cam?.scale ?? 70;
    tool = st.tool || "select";
    selected = st.selected ? deepClone(st.selected) : null;

    segmentPending = st.segmentPending ?? null;
    linePending = st.linePending ?? null;
    circlePending = st.circlePending ?? null;
    parabolaPending = st.parabolaPending ? deepClone(st.parabolaPending) : { focusId:null, directrixP1:null, directrixP2:null };
    ellipsePending = st.ellipsePending ? deepClone(st.ellipsePending) : { f1:null, f2:null };
    hyperbolaPending = st.hyperbolaPending ? deepClone(st.hyperbolaPending) : { f1:null, f2:null };

    syncToolUI();
    saveToStorage();
    sceneDirty = true;
  }

  function undo(){
    if (!undoStack.length) return;
    const cur = {
      objects: deepClone(objects),
      cam: deepClone(cam),
      tool,
      selected: selected ? deepClone(selected) : null,
      segmentPending, linePending, circlePending,
      parabolaPending: deepClone(parabolaPending),
      ellipsePending: deepClone(ellipsePending),
      hyperbolaPending: deepClone(hyperbolaPending)
    };
    redoStack.push(cur);
    const prev = undoStack.pop();
    applyState(prev);
  }

  function redo(){
    if (!redoStack.length) return;
    const cur = {
      objects: deepClone(objects),
      cam: deepClone(cam),
      tool,
      selected: selected ? deepClone(selected) : null,
      segmentPending, linePending, circlePending,
      parabolaPending: deepClone(parabolaPending),
      ellipsePending: deepClone(ellipsePending),
      hyperbolaPending: deepClone(hyperbolaPending)
    };
    undoStack.push(cur);
    const next = redoStack.pop();
    applyState(next);
  }

  // =========================
  // Name uniqueness (STEAL MODE) + 캡션은 변경하지 않음
  // =========================
  function getUsedNames(exceptId=null){
    const s = new Set();
    for (const o of objects){
      if (exceptId && o.id === exceptId) continue;
      const nm = (o.name && String(o.name).trim()) ? String(o.name).trim() : "";
      if (nm) s.add(nm);
    }
    return s;
  }

  function splitBaseAndIndex(name){
    const s = String(name || "").trim();
    let m = s.match(/^(.+)_\{(\d+)\}$/);
    if (m) return {base: m[1], idx: parseInt(m[2],10)};
    m = s.match(/^(.+)_([0-9]+)$/);
    if (m) return {base: m[1], idx: parseInt(m[2],10)};
    return {base: s, idx: null};
  }

  function nextIndexedName(base, usedSet){
    let k = 1;
    while (true){
      const cand = `${base}_{${k}}`;
      if (!usedSet.has(cand)) return cand;
      k++;
      if (k > 9999) return `${base}_{${Date.now()%100000}}`;
    }
  }

  // ✅ 이름 중복이면 기존 객체 이름만 A_{n}으로 바꾸고, 캡션은 그대로 둠
  function assignNameSteal(targetId, desiredRaw){
    const desired = String(desiredRaw || "").trim();
    const target = objects.find(o => o.id === targetId);
    if (!target) return;

    if (!desired){
      target.name = "";
      target.nameAuto = false;
      return;
    }

    const used = getUsedNames(null);
    const conflicts = objects.filter(o => o.id !== targetId && (o.name||"").trim() === desired);

    if (conflicts.length){
      const {base} = splitBaseAndIndex(desired);
      for (const c of conflicts){
        const newName = nextIndexedName(base, used);
        c.name = newName;
        c.nameAuto = false;
        used.add(newName);
        // 캡션은 절대 변경하지 않음
      }
    }

    target.name = desired;
    target.nameAuto = false;
  }

  // =========================
  // Auto point labels (creation only)
  // =========================
  const ALPH = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";

  function labelToIndex(name){
    const s = String(name || "").trim();
    let m = s.match(/^([A-Z])$/);
    if (m) return (m[1].charCodeAt(0) - 65);
    m = s.match(/^([A-Z])_\{(\d+)\}$/);
    if (m){
      const r = (m[1].charCodeAt(0) - 65);
      const q = parseInt(m[2],10);
      if (!Number.isFinite(q) || q < 1) return null;
      return q*26 + r;
    }
    m = s.match(/^([A-Z])_(\d+)$/);
    if (m){
      const r = (m[1].charCodeAt(0) - 65);
      const q = parseInt(m[2],10);
      if (!Number.isFinite(q) || q < 1) return null;
      return q*26 + r;
    }
    return null;
  }

  function indexToLabel(i){
    const r = i % 26;
    const q = Math.floor(i / 26);
    if (q === 0) return ALPH[r];
    return `${ALPH[r]}_{${q}}`;
  }

  function nextPointLabel(){
    const usedNames = getUsedNames(null);
    const usedIdx = new Set();
    for (const o of objects){
      const nm = (o.name && String(o.name).trim()) ? String(o.name).trim() : "";
      const idx = labelToIndex(nm);
      if (idx !== null) usedIdx.add(idx);
    }
    let i = 0;
    while (true){
      const cand = indexToLabel(i);
      if (!usedIdx.has(i) && !usedNames.has(cand)) return cand;
      i++;
      if (i > 5000) return `P_{${Date.now()%10000}}`;
    }
  }

  function buildCaptionForLabel(label){
    const s = String(label || "").trim();
    return `$\\mathrm{${s}}$`;
  }

  function applyAutoPointLabel(p){
    if (!p || p.kind !== "point") return;

    const hasName = !!(p.name && String(p.name).trim());
    const hasCap  = !!(p.caption && String(p.caption).trim());

    if (!hasName){
      const label = nextPointLabel();
      p.name = label;
      p.nameAuto = true;
      if (!hasCap){
        p.caption = buildCaptionForLabel(label);
        p.captionAuto = true;
      }
      return;
    }

    if (!hasCap){
      p.caption = buildCaptionForLabel(String(p.name).trim());
      p.captionAuto = true;
    }
  }

  function normalizeAllPointLabels(){
    for (const o of objects){
      if (o.kind === "point") applyAutoPointLabel(o);
    }
  }

  // =========================
  // SVG + coords
  // =========================
  const sv = $("sv");
  const NS = "http://www.w3.org/2000/svg";

  let W = 0, H = 0;
  function svgRect(){ return sv.getBoundingClientRect(); }
  function clientToSvg(clientX, clientY){
    const r = svgRect();
    return { sx: clientX - r.left, sy: clientY - r.top };
  }
  function canvasSizeCSS(){
    const r = svgRect();
    return { w: r.width, h: r.height };
  }

  function resize(){
    const r = svgRect();
    W = r.width; H = r.height;
    if (W < 10) W = 10;
    if (H < 10) H = 10;
    sv.setAttribute("viewBox", `0 0 ${W} ${H}`);
    sceneDirty = true;
  }
  window.addEventListener("resize", resize);

  function worldToScreen(wx, wy){
    return {
      sx: (wx - cam.x) * cam.scale + W/2,
      sy: H/2 - (wy - cam.y) * cam.scale
    };
  }
  function screenToWorld(sx, sy){
    return {
      wx: (sx - W/2) / cam.scale + cam.x,
      wy: (H/2 - sy) / cam.scale + cam.y
    };
  }

  function worldTol(){ return 10 / cam.scale; }

  function getViewportWorldBounds(){
    const a = screenToWorld(0,0);
    const b = screenToWorld(W,H);
    return {
      xmin: Math.min(a.wx, b.wx),
      xmax: Math.max(a.wx, b.wx),
      ymin: Math.min(a.wy, b.wy),
      ymax: Math.max(a.wy, b.wy)
    };
  }

  // =========================
  // Geometry helpers
  // =========================
  function getById(id){ return objects.find(o => o.id === id) || null; }

  function segmentIntersection(a,b,c,d){
    // skip invalid
    if (!Number.isFinite(a.x+a.y+b.x+b.y+c.x+c.y+d.x+d.y)) return null;
    const r = {x: b.x-a.x, y: b.y-a.y};
    const s = {x: d.x-c.x, y: d.y-c.y};
    const denom = r.x*s.y - r.y*s.x;
    if (Math.abs(denom) < 1e-12) return null;
    const uNumer = (c.x-a.x)*r.y - (c.y-a.y)*r.x;
    const tNumer = (c.x-a.x)*s.y - (c.y-a.y)*s.x;
    const t = tNumer/denom;
    const u = uNumer/denom;
    if (t >= 0 && t <= 1 && u >= 0 && u <= 1){
      return {x: a.x + t*r.x, y: a.y + t*r.y};
    }
    return null;
  }

  function polylineProject(poly, pt){
    if (!poly || poly.length < 2) return {x:pt.x, y:pt.y, t:0};
    let best = {d: Infinity, x: poly[0].x, y: poly[0].y, t:0};

    let total = 0;
    const lens = [];
    for (let i=0;i<poly.length-1;i++){
      const A = poly[i], B = poly[i+1];
      if (!Number.isFinite(A.x+A.y+B.x+B.y)) { lens.push(0); continue; }
      const L = dist(A.x,A.y, B.x,B.y);
      lens.push(L); total += L;
    }
    if (total < 1e-12) return {x:poly[0].x, y:poly[0].y, t:0};

    let acc = 0;
    for (let i=0;i<poly.length-1;i++){
      const A = poly[i], B = poly[i+1];
      if (!Number.isFinite(A.x+A.y+B.x+B.y)) { acc += lens[i]; continue; }
      const vx = B.x - A.x, vy = B.y - A.y;
      const vv = vx*vx + vy*vy;
      let u = 0;
      if (vv > 1e-12){
        u = ((pt.x - A.x)*vx + (pt.y - A.y)*vy) / vv;
        u = clamp(u, 0, 1);
      }
      const px = A.x + u*vx;
      const py = A.y + u*vy;
      const d = dist2(px,py, pt.x,pt.y);
      if (d < best.d){
        const tLocal = (acc + u*lens[i]) / total;
        best = {d, x:px, y:py, t: tLocal};
      }
      acc += lens[i];
    }
    return {x:best.x, y:best.y, t:best.t};
  }

  function polylineIntersections(polyA, polyB){
    const out = [];
    if (!polyA || !polyB || polyA.length<2 || polyB.length<2) return out;
    for (let i=0;i<polyA.length-1;i++){
      const a = polyA[i], b = polyA[i+1];
      if (!Number.isFinite(a.x+a.y+b.x+b.y)) continue;
      for (let j=0;j<polyB.length-1;j++){
        const c = polyB[j], d = polyB[j+1];
        if (!Number.isFinite(c.x+c.y+d.x+d.y)) continue;
        const p = segmentIntersection(a,b,c,d);
        if (p) out.push(p);
      }
    }
    return out;
  }

  function getLineEqFromTwoPoints(p1, p2){
    const dx = p2.x - p1.x;
    const dy = p2.y - p1.y;
    let nx = dy, ny = -dx;
    const len = Math.hypot(nx, ny);
    if (len < 1e-12) return null;
    nx /= len; ny /= len;
    const d = nx*p1.x + ny*p1.y;
    return {nx, ny, d};
  }

  function acosh(x){ return Math.log(x + Math.sqrt(x*x - 1)); }

  function dynamicN(pixelSpan, minN, maxN, stepPx){
    const n = Math.ceil(Math.max(0, pixelSpan) / stepPx);
    return clamp(n, minN, maxN);
  }

  // =========================
  // Curve params (world)
  // =========================
  function getCircleParams(obj){
    const C = getById(obj.cId), P = getById(obj.pId);
    if (!C || !P) return null;
    const r = dist(C.x,C.y, P.x,P.y);
    if (r < 1e-12) return null;
    return {cx:C.x, cy:C.y, r};
  }

  function getEllipseParams(obj){
    const F1 = getById(obj.f1Id), F2 = getById(obj.f2Id), P = getById(obj.pId);
    if (!F1 || !F2 || !P) return null;
    const sum = dist(F1.x,F1.y,P.x,P.y) + dist(F2.x,F2.y,P.x,P.y);
    const a = sum/2;
    const c = dist(F1.x,F1.y,F2.x,F2.y)/2;
    if (a < 1e-10 || a < c + 1e-10) return null;
    const b = Math.sqrt(Math.max(0, a*a - c*c));
    const cx = (F1.x+F2.x)/2, cy = (F1.y+F2.y)/2;
    const ang = Math.atan2(F2.y-F1.y, F2.x-F1.x);
    return {cx, cy, a, b, ang};
  }

  function getHyperbolaParams(obj){
    const F1 = getById(obj.f1Id), F2 = getById(obj.f2Id), P = getById(obj.pId);
    if (!F1 || !F2 || !P) return null;

    const cx = (F1.x+F2.x)/2, cy = (F1.y+F2.y)/2;
    const ang = Math.atan2(F2.y-F1.y, F2.x-F1.x);
    const ca = Math.cos(ang), sa = Math.sin(ang);

    const c = dist(F1.x,F1.y,F2.x,F2.y)/2;
    if (c < 1e-9) return null;
    const diff = Math.abs(dist(P.x,P.y, F1.x,F1.y) - dist(P.x,P.y, F2.x,F2.y));
    const a = diff/2;
    if (a < 1e-6 || a >= c - 1e-6) return null;
    const b = Math.sqrt(Math.max(0, c*c - a*a));

    return {cx, cy, a, b, ang, ca, sa};
  }

  function getParabolaFrame(obj){
    const F = getById(obj.fId);
    const p1 = getById(obj.p1Id), p2 = getById(obj.p2Id);
    if (!F || !p1 || !p2) return null;
    const L = getLineEqFromTwoPoints(p1,p2);
    if (!L) return null;

    const nx = L.nx, ny = L.ny, d = L.d;
    const ux = -ny, uy = nx;
    const Ox = nx*d, Oy = ny*d;

    const fx = ux*(F.x - Ox) + uy*(F.y - Oy);
    const fy = nx*(F.x - Ox) + ny*(F.y - Oy);
    if (Math.abs(fy) < 1e-6) return null;

    return {nx, ny, ux, uy, Ox, Oy, fx, fy};
  }

  // =========================
  // sampleObject (for intersections/constraints/hitTest)
  // =========================
  function sampleObject(obj){
    const b = getViewportWorldBounds();
    const margin = 1.35;
    const xmin = b.xmin*margin, xmax = b.xmax*margin;
    const ymin = b.ymin*margin, ymax = b.ymax*margin;

    if (obj.kind === "segment"){
      const A = getById(obj.aId), B = getById(obj.bId);
      if (!A || !B) return null;
      return [{x:A.x,y:A.y},{x:B.x,y:B.y}];
    }

    if (obj.kind === "line"){
      const A = getById(obj.aId), B = getById(obj.bId);
      if (!A || !B) return null;
      const dx = B.x-A.x, dy = B.y-A.y;
      const L = Math.hypot(dx,dy);
      if (L < 1e-12) return null;
      const ux = dx/L, uy = dy/L;
      const diag = Math.hypot(xmax-xmin, ymax-ymin);
      const tlen = diag*2.0;
      return [
        {x: A.x - ux*tlen, y: A.y - uy*tlen},
        {x: A.x + ux*tlen, y: A.y + uy*tlen},
      ];
    }

    if (obj.kind === "circle"){
      const p = getCircleParams(obj);
      if (!p) return null;
      const rPx = p.r * cam.scale;
      const circPx = 2*Math.PI*Math.max(1, rPx);
      const N = dynamicN(circPx, 240, 12000, 0.8);
      const pts = [];
      for (let i=0;i<=N;i++){
        const ang = (i/N)*Math.PI*2;
        pts.push({x:p.cx + p.r*Math.cos(ang), y:p.cy + p.r*Math.sin(ang)});
      }
      return pts;
    }

    if (obj.kind === "ellipse"){
      const ep = getEllipseParams(obj);
      if (!ep) return null;
      // Ramanujan circumference approximation
      const aPx = ep.a * cam.scale;
      const bPx = ep.b * cam.scale;
      const h = Math.pow((aPx-bPx),2)/Math.pow((aPx+bPx),2);
      const per = Math.PI*(aPx+bPx)*(1 + (3*h)/(10+Math.sqrt(4-3*h)));
      const N = dynamicN(per, 260, 14000, 0.8);
      const ca = Math.cos(ep.ang), sa = Math.sin(ep.ang);
      const pts = [];
      for (let i=0;i<=N;i++){
        const th = (i/N)*Math.PI*2;
        const ex = ep.a*Math.cos(th);
        const ey = ep.b*Math.sin(th);
        const wx = ep.cx + ex*ca - ey*sa;
        const wy = ep.cy + ex*sa + ey*ca;
        pts.push({x:wx,y:wy});
      }
      return pts;
    }

    if (obj.kind === "hyperbola"){
      const hp = getHyperbolaParams(obj);
      if (!hp) return null;

      function toLocal(x,y){
        const dx = x - hp.cx, dy = y - hp.cy;
        return { x: dx*hp.ca + dy*hp.sa, y: -dx*hp.sa + dy*hp.ca };
      }
      const corners = [ toLocal(xmin,ymin), toLocal(xmin,ymax), toLocal(xmax,ymin), toLocal(xmax,ymax) ];
      let maxAbsX = 0;
      for (const p of corners) maxAbsX = Math.max(maxAbsX, Math.abs(p.x));
      const xMax = Math.max(hp.a*1.05, maxAbsX*1.6 + hp.a);

      const T = acosh(xMax / hp.a);
      const pixelSpan = (xMax - hp.a) * cam.scale * 2;
      const N = dynamicN(pixelSpan, 400, 16000, 0.9);

      const pts = [];
      for (let i=0;i<=N;i++){
        const tt = -T + (2*T)*i/N;
        const x = hp.a*Math.cosh(tt);
        const y = hp.b*Math.sinh(tt);
        const wx = hp.cx + x*hp.ca - y*hp.sa;
        const wy = hp.cy + x*hp.sa + y*hp.ca;
        pts.push({x:wx,y:wy});
      }
      pts.push({x:NaN, y:NaN});
      for (let i=0;i<=N;i++){
        const tt = -T + (2*T)*i/N;
        const x = -hp.a*Math.cosh(tt);
        const y = hp.b*Math.sinh(tt);
        const wx = hp.cx + x*hp.ca - y*hp.sa;
        const wy = hp.cy + x*hp.sa + y*hp.ca;
        pts.push({x:wx,y:wy});
      }
      return pts;
    }

    if (obj.kind === "parabola"){
      const fr = getParabolaFrame(obj);
      if (!fr) return null;

      const span = Math.max(xmax-xmin, ymax-ymin) * 1.5;
      const xMin = fr.fx - span;
      const xMax = fr.fx + span;

      const pixelSpan = Math.abs(xMax - xMin) * cam.scale;
      const N = dynamicN(pixelSpan, 420, 20000, 0.8);

      const pts = [];
      for (let i=0;i<=N;i++){
        const x = xMin + (i/N)*(xMax-xMin);
        const y = (((x - fr.fx)*(x - fr.fx)) + fr.fy*fr.fy) / (2*fr.fy);
        pts.push({x: fr.Ox + fr.ux*x + fr.nx*y, y: fr.Oy + fr.uy*x + fr.ny*y});
      }
      return pts.length >= 2 ? pts : null;
    }

    return null;
  }



  // =========================
  // Render sampling (high-res curves for smooth SVG)
  // =========================
  function polylineScreenLengthFromWorld(poly){
    let len = 0;
    let prev = null;
    for (const p of poly || []){
      if (!p || !Number.isFinite(p.x + p.y)) { prev = null; continue; }
      const s = worldToScreen(p.x, p.y);
      if (prev) len += Math.hypot(s.sx - prev.sx, s.sy - prev.sy);
      prev = s;
    }
    return len;
  }

  function sampleObjectRender(obj){
    // Use higher resolution for visually smooth curves without affecting intersections logic.
    if (!obj) return null;

    if (obj.kind === "parabola"){
      const fr = getParabolaFrame(obj);
      if (!fr) return null;

      const b = getViewportWorldBounds();
      const margin = 1.35;
      const xmin = b.xmin*margin, xmax = b.xmax*margin;
      const ymin = b.ymin*margin, ymax = b.ymax*margin;

      const span = Math.max(xmax-xmin, ymax-ymin) * 1.5;
      const xMin = fr.fx - span;
      const xMax = fr.fx + span;

      const build = (N) => {
        const pts = [];
        for (let i=0;i<=N;i++){
          const x = xMin + (i/N)*(xMax-xMin);
          const y = (((x - fr.fx)*(x - fr.fx)) + fr.fy*fr.fy) / (2*fr.fy);
          pts.push({x: fr.Ox + fr.ux*x + fr.nx*y, y: fr.Oy + fr.uy*x + fr.ny*y});
        }
        return pts;
      };

      const rough = build(240);
      const lenPx = polylineScreenLengthFromWorld(rough);
      const N = dynamicN(lenPx, 1000, 9000, 0.50);
      return build(N);
    }

    if (obj.kind === "hyperbola"){
      const hp = getHyperbolaParams(obj);
      if (!hp) return null;

      const b = getViewportWorldBounds();
      const margin = 1.35;
      const xmin = b.xmin*margin, xmax = b.xmax*margin;
      const ymin = b.ymin*margin, ymax = b.ymax*margin;

      function toLocal(x,y){
        const dx = x - hp.cx, dy = y - hp.cy;
        return { x: dx*hp.ca + dy*hp.sa, y: -dx*hp.sa + dy*hp.ca };
      }
      const corners = [ toLocal(xmin,ymin), toLocal(xmin,ymax), toLocal(xmax,ymin), toLocal(xmax,ymax) ];
      let maxAbsX = 0;
      for (const p of corners) maxAbsX = Math.max(maxAbsX, Math.abs(p.x));
      const xMax = Math.max(hp.a*1.05, maxAbsX*1.6 + hp.a);

      const T = acosh(xMax / hp.a);

      const buildBranch = (sign, N) => {
        const pts = [];
        for (let i=0;i<=N;i++){
          const tt = -T + (2*T)*i/N;
          const x = sign*hp.a*Math.cosh(tt);
          const y = hp.b*Math.sinh(tt);
          const wx = hp.cx + x*hp.ca - y*hp.sa;
          const wy = hp.cy + x*hp.sa + y*hp.ca;
          pts.push({x:wx,y:wy});
        }
        return pts;
      };

      const rough1 = buildBranch(1, 220);
      const rough2 = buildBranch(-1, 220);
      const lenPx = polylineScreenLengthFromWorld(rough1) + polylineScreenLengthFromWorld(rough2);
      const N = dynamicN(lenPx/2, 1000, 9000, 0.50);

      const pts = [];
      pts.push(...buildBranch(1, N));
      pts.push({x:NaN,y:NaN});
      pts.push(...buildBranch(-1, N));
      return pts;
    }

    // Others: use existing sampling
    return sampleObject(obj);
  }
  // =========================
  // dependent points
  // =========================
  function updateDependentPoints(){
    let changed = false;
    for (const o of objects){
      if (o.kind !== "point" || !o.constraint) continue;
      const c = o.constraint;

      if (c.type === "on"){
        const parent = getById(c.parentId);
        if (!parent) continue;
        const poly = sampleObject(parent);
        if (!poly) continue;
        const prevX = o.x, prevY = o.y;
        const proj = polylineProject(poly, {x:o.x,y:o.y});
        o.x = proj.x; o.y = proj.y; c.t = proj.t;
        if (Math.abs(o.x-prevX) > 1e-12 || Math.abs(o.y-prevY) > 1e-12) changed = true;
      }

      if (c.type === "intersection"){
        const A = getById(c.aId), B = getById(c.bId);
        if (!A || !B) continue;
        const pA = sampleObject(A);
        const pB = sampleObject(B);
        if (!pA || !pB) continue;

        const ints = polylineIntersections(pA, pB);
        if (!ints.length) continue;

        const ref = {x:o.x ?? c.seed?.x ?? 0, y:o.y ?? c.seed?.y ?? 0};
        let best = ints[0], bestD = dist2(ints[0].x,ints[0].y, ref.x,ref.y);
        for (let i=1;i<ints.length;i++){
          const dd = dist2(ints[i].x,ints[i].y, ref.x,ref.y);
          if (dd < bestD){ bestD = dd; best = ints[i]; }
        }

        if (Math.abs(o.x-best.x) > 1e-12 || Math.abs(o.y-best.y) > 1e-12) changed = true;
        o.x = best.x; o.y = best.y;
      }
    }
    return changed;
  }

  // =========================
  // Hit testing
  // =========================
  function hitTest(wx, wy){
    const tol = worldTol();

    let bestP = null;
    for (const o of objects){
      if (o.kind !== "point") continue;
      const d = dist(o.x,o.y, wx,wy);
      if (d <= tol && (!bestP || d < bestP.d)) bestP = {id:o.id, d};
    }
    if (bestP) return bestP.id;

    let bestO = null;
    for (const o of objects){
      if (o.kind === "point" || o.kind === "text") continue;
      const poly = sampleObject(o);
      if (!poly) continue;
      const proj = polylineProject(poly, {x:wx,y:wy});
      const d = dist(proj.x,proj.y, wx,wy);
      if (d <= tol*1.2 && (!bestO || d < bestO.d)) bestO = {id:o.id, d};
    }
    return bestO ? bestO.id : null;
  }

  function findNearestIntersectionCandidate(wx, wy){
    const tol = worldTol()*1.25;
    let best = null;

    const candidates = objects.filter(o => o.kind !== "point" && o.kind !== "text");
    for (let i=0;i<candidates.length;i++){
      for (let j=i+1;j<candidates.length;j++){
        const A = candidates[i], B = candidates[j];
        const pA = sampleObject(A), pB = sampleObject(B);
        if (!pA || !pB) continue;
        const ints = polylineIntersections(pA, pB);
        for (const p of ints){
          const d = dist(p.x,p.y, wx,wy);
          if (d <= tol && (!best || d < best.d)){
            best = {aId:A.id, bId:B.id, x:p.x, y:p.y, d};
          }
        }
      }
    }
    return best;
  }

  // =========================
  // Object creation
  // =========================
  function ensurePointAt(wx, wy){
    const id = "p_" + rndId();
    const p = { id, kind:"point", x: wx, y: wy, name:"", caption:"", constraint: null, nameAuto:true, captionAuto:true };
    applyAutoPointLabel(p);
    objects.push(p);
    sceneDirty = true;
    return p;
  }

  function getOrCreatePointNear(wx, wy, tolWorld){
    const tol2 = tolWorld*tolWorld;
    let best = null;
    for (const o of objects){
      if (o.kind !== "point") continue;
      const d = dist2(o.x,o.y, wx,wy);
      if (d <= tol2 && (!best || d < best.d)) best = {p:o, d};
    }
    if (best){ applyAutoPointLabel(best.p); return best.p; }
    return ensurePointAt(wx, wy);
  }

  function getOrCreatePointForClick(wx, wy){
    const tol = worldTol();
    return getOrCreatePointNear(wx, wy, tol);
  }

  function createIntersectionPoint(hit){
    const id = "p_" + rndId();
    const p = {
      id, kind:"point",
      x: hit.x, y: hit.y,
      name:"", caption:"",
      constraint: {type:"intersection", aId: hit.aId, bId: hit.bId, seed:{x:hit.x,y:hit.y}},
      nameAuto:true, captionAuto:true
    };
    applyAutoPointLabel(p);
    objects.push(p);
    sceneDirty = true;
    return p;
  }

  function createPointOnObject(parentId, wx, wy){
    const parent = getById(parentId);
    if (!parent) return null;
    const poly = sampleObject(parent);
    if (!poly) return null;
    const proj = polylineProject(poly, {x:wx,y:wy});

    const p = ensurePointAt(proj.x, proj.y);
    p.constraint = {type:"on", parentId, t: proj.t};
    sceneDirty = true;
    return p;
  }

  function createSegment(aId, bId){
    const id = "s_" + rndId();
    objects.push({id, kind:"segment", aId, bId, name:"", caption:""});
    sceneDirty = true;
    return id;
  }
  function createLine(aId, bId){
    const id = "l_" + rndId();
    objects.push({id, kind:"line", aId, bId, name:"", caption:""});
    sceneDirty = true;
    return id;
  }
  function createCircle(cId, pId){
    const id = "c_" + rndId();
    objects.push({id, kind:"circle", cId, pId, name:"", caption:""});
    sceneDirty = true;
    return id;
  }
  function createParabola(fId, p1Id, p2Id){
    const id = "pa_" + rndId();
    objects.push({id, kind:"parabola", fId, p1Id, p2Id, name:"", caption:""});
    sceneDirty = true;
    return id;
  }
  function createEllipse(f1Id, f2Id, pId){
    const id = "e_" + rndId();
    objects.push({id, kind:"ellipse", f1Id, f2Id, pId, name:"", caption:""});
    sceneDirty = true;
    return id;
  }
  function createHyperbola(f1Id, f2Id, pId){
    const id = "h_" + rndId();
    objects.push({id, kind:"hyperbola", f1Id, f2Id, pId, name:"", caption:""});
    sceneDirty = true;
    return id;
  }
  function createText(wx, wy, content){
    const id = "t_" + rndId();
    objects.push({id, kind:"text", x:wx, y:wy, content: content ?? (lang==="ko"?"텍스트":"Text"), name:"", caption:""});
    sceneDirty = true;
    return id;
  }

  // =========================
  // UI: tooltip (1s idle after button click)
  // =========================
  const floatingTip = $("floatingTip");
  const tipTitle = $("tipTitle");
  const tipDesc  = $("tipDesc");
  let tipTimer = null;
  let tipArmed = false;

  function cancelFloatingTip(){
    tipArmed = false;
    if (tipTimer){ clearTimeout(tipTimer); tipTimer = null; }
    floatingTip.style.display = "none";
  }

  function armTipNear(el, toolKey){
    cancelFloatingTip();
    tipArmed = true;
    const rect = el.getBoundingClientRect();
    const x = rect.right + 8;
    const y = rect.top;
    tipTimer = setTimeout(() => {
      if (!tipArmed) return;
      const info = t().tools[toolKey];
      tipTitle.textContent = info.name;
      tipDesc.textContent  = info.desc;
      floatingTip.style.left = x + "px";
      floatingTip.style.top  = y + "px";
      floatingTip.style.display = "block";
    }, 1000);
  }

  ["pointerdown","pointermove","wheel","keydown","touchstart"].forEach(ev => {
    window.addEventListener(ev, () => { if (tipArmed) cancelFloatingTip(); }, {passive:true});
  });

  // =========================
  // Editors
  // =========================
  const objEditor = $("objEditor");
  const objKind = $("objKind");
  const objId = $("objId");
  const objName = $("objName");
  const objCaption = $("objCaption");
  const rowX = $("rowX");
  const rowY = $("rowY");
  const objX = $("objX");
  const objY = $("objY");
  let editingObjId = null;

  function openObjEditor(sel, clientX, clientY){
    const obj = getById(sel.id);
    if (!obj) return;

    editingObjId = obj.id;
    $("objTitle").textContent = t().ui.objTitle;
    $("lblKind").textContent = t().ui.kind;
    $("lblName").textContent = t().ui.name;
    $("lblCaption").textContent = t().ui.caption;

    objKind.value = obj.kind;
    objId.value = obj.id;
    objName.value = obj.name || "";
    objCaption.value = obj.caption || "";

    const showXY = (obj.kind === "point" || obj.kind === "text");
    rowX.style.display = showXY ? "flex" : "none";
    rowY.style.display = showXY ? "flex" : "none";
    if (showXY){
      objX.value = (obj.x ?? 0);
      objY.value = (obj.y ?? 0);
    }

    const pad = 10;
    const w = 340;
    const h = 320;
    const x = clamp(clientX + 12, pad, window.innerWidth - w - pad);
    const y = clamp(clientY + 12, pad, window.innerHeight - h - pad);
    objEditor.style.left = x + "px";
    objEditor.style.top  = y + "px";
    objEditor.style.display = "block";
    setTimeout(() => objName.focus(), 0);
  }

  function closeObjEditor(){
    objEditor.style.display = "none";
    editingObjId = null;
  }

  $("btnObjCancel").addEventListener("click", (e) => { e.preventDefault(); e.stopPropagation(); closeObjEditor(); });
  $("btnObjSave").addEventListener("click", (e) => {
    e.preventDefault(); e.stopPropagation();
    if (!editingObjId) return;
    const obj = getById(editingObjId);
    if (!obj) { closeObjEditor(); return; }

    pushState();

    const proposed = (objName.value || "").trim();
    assignNameSteal(obj.id, proposed);

    obj.caption = objCaption.value || "";
    obj.captionAuto = false;

    if (obj.kind === "point" || obj.kind === "text"){
      const x = parseFloat(objX.value);
      const y = parseFloat(objY.value);
      if (Number.isFinite(x)) obj.x = x;
      if (Number.isFinite(y)) obj.y = y;
    }

    closeObjEditor();
    saveToStorage();
    sceneDirty = true;
  });

  const textEditor = $("textEditor");
  const textContent = $("textContent");
  let editingTextId = null;

  function openTextEditorFor(id, clientX, clientY){
    const obj = getById(id);
    if (!obj || obj.kind !== "text") return;

    editingTextId = id;
    $("textTitle").textContent = t().ui.textTitle;
    $("lblText").textContent = t().ui.content;
    textContent.value = obj.content || "";

    const pad = 10;
    const w = 340;
    const h = 240;
    const x = clamp(clientX + 12, pad, window.innerWidth - w - pad);
    const y = clamp(clientY + 12, pad, window.innerHeight - h - pad);
    textEditor.style.left = x + "px";
    textEditor.style.top  = y + "px";
    textEditor.style.display = "block";
    setTimeout(() => textContent.focus(), 0);
  }

  function closeTextEditor(){
    textEditor.style.display = "none";
    editingTextId = null;
  }

  $("btnTextCancel").addEventListener("click", (e) => { e.preventDefault(); e.stopPropagation(); closeTextEditor(); });
  $("btnTextSave").addEventListener("click", (e) => {
    e.preventDefault(); e.stopPropagation();
    if (!editingTextId) return;
    const obj = getById(editingTextId);
    if (!obj) { closeTextEditor(); return; }

    pushState();
    obj.content = textContent.value || "";
    closeTextEditor();
    saveToStorage();
    sceneDirty = true;
  });

  // ✅ 편집창 바깥 클릭 시 자동 닫힘
  document.addEventListener("pointerdown", (e) => {
    const target = e.target;
    if (objEditor.style.display === "block" && !objEditor.contains(target)) closeObjEditor();
    if (textEditor.style.display === "block" && !textEditor.contains(target)) closeTextEditor();
  }, true);

  window.addEventListener("keydown", (e) => {
    if (e.key === "Escape"){
      if (objEditor.style.display === "block") closeObjEditor();
      if (textEditor.style.display === "block") closeTextEditor();
    }
  });

  // =========================
  // Labels (caption default; name on selection)
  // =========================
  function renderNamePretty(name){
    const s = String(name||"").trim();
    if (!s) return "";
    return renderMixedLatex(`$\\mathrm{${s}}$`);
  }

  function buildLabelHtml(obj){
    const name = (obj.name && obj.name.trim()) ? obj.name.trim() : "";
    const cap  = (obj.caption && obj.caption.trim()) ? obj.caption.trim() : "";
    const isSel = (selected?.id === obj.id);

    if (name && cap){
      if (isSel) return renderNamePretty(name);
      return renderMixedLatex(cap);
    }
    if (cap) return renderMixedLatex(cap);
    if (name) return renderNamePretty(name);
    return "";
  }

  // 라벨 오프셋(픽셀) - SVG 전(캔버스) 체감
  function labelOffsetPx(kind){
    // offset distance is half of previous (pixel-constant, independent of zoom)
    if (kind === "point")   return {dx: 4, dy: -4};
    if (kind === "text")    return {dx: 3, dy: -4};
    return {dx: 0, dy: -4};
  }

  function getObjectAnchor(obj){
    if (!obj) return {x:0,y:0};
    if (obj.kind === "point") return {x:obj.x, y:obj.y};
    if (obj.kind === "text")  return {x:obj.x, y:obj.y};
    if (obj.kind === "segment" || obj.kind === "line"){
      const A = getById(obj.aId), B = getById(obj.bId);
      if (A && B) return {x:(A.x+B.x)/2, y:(A.y+B.y)/2};
    }
    if (obj.kind === "circle"){
      const C = getById(obj.cId);
      if (C) return {x:C.x, y:C.y};
    }
    if (obj.kind === "parabola"){
      const F = getById(obj.fId);
      if (F) return {x:F.x, y:F.y};
    }
    if (obj.kind === "ellipse"){
      const ep = getEllipseParams(obj);
      if (ep) return {x:ep.cx, y:ep.cy};
    }
    if (obj.kind === "hyperbola"){
      const hp = getHyperbolaParams(obj);
      if (hp) return {x:hp.cx, y:hp.cy};
    }
    return {x:0,y:0};
  }

  // =========================
  // SVG layers
  // =========================
  let gridLayer, axesLayer, geomLayer, pointLayer, labelLayer, textLayer;
  function svgEl(tag, attrs={}){
    const el = document.createElementNS(NS, tag);
    for (const [k,v] of Object.entries(attrs)) el.setAttribute(k, String(v));
    return el;
  }

  function ensureLayers(){
    if (gridLayer) return;
    sv.innerHTML = "";
    gridLayer  = svgEl("g", {id:"gridLayer"});
    axesLayer  = svgEl("g", {id:"axesLayer"});
    geomLayer  = svgEl("g", {id:"geomLayer"});
    pointLayer = svgEl("g", {id:"pointLayer"});
    labelLayer = svgEl("g", {id:"labelLayer"});
    textLayer  = svgEl("g", {id:"textLayer"});

    sv.appendChild(gridLayer);
    sv.appendChild(axesLayer);
    sv.appendChild(geomLayer);
    sv.appendChild(pointLayer);
    sv.appendChild(labelLayer);
    sv.appendChild(textLayer);
  }

  // =========================
  // Drawing: smooth curve path (Catmull-Rom -> cubic)
  // =========================
  function pointsToSmoothPath(pts){
    if (!pts || pts.length < 2) return "";
    const n = pts.length;
    const p = (i) => pts[clamp(i,0,n-1)];
    let d = `M ${pts[0].x.toFixed(2)} ${pts[0].y.toFixed(2)}`;
    if (n === 2){
      d += ` L ${pts[1].x.toFixed(2)} ${pts[1].y.toFixed(2)}`;
      return d;
    }
    for (let i=0;i<n-1;i++){
      const p0 = p(i-1), p1 = p(i), p2 = p(i+1), p3 = p(i+2);
      const cp1x = p1.x + (p2.x - p0.x)/6;
      const cp1y = p1.y + (p2.y - p0.y)/6;
      const cp2x = p2.x - (p3.x - p1.x)/6;
      const cp2y = p2.y - (p3.y - p1.y)/6;
      d += ` C ${cp1x.toFixed(2)} ${cp1y.toFixed(2)} ${cp2x.toFixed(2)} ${cp2y.toFixed(2)} ${p2.x.toFixed(2)} ${p2.y.toFixed(2)}`;
    }
    return d;
  }

  // =========================
  // Grid/Axes drawing
  // =========================
  function niceStep(target){
    const pow = Math.pow(10, Math.floor(Math.log10(target)));
    const x = target / pow;
    if (x < 1.5) return 1*pow;
    if (x < 3.5) return 2*pow;
    if (x < 7.5) return 5*pow;
    return 10*pow;
  }

  function drawGridAxes(){
    gridLayer.innerHTML = "";
    axesLayer.innerHTML = "";

    const bounds = getViewportWorldBounds();
    const step = niceStep(40 / cam.scale);

    const xmin = Math.floor(bounds.xmin/step)*step;
    const xmax = Math.ceil(bounds.xmax/step)*step;
    const ymin = Math.floor(bounds.ymin/step)*step;
    const ymax = Math.ceil(bounds.ymax/step)*step;

    // grid lines
    for (let x=xmin; x<=xmax; x+=step){
      const s1 = worldToScreen(x, ymin);
      const s2 = worldToScreen(x, ymax);
      const ln = svgEl("line", {
        x1: s1.sx, y1: s1.sy, x2: s2.sx, y2: s2.sy,
        stroke: "rgba(36,49,74,.35)",
        "stroke-width": 1,
        "shape-rendering": "geometricPrecision"
      });
      gridLayer.appendChild(ln);
    }
    for (let y=ymin; y<=ymax; y+=step){
      const s1 = worldToScreen(xmin, y);
      const s2 = worldToScreen(xmax, y);
      const ln = svgEl("line", {
        x1: s1.sx, y1: s1.sy, x2: s2.sx, y2: s2.sy,
        stroke: "rgba(36,49,74,.35)",
        "stroke-width": 1,
        "shape-rendering": "geometricPrecision"
      });
      gridLayer.appendChild(ln);
    }

    // axes
    const o = worldToScreen(0,0);

    axesLayer.appendChild(svgEl("line", {x1:0, y1:o.sy, x2:W, y2:o.sy, stroke:"rgba(170,182,209,.45)", "stroke-width":1}));
    axesLayer.appendChild(svgEl("line", {x1:o.sx, y1:0, x2:o.sx, y2:H, stroke:"rgba(170,182,209,.45)", "stroke-width":1}));

    // arrowheads
    const ah = 8;
    const arrow = (d) => axesLayer.appendChild(svgEl("path", {d, fill:"rgba(170,182,209,.75)"}));
    arrow(`M ${W-ah} ${o.sy-ah/2} L ${W} ${o.sy} L ${W-ah} ${o.sy+ah/2} Z`);
    arrow(`M ${ah} ${o.sy-ah/2} L 0 ${o.sy} L ${ah} ${o.sy+ah/2} Z`);
    arrow(`M ${o.sx-ah/2} ${ah} L ${o.sx} 0 L ${o.sx+ah/2} ${ah} Z`);
    arrow(`M ${o.sx-ah/2} ${H-ah} L ${o.sx} ${H} L ${o.sx+ah/2} ${H-ah} Z`);

    // origin label "0"
    const fo = svgEl("foreignObject", {x: o.sx + 6, y: o.sy - 18, width: 1, height: 1, class:"foLabel", style:"overflow:visible"});
    const div = document.createElement("div");
    div.setAttribute("xmlns","http://www.w3.org/1999/xhtml");
    div.style.transform = "translate(0,0)";
    div.style.fontSize = "12px";
    div.style.color = "rgba(232,238,252,.75)";
    div.style.whiteSpace = "nowrap";
    div.textContent = "0";
    fo.appendChild(div);
    axesLayer.appendChild(fo);
  }

  // =========================
  // Drawing objects
  // =========================
  function drawObjects(){
    geomLayer.innerHTML = "";
    pointLayer.innerHTML = "";
    labelLayer.innerHTML = "";
    textLayer.innerHTML = "";

    // draw non-point geometry first
    for (const o of objects){
      if (o.kind === "segment"){
        const A = getById(o.aId), B = getById(o.bId);
        if (!A || !B) continue;
        const a = worldToScreen(A.x,A.y);
        const b = worldToScreen(B.x,B.y);
        const ln = svgEl("line", {
          x1:a.sx, y1:a.sy, x2:b.sx, y2:b.sy,
          stroke: (selected?.id===o.id)?"rgba(90,162,255,.95)":"rgba(232,238,252,.72)",
          "stroke-width": 2,
          "stroke-linecap":"round",
          "stroke-linejoin":"round",
          "shape-rendering":"geometricPrecision"
        });
        geomLayer.appendChild(ln);
      }

      if (o.kind === "line"){
        const poly = sampleObject(o);
        if (!poly) continue;
        const a = worldToScreen(poly[0].x,poly[0].y);
        const b = worldToScreen(poly[1].x,poly[1].y);
        const ln = svgEl("line", {
          x1:a.sx, y1:a.sy, x2:b.sx, y2:b.sy,
          stroke: (selected?.id===o.id)?"rgba(90,162,255,.95)":"rgba(232,238,252,.55)",
          "stroke-width": 2,
          "stroke-linecap":"round",
          "stroke-linejoin":"round",
          "shape-rendering":"geometricPrecision"
        });
        geomLayer.appendChild(ln);
      }

      if (o.kind === "circle"){
        const cp = getCircleParams(o);
        if (!cp) continue;
        const c = worldToScreen(cp.cx, cp.cy);
        const r = cp.r * cam.scale;
        const el = svgEl("circle", {
          cx: c.sx, cy: c.sy, r: r,
          fill:"none",
          stroke: (selected?.id===o.id)?"rgba(90,162,255,.95)":"rgba(232,238,252,.62)",
          "stroke-width": 2,
          "stroke-linecap":"round",
          "stroke-linejoin":"round",
          "shape-rendering":"geometricPrecision"
        });
        geomLayer.appendChild(el);
      }

      if (o.kind === "ellipse"){
        const ep = getEllipseParams(o);
        if (!ep) continue;
        const c = worldToScreen(ep.cx, ep.cy);
        const rx = ep.a * cam.scale;
        const ry = ep.b * cam.scale;
        const el = svgEl("ellipse", {
          cx: c.sx, cy: c.sy, rx: rx, ry: ry,
          fill:"none",
          stroke: (selected?.id===o.id)?"rgba(90,162,255,.95)":"rgba(232,238,252,.62)",
          "stroke-width": 2,
          "stroke-linecap":"round",
          "stroke-linejoin":"round",
          "shape-rendering":"geometricPrecision"
        });
        const deg = ep.ang * 180/Math.PI;
        el.setAttribute("transform", `rotate(${deg.toFixed(4)} ${c.sx.toFixed(2)} ${c.sy.toFixed(2)})`);
        geomLayer.appendChild(el);
      }

      if (o.kind === "parabola"){
        const poly = sampleObjectRender(o);
        if (!poly) continue;
        const pts = poly.map(p => {
          const s = worldToScreen(p.x,p.y);
          return {x:s.sx, y:s.sy};
        });
        const d = pointsToSmoothPath(pts);
        if (!d) continue;
        const path = svgEl("path", {
          d,
          fill:"none",
          stroke: (selected?.id===o.id)?"rgba(90,162,255,.95)":"rgba(232,238,252,.62)",
          "stroke-width": 2,
          "stroke-linecap":"round",
          "stroke-linejoin":"round",
          "shape-rendering":"geometricPrecision"
        });
        geomLayer.appendChild(path);
      }

      if (o.kind === "hyperbola"){
        const poly = sampleObjectRender(o);
        if (!poly) continue;
        const branches = [];
        let cur = [];
        for (const p of poly){
          if (!Number.isFinite(p.x+p.y)){
            if (cur.length>=2) branches.push(cur);
            cur = [];
            continue;
          }
          const s = worldToScreen(p.x,p.y);
          cur.push({x:s.sx, y:s.sy});
        }
        if (cur.length>=2) branches.push(cur);

        for (const b of branches){
          const d = pointsToSmoothPath(b);
          if (!d) continue;
          const path = svgEl("path", {
            d,
            fill:"none",
            stroke: (selected?.id===o.id)?"rgba(90,162,255,.95)":"rgba(232,238,252,.62)",
            "stroke-width": 2,
            "stroke-linecap":"round",
            "stroke-linejoin":"round",
            "shape-rendering":"geometricPrecision"
          });
          geomLayer.appendChild(path);
        }
      }
    }

    // draw points
    for (const o of objects){
      if (o.kind !== "point") continue;
      const p = worldToScreen(o.x,o.y);
      const r = (selected?.id===o.id) ? 6 : 5;
      const fill = (selected?.id===o.id) ? "rgba(90,162,255,.95)" : "rgba(232,238,252,.9)";

      const circle = svgEl("circle", {
        cx: p.sx, cy: p.sy, r: r,
        fill: fill,
        stroke: "none",
        "shape-rendering":"geometricPrecision"
      });
      pointLayer.appendChild(circle);

      if (o.constraint){
        const ring = svgEl("circle", {
          cx: p.sx, cy: p.sy, r: r+2,
          fill:"none",
          stroke:"rgba(55,214,138,.8)",
          "stroke-width": 2,
          "shape-rendering":"geometricPrecision"
        });
        pointLayer.appendChild(ring);
      }
    }

    // labels
    for (const o of objects){
      const has = ((o.name && o.name.trim()) || (o.caption && o.caption.trim()));
      if (!has) continue;

      const a = getObjectAnchor(o);
      const s = worldToScreen(a.x,a.y);
      const off = labelOffsetPx(o.kind);

      const html = buildLabelHtml(o);
      if (!html) continue;

      const fo = svgEl("foreignObject", {x: s.sx + off.dx, y: s.sy + off.dy, width: 1, height: 1, class:"foLabel", style:"overflow:visible"});
      const div = document.createElement("div");
      div.setAttribute("xmlns","http://www.w3.org/1999/xhtml");
      div.className = "labelItem";
      div.innerHTML = html;
      fo.appendChild(div);
      labelLayer.appendChild(fo);
    }

    // text objects
    for (const o of objects){
      if (o.kind !== "text") continue;
      const s = worldToScreen(o.x,o.y);
      const fo = svgEl("foreignObject", {x: s.sx, y: s.sy, width: 1, height: 1, class:"foText", style:"overflow:visible"});
      const div = document.createElement("div");
      div.setAttribute("xmlns","http://www.w3.org/1999/xhtml");
      div.className = "textItem" + ((selected?.id===o.id)?" selected":"");
      div.dataset.id = o.id;
      div.innerHTML = renderMixedLatex(o.content || "");

      // pointerdown for drag (select tool)
      div.addEventListener("pointerdown", (e) => {
        cancelFloatingTip();
        e.stopPropagation();
        e.preventDefault();
        if (tool !== "select") return;
        const obj = getById(o.id);
        if (!obj) return;
        selected = {id:o.id};
        pushState();
        dragging = {id:o.id, kind:"text"};
        const {sx,sy} = clientToSvg(e.clientX, e.clientY);
        const w = screenToWorld(sx, sy);
        obj.x = w.wx; obj.y = w.wy;
        saveToStorage();
        sceneDirty = true;
        try { sv.setPointerCapture(e.pointerId); } catch {}
      });

      // dblclick: content edit (any tool), Shift+ dblclick: properties
      div.addEventListener("dblclick", (e) => {
        cancelFloatingTip();
        e.stopPropagation();
        e.preventDefault();
        if (textEditor.style.display === "block" || objEditor.style.display === "block") return;
        if (tool === "select" && (e.shiftKey || e.altKey)){
          openObjEditor({id:o.id}, e.clientX, e.clientY);
        } else {
          openTextEditorFor(o.id, e.clientX, e.clientY);
        }
      });

      fo.appendChild(div);
      textLayer.appendChild(fo);
    }
  }

  // =========================
  // Tools UI (dropdown)
  // =========================
  const btnSelect = $("btnSelect");
  const btnText = $("btnText");
  const btnTools = $("btnTools");
  const toolsMenu = $("toolsMenu");
  const toolItems = [...toolsMenu.querySelectorAll(".mBtn")];

  function openToolsMenu(){
    toolsMenu.style.display = "block";
    toolsMenu.setAttribute("aria-hidden","false");
  }
  function closeToolsMenu(){
    toolsMenu.style.display = "none";
    toolsMenu.setAttribute("aria-hidden","true");
  }
  function toggleToolsMenu(){
    if (toolsMenu.style.display === "block") closeToolsMenu();
    else openToolsMenu();
  }

  function isGroupedTool(k){
    return ["point","segment","line","circle","parabola","ellipse","hyperbola"].includes(k);
  }

  function setHint(){ $("hint").textContent = t().ui.hint; }

  function syncToolUI(){
    btnSelect.textContent = t().tools.select.name;
    btnText.textContent = t().tools.text.name;

    // grouped tools main label
    if (isGroupedTool(tool)) btnTools.textContent = `${t().tools[tool].name} ▾`;
    else btnTools.textContent = `${t().ui.tools} ▾`;

    btnSelect.classList.toggle("active", tool === "select");
    btnText.classList.toggle("active", tool === "text");
    btnTools.classList.toggle("active", isGroupedTool(tool));

    // menu items labels & active
    for (const it of toolItems){
      const k = it.dataset.tool;
      it.textContent = t().tools[k].name;
      it.classList.toggle("active", tool === k);
    }

    $("btnUndo").textContent = t().ui.undo;
    $("btnRedo").textContent = t().ui.redo;
    $("btnLang").textContent = (lang === "ko") ? "KO" : "EN";
    setHint();
  }

  btnSelect.addEventListener("click", () => {
    tool = "select";
    segmentPending = null; linePending = null; circlePending = null;
    parabolaPending = { focusId:null, directrixP1:null, directrixP2:null };
    ellipsePending = { f1:null, f2:null };
    hyperbolaPending = { f1:null, f2:null };
    closeToolsMenu();
    selected = null;
    dragging = null;
    isPanning = false; panStart = null;
    syncToolUI();
    armTipNear(btnSelect, "select");
    saveToStorage();
    sceneDirty = true;
  });

  btnText.addEventListener("click", () => {
    tool = "text";
    segmentPending = null; linePending = null; circlePending = null;
    parabolaPending = { focusId:null, directrixP1:null, directrixP2:null };
    ellipsePending = { f1:null, f2:null };
    hyperbolaPending = { f1:null, f2:null };
    closeToolsMenu();
    selected = null;
    dragging = null;
    isPanning = false; panStart = null;
    syncToolUI();
    armTipNear(btnText, "text");
    saveToStorage();
    sceneDirty = true;
  });

  btnTools.addEventListener("click", (e) => {
    cancelFloatingTip();
    e.stopPropagation();
    toggleToolsMenu();
    // tool tip: show currently selected grouped tool (if any) after idle
    const key = isGroupedTool(tool) ? tool : "point";
    armTipNear(btnTools, key);
  });

  toolItems.forEach(it => {
    it.addEventListener("click", (e) => {
      cancelFloatingTip();
      e.stopPropagation();
      const k = it.dataset.tool;
      tool = k;
      segmentPending = null; linePending = null; circlePending = null;
      parabolaPending = { focusId:null, directrixP1:null, directrixP2:null };
      ellipsePending = { f1:null, f2:null };
      hyperbolaPending = { f1:null, f2:null };
      selected = null;
      dragging = null;
      isPanning = false; panStart = null;
      closeToolsMenu();
      syncToolUI();
      saveToStorage();
      sceneDirty = true;
    });
  });

  // close dropdown on outside click
  document.addEventListener("pointerdown", (e) => {
    if (toolsMenu.style.display !== "block") return;
    const t0 = e.target;
    if (btnTools.contains(t0) || toolsMenu.contains(t0)) return;
    closeToolsMenu();
  }, true);

  window.addEventListener("keydown", (e) => {
    if (e.key === "Escape") closeToolsMenu();
  });

  $("btnUndo").addEventListener("click", () => { cancelFloatingTip(); undo(); });
  $("btnRedo").addEventListener("click", () => { cancelFloatingTip(); redo(); });

  $("btnLang").addEventListener("click", () => {
    cancelFloatingTip();
    lang = (lang === "ko") ? "en" : "ko";
    syncToolUI();
    sceneDirty = true;
  });

  // =========================
  // Pointer events on SVG
  // =========================
  let sceneDirty = true;
  let camDirty = true;
  let lastCamSig = "";

  function camSignature(){
    return `${cam.x.toFixed(6)}|${cam.y.toFixed(6)}|${cam.scale.toFixed(3)}|${W.toFixed(1)}|${H.toFixed(1)}`;
  }

  sv.addEventListener("pointermove", (e) => {
    lastMouseClient.cx = e.clientX;
    lastMouseClient.cy = e.clientY;

    const {sx,sy} = clientToSvg(e.clientX, e.clientY);

    if (isPanning && panStart){
      const dx = sx - panStart.sx;
      const dy = sy - panStart.sy;
      cam.x = panStart.camX - dx / panStart.scale;
      cam.y = panStart.camY + dy / panStart.scale;
      saveToStorage();
      sceneDirty = true;
      camDirty = true;
      return;
    }

    if (dragging){
      const w = screenToWorld(sx, sy);
      const obj = getById(dragging.id);
      if (!obj) return;

      if (dragging.kind === "point"){
        if (obj.constraint?.type === "intersection") return;
        if (obj.constraint?.type === "on"){
          const parent = getById(obj.constraint.parentId);
          const poly = parent ? sampleObject(parent) : null;
          if (poly){
            const proj = polylineProject(poly, {x:w.wx, y:w.wy});
            obj.x = proj.x; obj.y = proj.y; obj.constraint.t = proj.t;
          } else {
            obj.x = w.wx; obj.y = w.wy;
          }
        } else {
          obj.x = w.wx; obj.y = w.wy;
        }
      }

      if (dragging.kind === "text"){
        obj.x = w.wx; obj.y = w.wy;
      }

      saveToStorage();
      sceneDirty = true;
      return;
    }
  });

  sv.addEventListener("pointerdown", (e) => {
    cancelFloatingTip();
    closeToolsMenu();

    lastMouseClient.cx = e.clientX;
    lastMouseClient.cy = e.clientY;

    const {sx,sy} = clientToSvg(e.clientX, e.clientY);
    const w = screenToWorld(sx, sy);

    // avoid if editing
    if (objEditor.style.display === "block" || textEditor.style.display === "block") return;

    if (tool === "select"){
      const id = hitTest(w.wx,w.wy);
      if (id){
        selected = {id};
        const obj = getById(id);

        if (obj?.kind === "point"){
          if (obj.constraint?.type === "intersection"){
            dragging = null;
          } else {
            pushState();
            dragging = {id, kind:"point"};
            if (obj.constraint?.type === "on"){
              const parent = getById(obj.constraint.parentId);
              const poly = parent ? sampleObject(parent) : null;
              if (poly){
                const proj = polylineProject(poly, {x:w.wx, y:w.wy});
                obj.x = proj.x; obj.y = proj.y; obj.constraint.t = proj.t;
              } else {
                obj.x = w.wx; obj.y = w.wy;
              }
            } else {
              obj.x = w.wx; obj.y = w.wy;
            }
            saveToStorage();
          }
        } else {
          dragging = null;
        }

        isPanning = false;
        panStart = null;
      } else {
        selected = null;
        dragging = null;
        pushState();
        isPanning = true;
        panStart = { sx, sy, camX: cam.x, camY: cam.y, scale: cam.scale };
        camDirty = true;
      }

      sceneDirty = true;
      saveToStorage();
      try { sv.setPointerCapture(e.pointerId); } catch {}
      return;
    }

    if (tool === "point"){
      const hit = findNearestIntersectionCandidate(w.wx, w.wy);
      if (hit){
        pushState();
        const p = createIntersectionPoint(hit);
        selected = {id:p.id};
        saveToStorage();
        sceneDirty = true;
        return;
      }

      const id = hitTest(w.wx,w.wy);
      const obj = id ? getById(id) : null;
      if (obj && obj.kind !== "point" && obj.kind !== "text"){
        pushState();
        const p = createPointOnObject(obj.id, w.wx, w.wy);
        if (p){
          selected = {id:p.id};
          saveToStorage();
          sceneDirty = true;
          return;
        }
      }

      pushState();
      const p = ensurePointAt(w.wx,w.wy);
      selected = {id:p.id};
      saveToStorage();
      sceneDirty = true;
      return;
    }

    if (tool === "segment"){
      pushState();
      const p = getOrCreatePointForClick(w.wx,w.wy);
      if (!segmentPending){
        segmentPending = p.id;
      } else {
        createSegment(segmentPending, p.id);
        segmentPending = null; // reset: next click starts a new segment
      }
      selected = null;
      saveToStorage();
      sceneDirty = true;
      return;
    }

    if (tool === "line"){
      pushState();
      const p = getOrCreatePointForClick(w.wx,w.wy);
      if (!linePending){
        linePending = p.id;
      } else {
        createLine(linePending, p.id);
        linePending = null;
      }
      selected = null;
      saveToStorage();
      sceneDirty = true;
      return;
    }

    if (tool === "circle"){
      pushState();
      const p = getOrCreatePointForClick(w.wx,w.wy);
      if (!circlePending){
        circlePending = p.id;
      } else {
        createCircle(circlePending, p.id);
        circlePending = null;
      }
      selected = null;
      saveToStorage();
      sceneDirty = true;
      return;
    }

    if (tool === "parabola"){
      // focus point then directrix: (line/segment) or two points
      pushState();

      if (!parabolaPending.focusId){
        const p = getOrCreatePointForClick(w.wx,w.wy);
        parabolaPending.focusId = p.id;
        saveToStorage();
        sceneDirty = true;
        return;
      }

      // second click: try select existing line/segment
      const id = hitTest(w.wx,w.wy);
      const obj = id ? getById(id) : null;
      if (obj && (obj.kind === "line" || obj.kind === "segment")){
        // use its two points as directrix
        createParabola(parabolaPending.focusId, obj.aId, obj.bId);
        parabolaPending = { focusId:null, directrixP1:null, directrixP2:null };
        saveToStorage();
        sceneDirty = true;
        return;
      }

      // else treat as directrix point1/point2
      const p = getOrCreatePointForClick(w.wx,w.wy);
      if (!parabolaPending.directrixP1){
        parabolaPending.directrixP1 = p.id;
      } else {
        parabolaPending.directrixP2 = p.id;
        createParabola(parabolaPending.focusId, parabolaPending.directrixP1, parabolaPending.directrixP2);
        parabolaPending = { focusId:null, directrixP1:null, directrixP2:null };
      }
      saveToStorage();
      sceneDirty = true;
      return;
    }

    if (tool === "ellipse"){
      pushState();
      const p = getOrCreatePointForClick(w.wx,w.wy);
      if (!ellipsePending.f1){
        ellipsePending.f1 = p.id;
      } else if (!ellipsePending.f2){
        ellipsePending.f2 = p.id;
      } else {
        createEllipse(ellipsePending.f1, ellipsePending.f2, p.id);
        ellipsePending = { f1:null, f2:null };
      }
      saveToStorage();
      sceneDirty = true;
      return;
    }

    if (tool === "hyperbola"){
      pushState();
      const p = getOrCreatePointForClick(w.wx,w.wy);
      if (!hyperbolaPending.f1){
        hyperbolaPending.f1 = p.id;
      } else if (!hyperbolaPending.f2){
        hyperbolaPending.f2 = p.id;
      } else {
        createHyperbola(hyperbolaPending.f1, hyperbolaPending.f2, p.id);
        hyperbolaPending = { f1:null, f2:null };
      }
      saveToStorage();
      sceneDirty = true;
      return;
    }

    if (tool === "text"){
      pushState();
      const id = createText(w.wx,w.wy, lang==="ko"?"텍스트":"Text");
      selected = {id};
      saveToStorage();
      sceneDirty = true;
      return;
    }
  });

  sv.addEventListener("pointerup", (e) => {
    isPanning = false;
    panStart = null;
    dragging = null;
    try { sv.releasePointerCapture(e.pointerId); } catch {}
    saveToStorage();
  });

  sv.addEventListener("wheel", (e) => {
    cancelFloatingTip();
    closeToolsMenu();

    const delta = Math.sign(e.deltaY);
    const factor = (delta > 0) ? 0.92 : 1.08;

    const {sx,sy} = clientToSvg(e.clientX, e.clientY);
    const before = screenToWorld(sx, sy);

    pushState();
    cam.scale = clamp(cam.scale * factor, 20, 260);

    const after = screenToWorld(sx, sy);
    cam.x += (before.wx - after.wx);
    cam.y += (before.wy - after.wy);

    camDirty = true;
    saveToStorage();
    sceneDirty = true;
    e.preventDefault();
  }, {passive:false});

  // dblclick: open properties (except text handled in FO)
  sv.addEventListener("dblclick", (e) => {
    cancelFloatingTip();
    closeToolsMenu();
    if (objEditor.style.display === "block" || textEditor.style.display === "block") return;

    const {sx,sy} = clientToSvg(e.clientX, e.clientY);
    const w = screenToWorld(sx, sy);
    const id = hitTest(w.wx,w.wy);
    if (!id) return;

    selected = {id};
    sceneDirty = true;
    openObjEditor({id}, e.clientX, e.clientY);
    e.preventDefault();
  });

  // Enter: open properties for selected (select tool)
  window.addEventListener("keydown", (e) => {
    if (e.key !== "Enter") return;
    if (objEditor.style.display === "block" || textEditor.style.display === "block") return;
    if (tool !== "select") return;
    if (!selected?.id) return;

    openObjEditor({id: selected.id}, lastMouseClient.cx ?? 200, lastMouseClient.cy ?? 120);
    e.preventDefault();
  });

  // =========================
  // Render loop
  // =========================
  function loop(){
    const depChanged = updateDependentPoints();
    if (depChanged) sceneDirty = true;

    const sig = camSignature();
    if (sig !== lastCamSig){
      lastCamSig = sig;
      camDirty = true;
      sceneDirty = true;
    }

    if (camDirty){
      drawGridAxes();
      camDirty = false;
    }
    if (sceneDirty){
      drawObjects();
      sceneDirty = false;
    }

    requestAnimationFrame(loop);
  }

  // =========================
  // init
  // =========================
  ensureLayers();
  resize();
  loadFromStorage();
  normalizeAllPointLabels();
  syncToolUI();
  camDirty = true;
  sceneDirty = true;
  pushState();
  loop();

})();
</script>

</body>
</html>
