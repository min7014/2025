<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Math Tool (Dynamic Intersection Points)</title>
  <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate, max-age=0" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <style>
    html, body { height: 100%; margin: 0; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background: #0b0f14; color: #e6edf3; }

    .topbar {
      position: fixed; top: 12px; left: 12px; right: 12px;
      display: flex; gap: 8px; align-items: center; z-index: 10;
      flex-wrap: wrap;
    }
    .panel {
      background: rgba(20, 26, 34, 0.85);
      border: 1px solid rgba(255,255,255,0.08);
      backdrop-filter: blur(8px);
      border-radius: 12px;
      padding: 10px 12px;
      display: flex; gap: 10px; align-items: center;
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
    }
    button {
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.12);
      color: #e6edf3;
      padding: 8px 10px;
      border-radius: 10px;
      cursor: pointer;
      user-select: none;
      white-space: nowrap;
    }
    button:hover { background: rgba(255,255,255,0.12); }
    button.active {
      background: rgba(120, 200, 255, 0.22);
      border-color: rgba(120, 200, 255, 0.35);
    }
    .readout { opacity: 0.9; font-size: 13px; }
    canvas { display: block; width: 100%; height: 100%; touch-action: none; }

    .footer {
      position: fixed; bottom: 12px; left: 12px;
      background: rgba(20, 26, 34, 0.75);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 12px;
      padding: 10px 12px;
      font-size: 12px;
      opacity: 0.85;
      line-height: 1.35;
      z-index: 10;
      max-width: min(980px, calc(100vw - 24px));
    }
    code { background: rgba(255,255,255,0.08); padding: 2px 6px; border-radius: 8px; }

    .tip {
      position: fixed;
      z-index: 9999;
      display: none;
      background: rgba(20, 26, 34, 0.94);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 12px;
      padding: 10px 12px;
      box-shadow: 0 18px 44px rgba(0,0,0,0.45);
      backdrop-filter: blur(10px);
      max-width: min(520px, calc(100vw - 24px));
      font-size: 13px;
      line-height: 1.35;
      opacity: 0;
      pointer-events: none;
      transform: translateY(-4px);
      transition: opacity 160ms ease, transform 160ms ease;
    }
    .tip.show { display: block; opacity: 1; transform: translateY(0); }
    .tip.hide { opacity: 0; transform: translateY(-6px); }
    .tip b { color: rgba(255, 230, 160, 0.95); }
  </style>
</head>
<body>
  <div class="topbar">
    <div class="panel">
      <button id="toolPoint" class="active" type="button">점 도구</button>
      <button id="toolSegment" type="button">선분 도구</button>
      <button id="toolLine" type="button">직선 도구</button>
      <button id="toolSelect" type="button">선택/이동 도구</button>
      <span class="readout" id="readout"></span>
    </div>

    <div class="panel">
      <button id="btnUndoPoint" type="button">점 되돌리기</button>
      <button id="btnUndoSeg" type="button">선분 되돌리기</button>
      <button id="btnUndoLine" type="button">직선 되돌리기</button>
      <button id="btnClearAll" type="button">전체 삭제</button>
      <button id="btnCancelFirst" type="button">2점 도구 1점 취소</button>
    </div>
  </div>

  <canvas id="c"></canvas>

  <div class="footer">
    ✅ 데이터는 브라우저(localStorage)에만 저장(서버 저장 0)<br/>
    선분/직선: (1-2), (3-4), (5-6)… <b>2점씩 짝지어</b> 생성<br/>
    ⭐ 점 도구: <b>교점 근처 클릭</b> → “동적 교점(종속점)” 생성(직선-직선/선분-선분/직선-선분)<br/>
    ⛔ 종속점(교점)은 직접 드래그로 이동 불가(부모 선/선분을 움직이면 같이 이동)<br/>
    단축키: <code>P</code>=점, <code>S</code>=선분, <code>L</code>=직선, <code>V</code>=선택, <code>ESC</code>=1점 취소
  </div>

  <div id="tip" class="tip" aria-live="polite"></div>

<script>
(() => {
  // =========================
  // 0) 자동 찌꺼기 삭제 정책
  // =========================
  const BUILD_ID = "2026-01-06-build-04-dynamic-intersection";
  const BUILD_KEY = "mathlab_build_id";

  function purgeOldLocalStorageIfNeeded() {
    try {
      const prev = localStorage.getItem(BUILD_KEY);
      if (prev === BUILD_ID) return false;

      const keysToDelete = [];
      for (let i = 0; i < localStorage.length; i++) {
        const k = localStorage.key(i);
        if (!k) continue;
        if (k.startsWith("mathlab_state_") || k.startsWith("mathlab_")) keysToDelete.push(k);
      }
      for (const k of keysToDelete) localStorage.removeItem(k);

      localStorage.setItem(BUILD_KEY, BUILD_ID);
      return true;
    } catch { return false; }
  }
  const didPurge = purgeOldLocalStorageIfNeeded();

  // -------------------------
  // Element refs (방어)
  // -------------------------
  const canvas = document.getElementById('c');
  const ctx = canvas?.getContext?.('2d');
  const readout = document.getElementById('readout');
  const tipEl = document.getElementById('tip');

  const toolPointBtn = document.getElementById('toolPoint');
  const toolSegmentBtn = document.getElementById('toolSegment');
  const toolLineBtn = document.getElementById('toolLine');
  const toolSelectBtn = document.getElementById('toolSelect');

  const btnUndoPoint = document.getElementById('btnUndoPoint');
  const btnUndoSeg   = document.getElementById('btnUndoSeg');
  const btnUndoLine  = document.getElementById('btnUndoLine');
  const btnClearAll  = document.getElementById('btnClearAll');
  const btnCancelFirst = document.getElementById('btnCancelFirst');

  if (!canvas || !ctx || !readout || !tipEl ||
      !toolPointBtn || !toolSegmentBtn || !toolLineBtn || !toolSelectBtn ||
      !btnUndoPoint || !btnUndoSeg || !btnUndoLine || !btnClearAll || !btnCancelFirst) {
    alert('UI 요소 로딩에 실패했습니다. HTML이 손상되었는지 확인해 주세요.');
    return;
  }

  // -------------------------
  // Tooltip
  // -------------------------
  let tipTimer = null;
  let tipHideTimer = null;

  function hideTip() {
    tipEl.classList.remove('show');
    tipEl.classList.add('hide');
    if (tipHideTimer) clearTimeout(tipHideTimer);
    tipHideTimer = setTimeout(() => {
      if (tipEl.classList.contains('hide')) tipEl.style.display = 'none';
    }, 200);
  }
  function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }
  function positionTip(anchorEl) {
    const padding = 10, gap = 10;
    const tw = Math.max(1, tipEl.offsetWidth);
    const th = Math.max(1, tipEl.offsetHeight);

    if (!anchorEl || !anchorEl.getBoundingClientRect) {
      const left = Math.round((window.innerWidth - tw) / 2);
      const top = 72;
      tipEl.style.left = `${clamp(left, padding, window.innerWidth - padding - tw)}px`;
      tipEl.style.top  = `${clamp(top,  padding, window.innerHeight - padding - th)}px`;
      return;
    }

    const r = anchorEl.getBoundingClientRect();
    let left = r.right + gap;
    let top  = r.top + (r.height - th) / 2;

    if (left + tw > window.innerWidth - padding) left = r.left - gap - tw;
    left = clamp(left, padding, window.innerWidth - padding - tw);
    top  = clamp(top,  padding, window.innerHeight - padding - th);

    tipEl.style.left = `${Math.round(left)}px`;
    tipEl.style.top  = `${Math.round(top)}px`;
  }
  function showTip(html, anchorEl=null, ms=1600) {
    if (tipTimer) clearTimeout(tipTimer);
    tipEl.innerHTML = html;
    tipEl.style.display = 'block';
    tipEl.classList.remove('hide');
    tipEl.classList.add('show');
    requestAnimationFrame(() => positionTip(anchorEl));
    tipTimer = setTimeout(hideTip, ms);
  }
  window.addEventListener('resize', hideTip);
  window.addEventListener('scroll', hideTip, true);

  // =========================
  // State
  // =========================
  const STORAGE_KEY = 'mathlab_state_safe_v5_dynamic_intersections';

  function sanitizeNumber(x, fallback=0) {
    const n = Number(x);
    return Number.isFinite(n) ? n : fallback;
  }

  function sanitizeState(obj) {
    const safe = { points: [], segments: [], lines: [] };
    if (!obj || typeof obj !== 'object') return safe;

    const pts = Array.isArray(obj.points) ? obj.points : [];
    const segs = Array.isArray(obj.segments) ? obj.segments : [];
    const lns = Array.isArray(obj.lines) ? obj.lines : [];

    for (const p of pts) {
      if (!p || typeof p !== 'object') continue;
      if (typeof p.id !== 'string' || !p.id) continue;

      const kind = (typeof p.kind === 'string' ? p.kind : 'free');

      if (kind === 'free') {
        safe.points.push({ id: p.id, kind: 'free', x: sanitizeNumber(p.x, 0), y: sanitizeNumber(p.y, 0) });
      } else if (kind === 'intersection') {
        const ak = p.a_kind, bk = p.b_kind;
        if (!((ak === 'line' || ak === 'segment') && (bk === 'line' || bk === 'segment'))) continue;
        if (typeof p.a_id !== 'string' || typeof p.b_id !== 'string') continue;
        safe.points.push({ id: p.id, kind: 'intersection', a_kind: ak, a_id: p.a_id, b_kind: bk, b_id: p.b_id });
      }
    }

    const ids = new Set(safe.points.map(p => p.id));

    for (const s of segs) {
      if (!s || typeof s !== 'object') continue;
      if (typeof s.id !== 'string' || !s.id) continue;
      if (typeof s.a_id !== 'string' || typeof s.b_id !== 'string') continue;
      if (!ids.has(s.a_id) || !ids.has(s.b_id) || s.a_id === s.b_id) continue;
      safe.segments.push({ id: s.id, a_id: s.a_id, b_id: s.b_id });
    }

    for (const l of lns) {
      if (!l || typeof l !== 'object') continue;
      if (typeof l.id !== 'string' || !l.id) continue;
      if (typeof l.a_id !== 'string' || typeof l.b_id !== 'string') continue;
      if (!ids.has(l.a_id) || !ids.has(l.b_id) || l.a_id === l.b_id) continue;
      safe.lines.push({ id: l.id, a_id: l.a_id, b_id: l.b_id });
    }

    return safe;
  }

  function loadState() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return { points: [], segments: [], lines: [] };
      return sanitizeState(JSON.parse(raw));
    } catch {
      return { points: [], segments: [], lines: [] };
    }
  }

  function saveState() {
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify({ points, segments, lines }));
    } catch {
      showTip('저장에 실패했습니다(브라우저 설정/용량). 그래도 작업은 계속됩니다.', null, 1600);
    }
  }

  // View
  let scale = 40;
  let origin = { x: 0, y: 0 };

  let { points, segments, lines } = loadState();

  let tool = 'point';
  let selectedId = null;

  // 2점 도구(선분/직선)
  let firstId = null;
  let mouseWorld = { x: 0, y: 0 };

  // Drag
  let dragging = false;
  let dragPointerId = null;
  let dragOffset = { x: 0, y: 0 };

  const HIT_RADIUS_PX = 10;
  const INTERSECTION_HIT_PX = 12;

  // =========================
  // Geometry core
  // =========================
  const EPS = 1e-12;

  function cross(ax, ay, bx, by) { return ax * by - ay * bx; }

  // p + t r, q + u s
  function intersectParams(px, py, rx, ry, qx, qy, sx, sy) {
    const denom = cross(rx, ry, sx, sy);
    if (Math.abs(denom) < EPS) return null; // 평행 or 일치(겹침)
    const qmpx = qx - px, qmpy = qy - py;
    const t = cross(qmpx, qmpy, sx, sy) / denom;
    const u = cross(qmpx, qmpy, rx, ry) / denom;
    return { t, u, x: px + t * rx, y: py + t * ry };
  }

  function uid(prefix='') {
    return prefix + Date.now().toString(36) + '-' + Math.random().toString(36).slice(2, 8);
  }

  function findPointObj(pid) { return points.find(p => p.id === pid) || null; }
  function findSegObj(sid) { return segments.find(s => s.id === sid) || null; }
  function findLineObj(lid) { return lines.find(l => l.id === lid) || null; }

  function worldToScreen(wx, wy) { return { x: origin.x + wx * scale, y: origin.y - wy * scale }; }
  function screenToWorld(sx, sy) { return { x: (sx - origin.x) / scale, y: (origin.y - sy) / scale }; }

  // ---- 평가(재귀) : 자유점/종속점 모두 좌표를 얻는다. (사이클 방어 포함) ----
  function evalPoint(pid, cache, stack) {
    if (cache.has(pid)) return cache.get(pid);
    if (stack.has(pid)) { cache.set(pid, null); return null; } // 사이클 방어
    stack.add(pid);

    const p = findPointObj(pid);
    if (!p) { cache.set(pid, null); stack.delete(pid); return null; }

    let res = null;

    if (!p.kind || p.kind === 'free') {
      res = { x: p.x, y: p.y };
    } else if (p.kind === 'intersection') {
      const A = evalPrimitiveEndpoints(p.a_kind, p.a_id, cache, stack);
      const B = evalPrimitiveEndpoints(p.b_kind, p.b_id, cache, stack);
      if (A && B) {
        const rx = A.bx - A.ax, ry = A.by - A.ay;
        const sx = B.bx - B.ax, sy = B.by - B.ay;
        const ip = intersectParams(A.ax, A.ay, rx, ry, B.ax, B.ay, sx, sy);
        if (ip) {
          const tol = 1e-9;
          if (p.a_kind === 'segment' && (ip.t < -tol || ip.t > 1 + tol)) {
            res = null;
          } else if (p.b_kind === 'segment' && (ip.u < -tol || ip.u > 1 + tol)) {
            res = null;
          } else {
            res = { x: ip.x, y: ip.y };
          }
        }
      }
    }

    cache.set(pid, res);
    stack.delete(pid);
    return res;
  }

  function evalPrimitiveEndpoints(kind, id, cache, stack) {
    const obj = (kind === 'line') ? findLineObj(id) : findSegObj(id);
    if (!obj) return null;
    const a = evalPoint(obj.a_id, cache, stack);
    const b = evalPoint(obj.b_id, cache, stack);
    if (!a || !b) return null;
    if (Math.abs(a.x - b.x) < EPS && Math.abs(a.y - b.y) < EPS) return null;
    return { ax: a.x, ay: a.y, bx: b.x, by: b.y };
  }

  // -------------------------
  // Cleanup: 존재하지 않는 primitive를 참조하는 종속점은 제거
  // (단, 평행/교점없음 등 "일시적 invalid"는 유지 -> 나중에 움직이면 다시 나타남)
  // -------------------------
  function cleanupReferences() {
    const pointIds = new Set(points.map(p => p.id));
    segments = segments.filter(s => pointIds.has(s.a_id) && pointIds.has(s.b_id) && s.a_id !== s.b_id);
    lines = lines.filter(l => pointIds.has(l.a_id) && pointIds.has(l.b_id) && l.a_id !== l.b_id);

    const segIds = new Set(segments.map(s => s.id));
    const lineIds = new Set(lines.map(l => l.id));

    points = points.filter(p => {
      if (!p.kind || p.kind === 'free') return true;
      if (p.kind === 'intersection') {
        const okA = (p.a_kind === 'segment') ? segIds.has(p.a_id) : lineIds.has(p.a_id);
        const okB = (p.b_kind === 'segment') ? segIds.has(p.b_id) : lineIds.has(p.b_id);
        return okA && okB;
      }
      return true;
    });
  }

  // =========================
  // Intersection candidates (클릭 시 종속점 생성용)
  // =========================
  function buildIntersectionCandidates(cache, stack) {
    const cands = [];
    const tol = 1e-9;

    // line-line
    for (let i = 0; i < lines.length; i++) {
      const A = evalPrimitiveEndpoints('line', lines[i].id, cache, stack);
      if (!A) continue;
      for (let j = i + 1; j < lines.length; j++) {
        const B = evalPrimitiveEndpoints('line', lines[j].id, cache, stack);
        if (!B) continue;

        const rx = A.bx - A.ax, ry = A.by - A.ay;
        const sx = B.bx - B.ax, sy = B.by - B.ay;
        const ip = intersectParams(A.ax, A.ay, rx, ry, B.ax, B.ay, sx, sy);
        if (!ip) continue;

        cands.push({ x: ip.x, y: ip.y, a_kind: 'line', a_id: lines[i].id, b_kind: 'line', b_id: lines[j].id });
      }
    }

    // seg-seg
    for (let i = 0; i < segments.length; i++) {
      const A = evalPrimitiveEndpoints('segment', segments[i].id, cache, stack);
      if (!A) continue;
      for (let j = i + 1; j < segments.length; j++) {
        const B = evalPrimitiveEndpoints('segment', segments[j].id, cache, stack);
        if (!B) continue;

        const rx = A.bx - A.ax, ry = A.by - A.ay;
        const sx = B.bx - B.ax, sy = B.by - B.ay;
        const ip = intersectParams(A.ax, A.ay, rx, ry, B.ax, B.ay, sx, sy);
        if (!ip) continue;

        if (ip.t < -tol || ip.t > 1 + tol) continue;
        if (ip.u < -tol || ip.u > 1 + tol) continue;

        cands.push({ x: ip.x, y: ip.y, a_kind: 'segment', a_id: segments[i].id, b_kind: 'segment', b_id: segments[j].id });
      }
    }

    // line-seg
    for (let i = 0; i < lines.length; i++) {
      const A = evalPrimitiveEndpoints('line', lines[i].id, cache, stack);
      if (!A) continue;
      for (let j = 0; j < segments.length; j++) {
        const B = evalPrimitiveEndpoints('segment', segments[j].id, cache, stack);
        if (!B) continue;

        const rx = A.bx - A.ax, ry = A.by - A.ay;
        const sx = B.bx - B.ax, sy = B.by - B.ay;
        const ip = intersectParams(A.ax, A.ay, rx, ry, B.ax, B.ay, sx, sy);
        if (!ip) continue;

        if (ip.u < -tol || ip.u > 1 + tol) continue; // seg 범위만 체크

        cands.push({ x: ip.x, y: ip.y, a_kind: 'line', a_id: lines[i].id, b_kind: 'segment', b_id: segments[j].id });
      }
    }

    // 위치 중복 완화(너무 겹치면 후보가 과도하게 늘어나는 것 방지)
    const out = [];
    const eps2 = 1e-10;
    for (const p of cands) {
      let ok = true;
      for (const q of out) {
        const dx = p.x - q.x, dy = p.y - q.y;
        if (dx*dx + dy*dy < eps2) { ok = false; break; }
      }
      if (ok) out.push(p);
    }
    return out;
  }

  function pairKey(a_kind, a_id, b_kind, b_id) {
    const A = `${a_kind}:${a_id}`;
    const B = `${b_kind}:${b_id}`;
    return (A < B) ? `${A}|${B}` : `${B}|${A}`;
  }

  function hasIntersectionPoint(a_kind, a_id, b_kind, b_id) {
    const key = pairKey(a_kind, a_id, b_kind, b_id);
    return points.some(p => p.kind === 'intersection' && pairKey(p.a_kind, p.a_id, p.b_kind, p.b_id) === key);
  }

  function findNearestIntersectionToScreen(sx, sy) {
    const cache = new Map();
    const stack = new Set();
    const cands = buildIntersectionCandidates(cache, stack);

    let best = null;
    let bestD2 = Infinity;

    for (const c of cands) {
      const sc = worldToScreen(c.x, c.y);
      const dx = sc.x - sx, dy = sc.y - sy;
      const d2 = dx*dx + dy*dy;
      if (d2 < bestD2) { bestD2 = d2; best = c; }
    }
    if (!best) return null;
    return { ...best, d2px: bestD2 };
  }

  // =========================
  // Hit test (free + intersection)
  // =========================
  function hitTestPoint(sx, sy) {
    const cache = new Map();
    const stack = new Set();

    let best = null;
    let bestDist2 = Infinity;

    for (const p of points) {
      const w = evalPoint(p.id, cache, stack);
      if (!w) continue; // 현재 교점이 존재하지 않으면 숨김
      const s = worldToScreen(w.x, w.y);
      const dx = s.x - sx, dy = s.y - sy;
      const d2 = dx*dx + dy*dy;
      if (d2 < bestDist2) { bestDist2 = d2; best = p; }
    }

    if (best && bestDist2 <= HIT_RADIUS_PX * HIT_RADIUS_PX) {
      return { point: best, dist2: bestDist2 };
    }
    return null;
  }

  // =========================
  // Tools / mutations
  // =========================
  function setTool(nextTool, anchorBtn=null) {
    tool = nextTool;

    toolPointBtn.classList.toggle('active', tool === 'point');
    toolSegmentBtn.classList.toggle('active', tool === 'segment');
    toolLineBtn.classList.toggle('active', tool === 'line');
    toolSelectBtn.classList.toggle('active', tool === 'select');

    dragging = false;
    dragPointerId = null;

    if (tool === 'point') {
      selectedId = null; firstId = null;
      showTip('<b>점 도구</b>: 클릭하면 점 생성<br/>⭐ 교점 근처 클릭 → <b>동적 교점(종속점)</b> 생성', anchorBtn || toolPointBtn);
    } else if (tool === 'segment') {
      selectedId = null; firstId = null;
      showTip('<b>선분 도구</b>: 첫 점 → 둘째 점 선택/생성하면 선분 생성', anchorBtn || toolSegmentBtn);
    } else if (tool === 'line') {
      selectedId = null; firstId = null;
      showTip('<b>직선 도구</b>: 첫 점 → 둘째 점 선택/생성하면 무한 직선 생성', anchorBtn || toolLineBtn);
    } else {
      firstId = null;
      showTip('<b>선택/이동</b>: 자유점만 드래그로 이동 가능(교점=종속점은 이동 불가)', anchorBtn || toolSelectBtn);
    }
    draw();
  }

  function cancelFirstPoint(anchorBtn=null) {
    if (!(tool === 'segment' || tool === 'line')) {
      showTip('선분/직선 도구에서만 사용할 수 있습니다.', anchorBtn || btnCancelFirst, 1200);
      return;
    }
    if (firstId) showTip('2점 도구: <b>첫 점 선택</b>을 취소했습니다.', anchorBtn || btnCancelFirst, 1200);
    firstId = null;
    draw();
  }

  function addFreePoint(wx, wy) {
    const p = { id: uid('p-'), kind: 'free', x: wx, y: wy };
    points.push(p);
    cleanupReferences();
    saveState();
    draw();
    return p.id;
  }

  function addIntersectionPoint(a_kind, a_id, b_kind, b_id) {
    const p = { id: uid('i-'), kind: 'intersection', a_kind, a_id, b_kind, b_id };
    points.push(p);
    cleanupReferences();
    saveState();
    draw();
    return p.id;
  }

  function updateFreePoint(pid, wx, wy) {
    const idx = points.findIndex(p => p.id === pid);
    if (idx < 0) return;
    if (points[idx].kind === 'intersection') return; // 종속점은 이동 불가
    points[idx].x = wx;
    points[idx].y = wy;
    cleanupReferences();
    saveState();
    draw();
  }

  function addSegment(a_id, b_id) {
    if (a_id === b_id) return;
    segments.push({ id: uid('s-'), a_id, b_id });
    cleanupReferences();
    saveState();
    draw();
  }

  function addLine(a_id, b_id) {
    if (a_id === b_id) return;
    lines.push({ id: uid('l-'), a_id, b_id });
    cleanupReferences();
    saveState();
    draw();
  }

  function undoPoint() {
    if (!points.length) { showTip('되돌릴 점이 없습니다.', btnUndoPoint, 900); return; }
    const removed = points.pop();

    segments = segments.filter(s => s.a_id !== removed.id && s.b_id !== removed.id);
    lines = lines.filter(l => l.a_id !== removed.id && l.b_id !== removed.id);

    if (selectedId === removed.id) selectedId = null;
    if (firstId === removed.id) firstId = null;

    cleanupReferences();
    saveState();
    draw();
    showTip('점 되돌리기 완료', btnUndoPoint, 900);
  }

  function undoSegment() {
    if (!segments.length) { showTip('되돌릴 선분이 없습니다.', btnUndoSeg, 900); return; }
    segments.pop();
    cleanupReferences();
    saveState();
    draw();
    showTip('선분 되돌리기 완료', btnUndoSeg, 900);
  }

  function undoLine() {
    if (!lines.length) { showTip('되돌릴 직선이 없습니다.', btnUndoLine, 900); return; }
    lines.pop();
    cleanupReferences();
    saveState();
    draw();
    showTip('직선 되돌리기 완료', btnUndoLine, 900);
  }

  function clearAll() {
    points = []; segments = []; lines = [];
    selectedId = null; firstId = null;
    saveState();
    draw();
    showTip('전체 삭제 완료', btnClearAll, 900);
  }

  // =========================
  // Drawing
  // =========================
  function resize() {
    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.floor(window.innerWidth * dpr);
    canvas.height = Math.floor(window.innerHeight * dpr);
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    origin.x = window.innerWidth / 2;
    origin.y = window.innerHeight / 2;
    draw();
  }

  function drawGrid() {
    const w = window.innerWidth, h = window.innerHeight;
    ctx.fillStyle = '#0b0f14';
    ctx.fillRect(0, 0, w, h);

    const minor = scale, major = scale * 5;

    function drawLines(step, alpha) {
      ctx.strokeStyle = `rgba(230, 237, 243, ${alpha})`;
      ctx.lineWidth = 1;

      let x0 = origin.x % step;
      for (let x = x0; x <= w; x += step) {
        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke();
      }
      let y0 = origin.y % step;
      for (let y = y0; y <= h; y += step) {
        ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke();
      }
    }

    drawLines(minor, 0.06);
    drawLines(major, 0.12);

    ctx.strokeStyle = 'rgba(230, 237, 243, 0.55)';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(0, origin.y); ctx.lineTo(w, origin.y); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(origin.x, 0); ctx.lineTo(origin.x, h); ctx.stroke();

    ctx.fillStyle = 'rgba(230, 237, 243, 0.75)';
    ctx.font = '12px system-ui';
    ctx.fillText('x', w - 18, origin.y - 10);
    ctx.fillText('y', origin.x + 10, 16);

    ctx.fillStyle = 'rgba(230, 237, 243, 0.85)';
    ctx.fillText('0', origin.x + 6, origin.y + 14);
  }

  function getWorldBounds() {
    const w = window.innerWidth, h = window.innerHeight;
    const tl = screenToWorld(0, 0);
    const br = screenToWorld(w, h);
    return {
      xmin: Math.min(tl.x, br.x),
      xmax: Math.max(tl.x, br.x),
      ymin: Math.min(tl.y, br.y),
      ymax: Math.max(tl.y, br.y),
    };
  }

  function clipInfiniteLineToWorldRect(ax, ay, bx, by, rect) {
    const dx = bx - ax;
    const dy = by - ay;
    const pts = [];

    function addIfValid(x, y, t) {
      if (x < rect.xmin - 1e-9 || x > rect.xmax + 1e-9) return;
      if (y < rect.ymin - 1e-9 || y > rect.ymax + 1e-9) return;
      pts.push({ x, y, t });
    }

    if (Math.abs(dx) > 1e-12) {
      let t = (rect.xmin - ax) / dx;
      addIfValid(rect.xmin, ay + t * dy, t);
      t = (rect.xmax - ax) / dx;
      addIfValid(rect.xmax, ay + t * dy, t);
    }

    if (Math.abs(dy) > 1e-12) {
      let t = (rect.ymin - ay) / dy;
      addIfValid(ax + t * dx, rect.ymin, t);
      t = (rect.ymax - ay) / dy;
      addIfValid(ax + t * dx, rect.ymax, t);
    }

    const uniq = [];
    for (const p of pts) {
      const hit = uniq.find(q => (p.x - q.x)**2 + (p.y - q.y)**2 < 1e-10);
      if (!hit) uniq.push(p);
    }
    if (uniq.length < 2) return null;

    uniq.sort((p, q) => p.t - q.t);
    return { p1: uniq[0], p2: uniq[uniq.length - 1] };
  }

  function drawLinesInfinite() {
    const rect = getWorldBounds();
    const cache = new Map();
    const stack = new Set();

    ctx.lineWidth = 2.5;
    ctx.strokeStyle = 'rgba(255, 190, 120, 0.65)';

    for (const ln of lines) {
      const A = evalPrimitiveEndpoints('line', ln.id, cache, stack);
      if (!A) continue;

      const clipped = clipInfiniteLineToWorldRect(A.ax, A.ay, A.bx, A.by, rect);
      if (!clipped) continue;

      const s1 = worldToScreen(clipped.p1.x, clipped.p1.y);
      const s2 = worldToScreen(clipped.p2.x, clipped.p2.y);

      ctx.beginPath(); ctx.moveTo(s1.x, s1.y); ctx.lineTo(s2.x, s2.y); ctx.stroke();
    }
  }

  function drawSegments() {
    const cache = new Map();
    const stack = new Set();

    ctx.lineWidth = 3;
    ctx.strokeStyle = 'rgba(180, 220, 255, 0.75)';

    for (const seg of segments) {
      const A = evalPrimitiveEndpoints('segment', seg.id, cache, stack);
      if (!A) continue;
      const sa = worldToScreen(A.ax, A.ay);
      const sb = worldToScreen(A.bx, A.by);
      ctx.beginPath(); ctx.moveTo(sa.x, sa.y); ctx.lineTo(sb.x, sb.y); ctx.stroke();
    }
  }

  function drawTwoPointPreview() {
    if (!((tool === 'segment' || tool === 'line') && firstId)) return;

    const cache = new Map();
    const stack = new Set();
    const a = evalPoint(firstId, cache, stack);
    if (!a) return;

    const sa = worldToScreen(a.x, a.y);
    const sb = worldToScreen(mouseWorld.x, mouseWorld.y);

    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.35)';
    ctx.setLineDash([6, 6]);
    ctx.beginPath(); ctx.moveTo(sa.x, sa.y); ctx.lineTo(sb.x, sb.y); ctx.stroke();
    ctx.setLineDash([]);
  }

  function drawPoints() {
    const cache = new Map();
    const stack = new Set();

    for (const p of points) {
      const w = evalPoint(p.id, cache, stack);
      if (!w) continue;

      const s = worldToScreen(w.x, w.y);
      const isSelected = (p.id === selectedId);
      const isFirst = ((tool === 'segment' || tool === 'line') && p.id === firstId);
      const isIntersection = (p.kind === 'intersection');

      let radius = 5;
      if (isSelected) radius = 7;
      if (isFirst) radius = 8;
      if (isIntersection) radius = Math.max(radius, 6);

      ctx.beginPath();
      ctx.arc(s.x, s.y, radius, 0, Math.PI * 2);

      // 교점은 색을 살짝 다르게(종속점 표시)
      ctx.fillStyle =
        isSelected ? 'rgba(255, 220, 120, 0.95)' :
        isFirst ? 'rgba(255, 200, 120, 0.85)' :
        isIntersection ? 'rgba(120, 255, 180, 0.92)' :
        'rgba(120, 200, 255, 0.95)';
      ctx.fill();

      ctx.lineWidth = 2;
      ctx.strokeStyle = isSelected ? 'rgba(255, 255, 255, 0.55)' : 'rgba(255, 255, 255, 0.35)';
      ctx.stroke();

      const tag = isIntersection ? 'I' : '';
      const label = `${tag}(${w.x.toFixed(2)}, ${w.y.toFixed(2)})`;
      ctx.font = '12px system-ui';
      ctx.fillStyle = 'rgba(230, 237, 243, 0.85)';
      ctx.fillText(label, s.x + 10, s.y - 10);
    }
  }

  function draw() {
    drawGrid();
    drawLinesInfinite();
    drawSegments();
    drawTwoPointPreview();
    drawPoints();
  }

  // =========================
  // Events
  // =========================
  function getCanvasLocalXY(e) {
    const rect = canvas.getBoundingClientRect();
    return { sx: e.clientX - rect.left, sy: e.clientY - rect.top };
  }

  canvas.addEventListener('pointermove', (e) => {
    const { sx, sy } = getCanvasLocalXY(e);
    const w = screenToWorld(sx, sy);
    mouseWorld = w;
    readout.textContent = `마우스: (${w.x.toFixed(2)}, ${w.y.toFixed(2)})`;
    if ((tool === 'segment' || tool === 'line') && firstId) draw();
  });

  canvas.addEventListener('click', (e) => {
    const { sx, sy } = getCanvasLocalXY(e);

    // 점 도구: 교점이면 "종속점"으로 생성
    if (tool === 'point') {
      // 이미 점이 있으면 중복 방지
      const hit = hitTestPoint(sx, sy);
      if (hit) { showTip('이미 점이 있습니다.', toolPointBtn, 900); return; }

      const nearest = findNearestIntersectionToScreen(sx, sy);
      if (nearest && nearest.d2px <= INTERSECTION_HIT_PX * INTERSECTION_HIT_PX) {
        if (!hasIntersectionPoint(nearest.a_kind, nearest.a_id, nearest.b_kind, nearest.b_id)) {
          addIntersectionPoint(nearest.a_kind, nearest.a_id, nearest.b_kind, nearest.b_id);
          showTip('⭐ 동적 교점(종속점) 생성 완료', toolPointBtn, 1100);
        } else {
          showTip('이미 같은 교점(종속점)이 있습니다.', toolPointBtn, 1100);
        }
        return;
      }

      // 일반 자유점 생성
      const w = screenToWorld(sx, sy);
      addFreePoint(w.x, w.y);
      return;
    }

    // 2점 도구(선분/직선)
    if (tool === 'segment' || tool === 'line') {
      const hit = hitTestPoint(sx, sy);
      const w = screenToWorld(sx, sy);
      const pid = hit ? hit.point.id : addFreePoint(w.x, w.y);

      if (!firstId) {
        firstId = pid;
        showTip('2점 도구: <b>첫 점</b> 선택됨 → 둘째 점을 선택하세요.',
          tool === 'segment' ? toolSegmentBtn : toolLineBtn, 1400);
        draw();
        return;
      }

      if (firstId === pid) {
        firstId = null;
        showTip('2점 도구: 첫 점 선택을 <b>취소</b>했습니다.',
          tool === 'segment' ? toolSegmentBtn : toolLineBtn, 1200);
        draw();
        return;
      }

      if (tool === 'segment') {
        addSegment(firstId, pid);
        showTip('선분 생성 완료. 다음은 다시 <b>첫 점</b>부터.', toolSegmentBtn, 1400);
      } else {
        addLine(firstId, pid);
        showTip('직선 생성 완료. 다음은 다시 <b>첫 점</b>부터.', toolLineBtn, 1400);
      }
      firstId = null;
      draw();
      return;
    }
  });

  // Select tool drag (자유점만 이동)
  canvas.addEventListener('pointerdown', (e) => {
    if (tool !== 'select') return;

    const { sx, sy } = getCanvasLocalXY(e);
    const hit = hitTestPoint(sx, sy);

    if (!hit) { selectedId = null; draw(); return; }

    const p = hit.point;
    selectedId = p.id;

    if (p.kind === 'intersection') {
      showTip('⛔ 교점은 <b>종속점</b>이라 직접 이동할 수 없습니다.<br/>부모 선/선분의 점을 이동해 주세요.', toolSelectBtn, 1700);
      draw();
      return;
    }

    dragging = true;
    dragPointerId = e.pointerId;

    const w = screenToWorld(sx, sy);
    dragOffset.x = w.x - p.x;
    dragOffset.y = w.y - p.y;

    try { canvas.setPointerCapture(e.pointerId); } catch {}
    showTip('자유점 선택됨. 드래그해서 이동하세요.', toolSelectBtn, 1100);
    draw();
  });

  canvas.addEventListener('pointermove', (e) => {
    if (tool !== 'select' || !dragging || e.pointerId !== dragPointerId || !selectedId) return;

    const pobj = findPointObj(selectedId);
    if (!pobj || pobj.kind === 'intersection') return;

    const { sx, sy } = getCanvasLocalXY(e);
    const w = screenToWorld(sx, sy);

    pobj.x = w.x - dragOffset.x;
    pobj.y = w.y - dragOffset.y;
    draw();
  });

  function endDrag(e) {
    if (tool !== 'select' || !dragging || e.pointerId !== dragPointerId) return;

    dragging = false;
    try { canvas.releasePointerCapture(e.pointerId); } catch {}
    dragPointerId = null;

    if (!selectedId) return;
    const p = findPointObj(selectedId);
    if (!p || p.kind === 'intersection') return;

    updateFreePoint(selectedId, p.x, p.y);
    showTip('이동 저장됨', toolSelectBtn, 900);
  }
  canvas.addEventListener('pointerup', endDrag);
  canvas.addEventListener('pointercancel', endDrag);

  // Buttons
  toolPointBtn.addEventListener('click', () => setTool('point', toolPointBtn));
  toolSegmentBtn.addEventListener('click', () => setTool('segment', toolSegmentBtn));
  toolLineBtn.addEventListener('click', () => setTool('line', toolLineBtn));
  toolSelectBtn.addEventListener('click', () => setTool('select', toolSelectBtn));

  btnUndoPoint.addEventListener('click', undoPoint);
  btnUndoSeg.addEventListener('click', undoSegment);
  btnUndoLine.addEventListener('click', undoLine);
  btnClearAll.addEventListener('click', clearAll);
  btnCancelFirst.addEventListener('click', () => cancelFirstPoint(btnCancelFirst));

  // Shortcuts
  window.addEventListener('keydown', (e) => {
    const k = e.key.toLowerCase();
    if (k === 'p') setTool('point', null);
    if (k === 's') setTool('segment', null);
    if (k === 'l') setTool('line', null);
    if (k === 'v') setTool('select', null);
    if (k === 'escape') cancelFirstPoint(null);
  });

  window.addEventListener('resize', resize);

  // init
  cleanupReferences();
  saveState();
  resize();
  draw();

  if (didPurge) {
    showTip('이전 저장 찌꺼기를 <b>자동 삭제</b>하고 새 버전으로 시작합니다.', null, 1800);
  } else {
    showTip('점 도구에서 교점 근처 클릭하면 <b>동적 교점(종속점)</b>이 생성됩니다.', null, 1800);
  }
})();
</script>
</body>
</html>
