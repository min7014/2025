<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>mathlab</title>

  <!-- KaTeX (LaTeX 렌더링). 오프라인이면 로드 실패할 수 있으며, 그 경우 일반 텍스트로 표시됩니다. -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>

  <style>
    :root{
      --bg:#0b1220;
      --panel:#0f182b;
      --stroke:#c7d2fe;
      --muted:#93a4c7;
      --text:#e8eefc;
      --accent:#7c5cff;
      --danger:#ff5a6a;
      --shadow: 0 14px 40px rgba(0,0,0,.35);
      --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    html,body{height:100%; margin:0; background:var(--bg); color:var(--text); font-family:var(--font);}
    #app{height:100%; display:flex; flex-direction:column;}

    #topbar{
      display:flex; gap:10px; align-items:center; justify-content:space-between;
      padding:10px 12px; background:rgba(15,24,43,.96); border-bottom:1px solid rgba(199,210,254,.12);
      position:sticky; top:0; z-index:50;
    }
    .group{display:flex; gap:8px; align-items:center; flex-wrap:wrap;}
    .sep{width:1px; height:26px; background:rgba(199,210,254,.14); margin:0 4px;}

    .btn{
      appearance:none; border:1px solid rgba(199,210,254,.18);
      background:rgba(255,255,255,.04);
      color:var(--text);
      padding:8px 10px; border-radius:12px;
      font-size:13px; line-height:1; cursor:pointer;
      transition:transform .05s ease, background .12s ease, border-color .12s ease;
      user-select:none;
    }
    .btn:hover{ background:rgba(255,255,255,.07); border-color:rgba(199,210,254,.28); }
    .btn:active{ transform:translateY(1px); }
    .btn.active{ background:rgba(124,92,255,.18); border-color:rgba(124,92,255,.55); }
    .btn.danger{ background:rgba(255,90,106,.12); border-color:rgba(255,90,106,.35); }

    .dropdown{ position:relative; }
    .dropdownMenu{
      position:absolute; top:calc(100% + 8px); left:0;
      display:none; flex-direction:column; gap:6px;
      background:rgba(15,24,43,.98);
      border:1px solid rgba(199,210,254,.16);
      border-radius:14px;
      padding:10px;
      box-shadow: var(--shadow);
      min-width: 170px;
      z-index:60;
    }
    .dropdown.open .dropdownMenu{ display:flex; }

    #hint{ font-size:12px; color:var(--muted); white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:42vw; }

    #work{
      position:relative;
      flex:1;
      overflow:hidden;
      background: radial-gradient(1000px 600px at 20% 20%, rgba(124,92,255,.08), transparent 55%),
                  radial-gradient(900px 600px at 80% 40%, rgba(124,92,255,.06), transparent 55%);
    }

    #sv{
      position:absolute; inset:0;
      width:100%; height:100%;
      touch-action:none; /* ✅ 모바일 핀치/드래그를 pointer events로 처리 */
      user-select:none;
    }

    #overlay{ position:absolute; inset:0; pointer-events:none; }

    /* floating tooltip */
    #floatingTip{
      position:fixed;
      z-index:100;
      display:none;
      max-width:min(360px, 80vw);
      background:rgba(15,24,43,.98);
      border:1px solid rgba(199,210,254,.18);
      border-radius:14px;
      box-shadow: var(--shadow);
      padding:10px 12px;
      pointer-events:none;
    }
    #floatingTip .t{ font-size:13px; font-weight:700; margin-bottom:6px; }
    #floatingTip .d{ font-size:12px; color:var(--muted); line-height:1.35; }

    /* editors */
    .panel{
      position:fixed;
      right:14px; top:70px;
      width: 340px;
      max-width: 92vw;
      background:rgba(15,24,43,.98);
      border:1px solid rgba(199,210,254,.18);
      border-radius:16px;
      box-shadow: var(--shadow);
      padding:12px;
      display:none;
      user-select:text;
      z-index:120;
    }
    .panel h3{ margin:0 0 8px 0; font-size:14px; color: var(--text); }
    .row{ display:flex; gap:8px; align-items:center; margin:8px 0; }
    .row label{ width:88px; color: var(--muted); font-size:12px; }
    .row input, .row textarea{
      flex:1;
      background: rgba(15,21,34,.85);
      border:1px solid rgba(36,49,74,.85);
      color: var(--text);
      border-radius: 12px;
      padding:8px 10px;
      font-size:12px;
      outline:none;
    }
    .row textarea{ min-height: 80px; resize: vertical; font-family: var(--font); }
    .actions{ display:flex; gap:8px; justify-content:flex-end; margin-top:10px; }
    .mini{ font-size:12px; padding:8px 10px; border-radius: 12px; }

    #siteLink{ position:fixed; left:12px; bottom:12px; z-index:130; text-decoration:none; }

    @media (max-width: 920px){
      #hint{ display:none; }
      .panel{ width: 92vw; left:4vw; right:auto; }
      #topbar{ flex-wrap:wrap; }
    }

    /* label HTML inside foreignObject */
    .lbl{
      display:inline-block;
      padding: 3px 6px;
      border-radius: 10px;
      background: rgba(15,24,43,.78);
      border: 1px solid rgba(199,210,254,.14);
      color: var(--text);
      font-size: 12px;
      line-height: 1.1;
      white-space: nowrap;
      transform: translate(-50%, -50%);
      pointer-events: none;
    }
  </style>
</head>

<body>
<div id="app">
  <div id="topbar">
    <div class="group" id="toolGroup">
      <button class="btn" data-tool="select" id="btnSelect">선택/이동</button>

      <div class="dropdown" id="toolsDropdown">
        <button class="btn" id="btnTools" type="button">도구 ▾</button>
        <div class="dropdownMenu" id="toolsMenu">
          <button class="btn" data-tool="point">점</button>
          <button class="btn" data-tool="segment">선분</button>
          <button class="btn" data-tool="line">직선</button>
          <button class="btn" data-tool="circle">원</button>
          <button class="btn" data-tool="parabola">포물선</button>
          <button class="btn" data-tool="ellipse">타원</button>
          <button class="btn" data-tool="hyperbola">쌍곡선</button>
        </div>
      </div>

      <button class="btn" data-tool="text" id="btnText">텍스트</button>
    </div>

    <div class="group">
      <button class="btn" id="btnUndo">이전(Undo)</button>
      <button class="btn" id="btnRedo">다음(Redo)</button>
      <div class="sep"></div>
      <button class="btn" id="btnLang">KO</button>
    </div>

    <div id="hint"></div>
  </div>

  <div id="work">
    <svg id="sv" xmlns="http://www.w3.org/2000/svg"></svg>
    <div id="overlay"></div>
  </div>
</div>

<a id="siteLink" class="btn" href="https://min7014.github.io" target="_blank" rel="noopener">min7014.github.io</a>

<div id="floatingTip">
  <div class="t" id="tipTitle"></div>
  <div class="d" id="tipDesc"></div>
</div>

<div class="panel" id="objEditor">
  <h3 id="objTitle">객체 속성</h3>
  <div class="row"><label id="lblKind">종류</label><input id="objKind" readonly /></div>
  <div class="row"><label>ID</label><input id="objId" readonly /></div>
  <div class="row"><label id="lblName">이름</label><input id="objName" placeholder="예: A, l1, c1 ..." /></div>
  <div class="row"><label id="lblCaption">캡션</label><textarea id="objCaption" placeholder="예: $\\mathrm{A}$ 또는 $y=x^2$"></textarea></div>
  <div class="row" id="rowX"><label>X</label><input id="objX" /></div>
  <div class="row" id="rowY"><label>Y</label><input id="objY" /></div>
  <div class="actions">
    <button class="btn mini danger" id="btnObjCancel">취소</button>
    <button class="btn mini" id="btnObjSave">저장</button>
  </div>
</div>

<div class="panel" id="textEditor">
  <h3 id="textTitle">텍스트 편집</h3>
  <div class="row"><label id="lblText">내용</label><textarea id="txtContent" placeholder="일반 텍스트와 $\\LaTeX$ 혼용 가능"></textarea></div>
  <div class="actions">
    <button class="btn mini danger" id="btnTextCancel">취소</button>
    <button class="btn mini" id="btnTextSave">저장</button>
  </div>
</div>

<script>
(() => {
  "use strict";

  // =========================
  // i18n
  // =========================
  const I18N = {
    ko: {
      ui: {
        hint: "도구 선택 → 화면을 클릭/드래그로 생성/이동. (모바일: 두 손가락 핀치 확대/축소)",
        undo: "이전(Undo)",
        redo: "다음(Redo)",
        tools: "도구",
        select: "선택/이동",
        text: "텍스트",
      },
      tools: {
        select: { name: "선택/이동", desc: "객체 선택, 점/텍스트 드래그, 빈 공간 드래그로 평면 이동" },
        point: { name: "점", desc: "빈 곳 클릭: 점 생성. 교점 근처 클릭: 교점 생성. 도형 위 클릭: 도형에 종속된 점 생성" },
        segment: { name: "선분", desc: "두 점을 찍거나 선택하면 선분 생성 (1-2, 3-4, ...)" },
        line: { name: "직선", desc: "두 점을 찍거나 선택하면 직선 생성" },
        circle: { name: "원", desc: "중심점 → 원 위의 점 선택/생성" },
        parabola: { name: "포물선", desc: "초점 점 선택/생성 → 준선(직선/선분 또는 두 점) 선택" },
        ellipse: { name: "타원", desc: "두 초점 점 선택/생성 → 타원 위의 점 선택/생성" },
        hyperbola: { name: "쌍곡선", desc: "두 초점 점 선택/생성 → 쌍곡선 위의 점 선택/생성" },
        text: { name: "텍스트", desc: "클릭으로 텍스트 생성, 더블클릭/Enter로 편집" },
      },
      editor: {
        objTitle: "객체 속성",
        textTitle: "텍스트 편집",
        kind: "종류",
        name: "이름",
        caption: "캡션",
        content: "내용",
        save: "저장",
        cancel: "취소",
      }
    },
    en: {
      ui: {
        hint: "Select a tool → click/drag to create/move. (Mobile: pinch to zoom)",
        undo: "Undo",
        redo: "Redo",
        tools: "Tools",
        select: "Select/Move",
        text: "Text",
      },
      tools: {
        select: { name: "Select/Move", desc: "Select objects, drag points/text, drag empty space to pan" },
        point: { name: "Point", desc: "Click empty: create point. Near intersection: create intersection point. On object: constrained point" },
        segment: { name: "Segment", desc: "Pick/create two points to create a segment (1-2, 3-4, ...)" },
        line: { name: "Line", desc: "Pick/create two points to create a line" },
        circle: { name: "Circle", desc: "Center point → point on circle" },
        parabola: { name: "Parabola", desc: "Focus point → directrix (line/segment or two points)" },
        ellipse: { name: "Ellipse", desc: "Two foci → a point on ellipse" },
        hyperbola: { name: "Hyperbola", desc: "Two foci → a point on hyperbola" },
        text: { name: "Text", desc: "Click to create text. Double-click / Enter to edit" },
      },
      editor: {
        objTitle: "Object",
        textTitle: "Text",
        kind: "Kind",
        name: "Name",
        caption: "Caption",
        content: "Content",
        save: "Save",
        cancel: "Cancel",
      }
    }
  };

  let lang = (localStorage.getItem("mathlab.lang") || "ko");

  const $ = (id) => document.getElementById(id);
  const sv = $("sv");
  const overlay = $("overlay");
  const hint = $("hint");
  const objEditor = $("objEditor");
  const textEditor = $("textEditor");

  const btnSelect = $("btnSelect");
  const btnTools = $("btnTools");
  const toolsDropdown = $("toolsDropdown");
  const toolsMenu = $("toolsMenu");
  const btnText = $("btnText");
  const btnUndo = $("btnUndo");
  const btnRedo = $("btnRedo");
  const btnLang = $("btnLang");

  const floatingTip = $("floatingTip");
  const tipTitle = $("tipTitle");
  const tipDesc = $("tipDesc");

  const t = () => I18N[lang] || I18N.ko;

  // =========================
  // State
  // =========================
  const cam = {
    x: 0,
    y: 0,
    scale: 70, // px per world unit
  };

  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

  // objects
  let objects = [];
  let nextId = 1;

  // tool state
  let tool = "select";
  let selected = null; // {id}
  let dragging = null; // {id, kind, pointerId, offX, offY}
  let isPanning = false;
  let panStart = null; // {sx,sy, camX, camY, scale}

  // tool-progress variables
  let segP1 = null;
  let lineP1 = null;
  let circleC = null;
  let parabolaFocus = null;
  let parabolaD1 = null;
  let ellipseF1 = null;
  let ellipseF2 = null;
  let hyperF1 = null;
  let hyperF2 = null;

  // undo/redo
  let undoStack = [];
  let redoStack = [];

  // =========================
  // Pinch zoom (mobile)
  // =========================
  const activeTouches = new Map();
  let pinchState = null; // {ids:[id1,id2], startDist, startScale, anchor:{wx,wy}}

  // =========================
  // Utilities
  // =========================
  function svgEl(name, attrs = {}, parent = sv){
    const el = document.createElementNS("http://www.w3.org/2000/svg", name);
    for (const [k,v] of Object.entries(attrs)){
      if (v === null || v === undefined) continue;
      el.setAttribute(k, String(v));
    }
    parent.appendChild(el);
    return el;
  }

  function clearSvg(){
    while (sv.firstChild) sv.removeChild(sv.firstChild);
    while (overlay.firstChild) overlay.removeChild(overlay.firstChild);
  }

  function size(){
    const r = sv.getBoundingClientRect();
    return { w: r.width || 1, h: r.height || 1, left: r.left, top: r.top };
  }

  function clientToScreen(cx, cy){
    const r = sv.getBoundingClientRect();
    return { sx: cx - r.left, sy: cy - r.top };
  }

  function worldToScreen(wx, wy){
    const {w,h} = size();
    const sx = (wx - cam.x) * cam.scale + w/2;
    const sy = h/2 - (wy - cam.y) * cam.scale;
    return {sx, sy};
  }

  function screenToWorld(sx, sy){
    const {w,h} = size();
    const wx = cam.x + (sx - w/2) / cam.scale;
    const wy = cam.y + (h/2 - sy) / cam.scale;
    return {wx, wy};
  }

  function viewBoundsWorld(){
    const {w,h} = size();
    const xMin = cam.x - (w/2)/cam.scale;
    const xMax = cam.x + (w/2)/cam.scale;
    const yMin = cam.y - (h/2)/cam.scale;
    const yMax = cam.y + (h/2)/cam.scale;
    return {xMin,xMax,yMin,yMax,w,h};
  }

  function dist(a,b){
    const dx = a.x - b.x, dy = a.y - b.y;
    return Math.hypot(dx,dy);
  }

  function getById(id){
    return objects.find(o => o.id === id) || null;
  }

  function newId(){
    return "o" + (nextId++);
  }

  // =========================
  // Naming
  // =========================
  function idxToLetters(n){
    // 0->A, 25->Z, 26->AA
    let s = "";
    n = Math.max(0, n|0);
    while (true){
      const r = n % 26;
      s = String.fromCharCode(65 + r) + s;
      n = Math.floor(n/26) - 1;
      if (n < 0) break;
    }
    return s;
  }

  function usedNames(){
    const set = new Set();
    for (const o of objects){
      if (o.name) set.add(o.name);
    }
    return set;
  }

  function nextPointName(){
    const used = usedNames();
    for (let i=0; i<10000; i++){
      const name = idxToLetters(i);
      if (!used.has(name)) return name;
    }
    return "P" + Math.floor(Math.random()*9999);
  }

  function ensureUniqueName(obj, desired){
    desired = (desired || "").trim();
    if (!desired){
      obj.name = "";
      return;
    }
    const used = usedNames();
    if (!used.has(desired) || obj.name === desired){
      // ok
      obj.name = desired;
      return;
    }
    // duplicate: change THIS object name by appending _{n} (caption unchanged)
    let n = 1;
    while (true){
      const cand = `${desired}_{${n}}`;
      if (!used.has(cand)){
        obj.name = cand;
        return;
      }
      n++;
      if (n > 9999){
        obj.name = desired + "_" + Math.floor(Math.random()*9999);
        return;
      }
    }
  }

  // =========================
  // Storage
  // =========================
  const STORAGE_KEY = "mathlab.state.v3";

  function snapshot(){
    return JSON.stringify({ objects, nextId, cam, lang });
  }

  function restoreFrom(json){
    const s = JSON.parse(json);
    objects = Array.isArray(s.objects) ? s.objects : [];
    nextId = (typeof s.nextId === "number") ? s.nextId : 1;
    if (s.cam && typeof s.cam.x === "number"){
      cam.x = s.cam.x; cam.y = s.cam.y; cam.scale = s.cam.scale;
    }
    if (s.lang === "ko" || s.lang === "en") lang = s.lang;
  }

  function saveToStorage(){
    try{ localStorage.setItem(STORAGE_KEY, snapshot()); } catch {}
    try{ localStorage.setItem("mathlab.lang", lang); } catch {}
  }

  function loadFromStorage(){
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return;
    try{ restoreFrom(raw); } catch {}
  }

  // =========================
  // Undo/Redo
  // =========================
  function pushState(){
    undoStack.push(snapshot());
    if (undoStack.length > 80) undoStack.shift();
    redoStack.length = 0;
  }

  function undo(){
    if (!undoStack.length) return;
    redoStack.push(snapshot());
    const s = undoStack.pop();
    restoreFrom(s);
    closeEditors(true);
    saveToStorage();
    render();
    syncUI();
  }

  function redo(){
    if (!redoStack.length) return;
    undoStack.push(snapshot());
    const s = redoStack.pop();
    restoreFrom(s);
    closeEditors(true);
    saveToStorage();
    render();
    syncUI();
  }

  // =========================
  // Grid/Axes
  // =========================
  function niceStep(target){
    const pow = Math.pow(10, Math.floor(Math.log10(target)));
    const t = target / pow;
    let m;
    if (t <= 1) m = 1;
    else if (t <= 2) m = 2;
    else if (t <= 5) m = 5;
    else m = 10;
    return m * pow;
  }

  function gridStep(){
    const px = 80; // prefer 80px
    return niceStep(px / cam.scale);
  }

  function drawGridAndAxes(){
    const {xMin,xMax,yMin,yMax,w,h} = viewBoundsWorld();
    const step = gridStep();

    // background
    svgEl("rect", {x:0,y:0,width:w,height:h,fill:"transparent"});

    // grid lines
    const g = svgEl("g", {opacity:"0.85"});
    const startX = Math.floor(xMin/step)*step;
    const endX = Math.ceil(xMax/step)*step;
    const startY = Math.floor(yMin/step)*step;
    const endY = Math.ceil(yMax/step)*step;

    for (let x = startX; x <= endX + 1e-9; x += step){
      const {sx} = worldToScreen(x, 0);
      svgEl("line", {x1:sx,y1:0,x2:sx,y2:h,stroke:"rgba(199,210,254,.08)","stroke-width":1}, g);
    }
    for (let y = startY; y <= endY + 1e-9; y += step){
      const {sy} = worldToScreen(0, y);
      svgEl("line", {x1:0,y1:sy,x2:w,y2:sy,stroke:"rgba(199,210,254,.08)","stroke-width":1}, g);
    }

    // axes with arrowheads
    const defs = svgEl("defs", {});
    const marker = svgEl("marker", {id:"arrow", viewBox:"0 0 10 10", refX:"7", refY:"5", markerWidth:"6", markerHeight:"6", orient:"auto-start-reverse"}, defs);
    svgEl("path", {d:"M 0 0 L 10 5 L 0 10 z", fill:"rgba(199,210,254,.55)"}, marker);

    const ax = svgEl("g", {opacity:"1"});
    const y0 = worldToScreen(0, cam.y).sy;
    const x0 = worldToScreen(cam.x, 0).sx;

    // x-axis line
    svgEl("line", {x1:0,y1:y0,x2:w,y2:y0,stroke:"rgba(199,210,254,.35)","stroke-width":1.4,"marker-start":"url(#arrow)","marker-end":"url(#arrow)"}, ax);
    // y-axis line
    svgEl("line", {x1:x0,y1:0,x2:x0,y2:h,stroke:"rgba(199,210,254,.35)","stroke-width":1.4,"marker-start":"url(#arrow)","marker-end":"url(#arrow)"}, ax);

    // origin label "0"
    const origin = worldToScreen(0,0);
    addOverlayLabel(origin.sx + 10, origin.sy + 14, "0");
  }

  // =========================
  // LaTeX rendering helper (HTML)
  // =========================
  function renderInlineLatexToHTML(str){
    if (typeof str !== "string") return "";
    if (!str.includes("$")){
      return escapeHtml(str);
    }
    const parts = str.split("$");
    let out = "";
    for (let i=0; i<parts.length; i++){
      const seg = parts[i];
      if (i % 2 === 0){
        out += escapeHtml(seg);
      } else {
        out += `<span class="katex-inline" data-latex="${escapeAttr(seg)}"></span>`;
      }
    }
    return out;
  }

  function escapeHtml(s){
    return String(s).replace(/[&<>"']/g, c => ({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[c]));
  }
  function escapeAttr(s){
    return String(s).replace(/[&<>"']/g, c => ({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[c]));
  }

  function applyKatexWithin(el){
    if (!window.katex) return;
    const nodes = el.querySelectorAll(".katex-inline");
    for (const n of nodes){
      const tex = n.getAttribute("data-latex") || "";
      try{
        n.innerHTML = "";
        window.katex.render(tex, n, {throwOnError:false});
      } catch {
        n.textContent = tex;
      }
    }
  }

  // =========================
  // Overlay labels (HTML in div overlay)
  // =========================
  function addOverlayLabel(px, py, html){
    const d = document.createElement("div");
    d.className = "lbl";
    d.style.position = "absolute";
    d.style.left = px + "px";
    d.style.top = py + "px";
    d.innerHTML = renderInlineLatexToHTML(html);
    overlay.appendChild(d);
    applyKatexWithin(d);
    return d;
  }

  // =========================
  // Geometry helpers
  // =========================
  function lineFromPoints(p1, p2){
    // ax + by + c = 0
    const a = p2.y - p1.y;
    const b = p1.x - p2.x;
    const c = -(a*p1.x + b*p1.y);
    const n = Math.hypot(a,b) || 1;
    return {a:a/n, b:b/n, c:c/n};
  }

  function signedDistToLine(L, p){
    return L.a*p.x + L.b*p.y + L.c;
  }

  function projectToLine(L, p){
    const d = signedDistToLine(L,p);
    return {x: p.x - L.a*d, y: p.y - L.b*d};
  }

  function intersectSegments(p, p2, q, q2){
    // returns {x,y} or null
    const r = {x: p2.x - p.x, y: p2.y - p.y};
    const s = {x: q2.x - q.x, y: q2.y - q.y};
    const denom = r.x*s.y - r.y*s.x;
    if (Math.abs(denom) < 1e-12) return null;
    const qp = {x: q.x - p.x, y: q.y - p.y};
    const t = (qp.x*s.y - qp.y*s.x)/denom;
    const u = (qp.x*r.y - qp.y*r.x)/denom;
    if (t < 0 || t > 1 || u < 0 || u > 1) return null;
    return {x: p.x + t*r.x, y: p.y + t*r.y};
  }

  function polylineIntersections(polyA, polyB){
    const hits = [];
    for (let i=0; i<polyA.length-1; i++){
      const p = polyA[i], p2 = polyA[i+1];
      for (let j=0; j<polyB.length-1; j++){
        const q = polyB[j], q2 = polyB[j+1];
        const h = intersectSegments(p,p2,q,q2);
        if (h) hits.push(h);
      }
    }
    return hits;
  }

  function polylineNearest(poly, pt){
    // returns nearest point on polyline and t in [0,1] along cumulative length
    let best = {x:poly[0].x, y:poly[0].y, t:0, d:Infinity};
    let total = 0;
    const segLens = [];
    for (let i=0; i<poly.length-1; i++){
      const L = Math.hypot(poly[i+1].x - poly[i].x, poly[i+1].y - poly[i].y);
      segLens.push(L);
      total += L;
    }
    if (total <= 1e-12) return best;

    let acc = 0;
    for (let i=0; i<poly.length-1; i++){
      const a = poly[i], b = poly[i+1];
      const vx = b.x - a.x, vy = b.y - a.y;
      const L2 = vx*vx + vy*vy;
      let u = 0;
      if (L2 > 1e-12){
        u = ((pt.x - a.x)*vx + (pt.y - a.y)*vy)/L2;
        u = Math.max(0, Math.min(1, u));
      }
      const x = a.x + u*vx;
      const y = a.y + u*vy;
      const d = Math.hypot(x-pt.x, y-pt.y);
      const t = (acc + u*segLens[i]) / total;
      if (d < best.d){ best = {x,y,t,d}; }
      acc += segLens[i];
    }
    return best;
  }

  function polylinePointAtT(poly, t){
    t = Math.max(0, Math.min(1, t));
    let total = 0;
    const segLens = [];
    for (let i=0; i<poly.length-1; i++){
      const L = Math.hypot(poly[i+1].x - poly[i].x, poly[i+1].y - poly[i].y);
      segLens.push(L);
      total += L;
    }
    if (total <= 1e-12) return {...poly[0]};

    const target = t * total;
    let acc = 0;
    for (let i=0; i<poly.length-1; i++){
      const L = segLens[i];
      if (acc + L >= target){
        const u = (target - acc) / (L || 1);
        const a = poly[i], b = poly[i+1];
        return {x: a.x + u*(b.x-a.x), y: a.y + u*(b.y-a.y)};
      }
      acc += L;
    }
    return {...poly[poly.length-1]};
  }

  // Smooth path from polyline using Catmull-Rom -> Bezier
  function polylineToSmoothPathScreen(pts){
    if (pts.length < 2) return "";
    const p = pts;
    let d = `M ${p[0].sx.toFixed(2)} ${p[0].sy.toFixed(2)}`;
    if (pts.length === 2){
      d += ` L ${p[1].sx.toFixed(2)} ${p[1].sy.toFixed(2)}`;
      return d;
    }
    for (let i=0; i<pts.length-1; i++){
      const p0 = pts[Math.max(0, i-1)];
      const p1 = pts[i];
      const p2 = pts[i+1];
      const p3 = pts[Math.min(pts.length-1, i+2)];
      const c1x = p1.sx + (p2.sx - p0.sx) / 6;
      const c1y = p1.sy + (p2.sy - p0.sy) / 6;
      const c2x = p2.sx - (p3.sx - p1.sx) / 6;
      const c2y = p2.sy - (p3.sy - p1.sy) / 6;
      d += ` C ${c1x.toFixed(2)} ${c1y.toFixed(2)} ${c2x.toFixed(2)} ${c2y.toFixed(2)} ${p2.sx.toFixed(2)} ${p2.sy.toFixed(2)}`;
    }
    return d;
  }

  // =========================
  // Sampling (for hit tests / intersections)
  // =========================
  function dynamicN(pixelLen, minN, maxN, stepPx){
    const n = Math.floor(pixelLen / Math.max(0.35, stepPx));
    return clamp(n, minN, maxN);
  }

  function sampleLineAsSegment(obj){
    // infinite line clipped to view bounds
    const a = getById(obj.aId), b = getById(obj.bId);
    if (!a || !b) return [];
    const {xMin,xMax,yMin,yMax} = viewBoundsWorld();
    const p1 = {x:a.x, y:a.y};
    const p2 = {x:b.x, y:b.y};
    const dx = p2.x - p1.x;
    const dy = p2.y - p1.y;
    const pts = [];

    // intersect with 4 borders
    const borders = [
      {x:xMin, y1:yMin, y2:yMax, vertical:true},
      {x:xMax, y1:yMin, y2:yMax, vertical:true},
      {y:yMin, x1:xMin, x2:xMax, vertical:false},
      {y:yMax, x1:xMin, x2:xMax, vertical:false},
    ];

    for (const br of borders){
      if (br.vertical){
        if (Math.abs(dx) < 1e-12) continue;
        const t = (br.x - p1.x) / dx;
        const y = p1.y + t*dy;
        if (y >= br.y1 - 1e-9 && y <= br.y2 + 1e-9) pts.push({x:br.x, y});
      } else {
        if (Math.abs(dy) < 1e-12) continue;
        const t = (br.y - p1.y) / dy;
        const x = p1.x + t*dx;
        if (x >= br.x1 - 1e-9 && x <= br.x2 + 1e-9) pts.push({x, y:br.y});
      }
    }

    // pick two distinct
    if (pts.length < 2) return [];
    // remove near-duplicates
    const uniq = [];
    for (const p of pts){
      if (!uniq.some(q => Math.hypot(q.x-p.x,q.y-p.y) < 1e-6)) uniq.push(p);
    }
    if (uniq.length < 2) return [];
    return [uniq[0], uniq[1]];
  }

  function sampleObject(obj){
    const kind = obj.kind;
    if (kind === "segment"){
      const a = getById(obj.aId), b = getById(obj.bId);
      if (!a || !b) return [];
      return [{x:a.x,y:a.y},{x:b.x,y:b.y}];
    }
    if (kind === "line"){
      return sampleLineAsSegment(obj);
    }
    if (kind === "circle"){
      const c = getById(obj.cId), p = getById(obj.pId);
      if (!c || !p) return [];
      const r = Math.hypot(p.x-c.x,p.y-c.y);
      const {w} = size();
      const circPx = 2*Math.PI*r*cam.scale;
      const N = dynamicN(circPx, 300, 16000, 0.55);
      const out = [];
      for (let i=0;i<=N;i++){
        const th = 2*Math.PI*i/N;
        out.push({x: c.x + r*Math.cos(th), y: c.y + r*Math.sin(th)});
      }
      return out;
    }
    if (kind === "ellipse"){
      const f1 = getById(obj.f1Id), f2 = getById(obj.f2Id), pp = getById(obj.pId);
      if (!f1 || !f2 || !pp) return [];
      const d1 = Math.hypot(pp.x-f1.x, pp.y-f1.y);
      const d2 = Math.hypot(pp.x-f2.x, pp.y-f2.y);
      const a = (d1+d2)/2;
      const c = Math.hypot(f2.x-f1.x, f2.y-f1.y)/2;
      if (a <= c + 1e-9) return [];
      const b = Math.sqrt(Math.max(0, a*a - c*c));
      const cx = (f1.x+f2.x)/2, cy=(f1.y+f2.y)/2;
      const ang = Math.atan2(f2.y-f1.y, f2.x-f1.x);
      // Ramanujan perimeter approx
      const per = Math.PI * (3*(a+b) - Math.sqrt((3*a+b)*(a+3*b)));
      const N = dynamicN(per*cam.scale, 360, 18000, 0.55);
      const out=[];
      for (let i=0;i<=N;i++){
        const th = 2*Math.PI*i/N;
        const x = a*Math.cos(th);
        const y = b*Math.sin(th);
        const xr = cx + x*Math.cos(ang) - y*Math.sin(ang);
        const yr = cy + x*Math.sin(ang) + y*Math.cos(ang);
        out.push({x:xr,y:yr});
      }
      return out;
    }
    if (kind === "parabola"){
      const f = getById(obj.focusId), d1 = getById(obj.d1Id), d2 = getById(obj.d2Id);
      if (!f || !d1 || !d2) return [];
      const L = lineFromPoints({x:d1.x,y:d1.y},{x:d2.x,y:d2.y});
      const proj = projectToLine(L, {x:f.x,y:f.y});
      const D = Math.abs(signedDistToLine(L, {x:f.x,y:f.y}));
      if (D < 1e-9) return [];
      // unit normal pointing from directrix to focus
      const sign = signedDistToLine(L, {x:f.x,y:f.y}) >= 0 ? 1 : -1;
      const n = {x: L.a*sign, y: L.b*sign};
      const u = {x: -n.y, y: n.x};
      const p = D/2;
      const vtx = {x: (f.x + proj.x)/2, y: (f.y + proj.y)/2};

      // Determine u-range from viewport corners transformed into local coords
      const {xMin,xMax,yMin,yMax} = viewBoundsWorld();
      const corners = [
        {x:xMin,y:yMin},{x:xMin,y:yMax},{x:xMax,y:yMin},{x:xMax,y:yMax}
      ];
      let uMax=0;
      for (const c0 of corners){
        const dx = c0.x - vtx.x;
        const dy = c0.y - vtx.y;
        const uu = dx*u.x + dy*u.y;
        uMax = Math.max(uMax, Math.abs(uu));
      }
      uMax *= 1.1;
      const spanPx = 2*uMax*cam.scale;
      const N = dynamicN(spanPx, 900, 26000, 0.55);
      const out=[];
      for (let i=0;i<=N;i++){
        const uu = -uMax + (2*uMax)*i/N;
        const vv = (uu*uu)/(4*p);
        const x = vtx.x + uu*u.x + vv*n.x;
        const y = vtx.y + uu*u.y + vv*n.y;
        out.push({x,y});
      }
      return out;
    }
    if (kind === "hyperbola"){
      const f1 = getById(obj.f1Id), f2 = getById(obj.f2Id), pp = getById(obj.pId);
      if (!f1 || !f2 || !pp) return [];
      const c = Math.hypot(f2.x-f1.x,f2.y-f1.y)/2;
      const k = Math.abs(Math.hypot(pp.x-f1.x,pp.y-f1.y) - Math.hypot(pp.x-f2.x,pp.y-f2.y));
      const a = k/2;
      if (a <= 1e-9 || c <= a + 1e-9) return [];
      const b = Math.sqrt(Math.max(0, c*c - a*a));
      const cx = (f1.x+f2.x)/2, cy=(f1.y+f2.y)/2;
      const ang = Math.atan2(f2.y-f1.y, f2.x-f1.x);

      // determine t-range based on view bounds
      const {xMin,xMax,yMin,yMax} = viewBoundsWorld();
      const maxR = Math.max(
        Math.hypot(xMin-cx,yMin-cy),
        Math.hypot(xMin-cx,yMax-cy),
        Math.hypot(xMax-cx,yMin-cy),
        Math.hypot(xMax-cx,yMax-cy)
      ) * 1.25;
      // in local coords, x ~ a cosh t, y ~ b sinh t
      const T = Math.max(1.2, Math.asinh(maxR / Math.max(1e-9, b)));
      const approxPx = (2*T) * cam.scale * Math.max(a,b);
      const N = dynamicN(approxPx, 1000, 32000, 0.55);

      const out=[];
      for (let i=0;i<=N;i++){
        const tt = -T + (2*T)*i/N;
        const ch = Math.cosh(tt);
        const sh = Math.sinh(tt);
        // right branch
        let x = a*ch;
        let y = b*sh;
        let xr = cx + x*Math.cos(ang) - y*Math.sin(ang);
        let yr = cy + x*Math.sin(ang) + y*Math.cos(ang);
        out.push({x:xr,y:yr});
      }
      // separator by NaN to allow splitting when rendering if needed
      out.push({x:NaN,y:NaN});
      for (let i=0;i<=N;i++){
        const tt = -T + (2*T)*i/N;
        const ch = Math.cosh(tt);
        const sh = Math.sinh(tt);
        // left branch
        let x = -a*ch;
        let y = b*sh;
        let xr = cx + x*Math.cos(ang) - y*Math.sin(ang);
        let yr = cy + x*Math.sin(ang) + y*Math.cos(ang);
        out.push({x:xr,y:yr});
      }
      return out;
    }
    return [];
  }

  // =========================
  // Intersection candidate search
  // =========================
  function findNearestIntersectionCandidate(wx, wy){
    const click = {x:wx,y:wy};
    const tol = 12 / cam.scale; // ~12px
    let best = null;

    const curveObjs = objects.filter(o => !["point","text"].includes(o.kind));
    for (let i=0;i<curveObjs.length;i++){
      for (let j=i+1;j<curveObjs.length;j++){
        const A = curveObjs[i], B = curveObjs[j];
        const polyA = sampleObject(A);
        const polyB = sampleObject(B);
        if (polyA.length < 2 || polyB.length < 2) continue;

        // handle hyperbola with NaN split: just include NaNs, intersection function will ignore if we split
        const hits = polylineIntersections(polyA.filter(p=>Number.isFinite(p.x)&&Number.isFinite(p.y)), polyB.filter(p=>Number.isFinite(p.x)&&Number.isFinite(p.y)));
        for (const h of hits){
          const d = Math.hypot(h.x-click.x,h.y-click.y);
          if (d <= tol && (!best || d < best.d)){
            best = { parents:[A.id,B.id], x:h.x, y:h.y, d };
          }
        }
      }
    }
    return best;
  }

  function allIntersections(parentAId, parentBId){
    const A = getById(parentAId);
    const B = getById(parentBId);
    if (!A || !B) return [];
    const polyA = sampleObject(A).filter(p=>Number.isFinite(p.x)&&Number.isFinite(p.y));
    const polyB = sampleObject(B).filter(p=>Number.isFinite(p.x)&&Number.isFinite(p.y));
    if (polyA.length < 2 || polyB.length < 2) return [];
    return polylineIntersections(polyA, polyB);
  }

  // =========================
  // Creation helpers
  // =========================
  function createPoint(wx, wy){
    const name = nextPointName();
    const p = {
      id: newId(),
      kind: "point",
      x: wx,
      y: wy,
      name,
      caption: `$\\mathrm{${name}}$`,
    };
    objects.push(p);
    return p;
  }

  function ensurePointAt(wx, wy){
    return createPoint(wx, wy);
  }

  function getOrCreatePointForClick(wx, wy){
    const id = hitTest(wx, wy);
    const obj = id ? getById(id) : null;
    if (obj && obj.kind === "point") return obj;
    return createPoint(wx, wy);
  }

  function createSegment(aId,bId){
    objects.push({id:newId(), kind:"segment", aId, bId, name:"", caption:""});
  }

  function createLine(aId,bId){
    objects.push({id:newId(), kind:"line", aId, bId, name:"", caption:""});
  }

  function createCircle(cId,pId){
    objects.push({id:newId(), kind:"circle", cId, pId, name:"", caption:""});
  }

  function createParabola(focusId, d1Id, d2Id){
    objects.push({id:newId(), kind:"parabola", focusId, d1Id, d2Id, name:"", caption:""});
  }

  function createEllipse(f1Id,f2Id,pId){
    objects.push({id:newId(), kind:"ellipse", f1Id,f2Id,pId, name:"", caption:""});
  }

  function createHyperbola(f1Id,f2Id,pId){
    objects.push({id:newId(), kind:"hyperbola", f1Id,f2Id,pId, name:"", caption:""});
  }

  function createText(wx, wy, content=""){
    const o = {id:newId(), kind:"text", x:wx, y:wy, content};
    objects.push(o);
    return o;
  }

  function createPointOnObject(parentId, wx, wy){
    const parent = getById(parentId);
    if (!parent) return null;
    const poly = sampleObject(parent).filter(p=>Number.isFinite(p.x)&&Number.isFinite(p.y));
    if (poly.length < 2) return null;
    const proj = polylineNearest(poly, {x:wx,y:wy});
    const p = createPoint(proj.x, proj.y);
    p.constraint = {type:"on", parentId, t: proj.t};
    return p;
  }

  function createIntersectionPoint(hit){
    const p = createPoint(hit.x, hit.y);
    const parents = hit.parents;
    // store which intersection index (nearest at creation)
    const all = allIntersections(parents[0], parents[1]);
    let idx = 0;
    let bestD = Infinity;
    for (let i=0;i<all.length;i++){
      const h = all[i];
      const d = Math.hypot(h.x-hit.x,h.y-hit.y);
      if (d < bestD){ bestD = d; idx = i; }
    }
    p.constraint = {type:"intersection", parents, idx};
    return p;
  }

  // =========================
  // Constraints update
  // =========================
  function updateConstraints(){
    // on-object points
    for (const o of objects){
      if (o.kind !== "point") continue;
      const c = o.constraint;
      if (!c) continue;
      if (c.type === "on"){
        const parent = getById(c.parentId);
        if (!parent) continue;
        const poly = sampleObject(parent).filter(p=>Number.isFinite(p.x)&&Number.isFinite(p.y));
        if (poly.length < 2) continue;
        const p = polylinePointAtT(poly, c.t || 0);
        o.x = p.x; o.y = p.y;
      }
      if (c.type === "intersection"){
        const [aId,bId] = c.parents || [];
        if (!aId || !bId) continue;
        const hits = allIntersections(aId,bId);
        if (!hits.length) continue;
        const idx = clamp(c.idx || 0, 0, hits.length-1);
        const h = hits[idx];
        o.x = h.x; o.y = h.y;
      }
    }
  }

  // =========================
  // Hit testing
  // =========================
  function hitTest(wx, wy){
    const tolP = 10 / cam.scale; // ~10px
    // points first
    for (let i=objects.length-1;i>=0;i--){
      const o = objects[i];
      if (o.kind === "point"){
        const d = Math.hypot(o.x-wx,o.y-wy);
        if (d <= tolP) return o.id;
      }
    }
    // texts
    for (let i=objects.length-1;i>=0;i--){
      const o = objects[i];
      if (o.kind === "text"){
        const d = Math.hypot(o.x-wx,o.y-wy);
        if (d <= tolP) return o.id;
      }
    }
    // curves
    const tolC = 10 / cam.scale;
    for (let i=objects.length-1;i>=0;i--){
      const o = objects[i];
      if (["point","text"].includes(o.kind)) continue;
      const poly = sampleObject(o).filter(p=>Number.isFinite(p.x)&&Number.isFinite(p.y));
      if (poly.length < 2) continue;
      const nearest = polylineNearest(poly, {x:wx,y:wy});
      if (nearest.d <= tolC) return o.id;
    }
    return null;
  }

  // =========================
  // Rendering
  // =========================
  function renderObject(obj){
    const stroke = "rgba(199,210,254,.92)";
    const stroke2 = "rgba(124,92,255,.95)";
    const selectedStroke = "rgba(255,255,255,.98)";
    const width = 2.0;
    const selWidth = 2.8;

    const isSel = selected && selected.id === obj.id;
    const sCol = isSel ? selectedStroke : (obj.kind === "parabola" ? stroke2 : stroke);
    const sw = isSel ? selWidth : width;

    if (obj.kind === "segment"){
      const a = getById(obj.aId), b = getById(obj.bId);
      if (!a||!b) return;
      const A = worldToScreen(a.x,a.y);
      const B = worldToScreen(b.x,b.y);
      svgEl("line", {x1:A.sx,y1:A.sy,x2:B.sx,y2:B.sy, stroke:sCol, "stroke-width":sw, "stroke-linecap":"round", "stroke-linejoin":"round"});
      renderNameCaption(obj, (A.sx+B.sx)/2, (A.sy+B.sy)/2);
      return;
    }

    if (obj.kind === "line"){
      const seg = sampleLineAsSegment(obj);
      if (seg.length<2) return;
      const A = worldToScreen(seg[0].x, seg[0].y);
      const B = worldToScreen(seg[1].x, seg[1].y);
      svgEl("line", {x1:A.sx,y1:A.sy,x2:B.sx,y2:B.sy, stroke:sCol, "stroke-width":sw, "stroke-linecap":"round", "stroke-linejoin":"round"});
      renderNameCaption(obj, (A.sx+B.sx)/2, (A.sy+B.sy)/2);
      return;
    }

    if (obj.kind === "circle"){
      const c = getById(obj.cId), p = getById(obj.pId);
      if (!c||!p) return;
      const C = worldToScreen(c.x,c.y);
      const r = Math.hypot(p.x-c.x,p.y-c.y) * cam.scale;
      svgEl("circle", {cx:C.sx, cy:C.sy, r, fill:"none", stroke:sCol, "stroke-width":sw, "stroke-linecap":"round", "stroke-linejoin":"round"});
      // label: near top-right of circle
      renderNameCaption(obj, C.sx + r*0.7, C.sy - r*0.7);
      return;
    }

    if (obj.kind === "ellipse"){
      const f1 = getById(obj.f1Id), f2 = getById(obj.f2Id), pp = getById(obj.pId);
      if (!f1||!f2||!pp) return;
      const d1 = Math.hypot(pp.x-f1.x, pp.y-f1.y);
      const d2 = Math.hypot(pp.x-f2.x, pp.y-f2.y);
      const a = (d1+d2)/2;
      const c = Math.hypot(f2.x-f1.x,f2.y-f1.y)/2;
      if (a <= c + 1e-9) return;
      const b = Math.sqrt(Math.max(0, a*a - c*c));
      const cxw = (f1.x+f2.x)/2, cyw=(f1.y+f2.y)/2;
      const ang = Math.atan2(f2.y-f1.y, f2.x-f1.x);
      const C = worldToScreen(cxw, cyw);
      svgEl("ellipse", {
        cx: C.sx,
        cy: C.sy,
        rx: a*cam.scale,
        ry: b*cam.scale,
        fill:"none",
        stroke:sCol,
        "stroke-width":sw,
        transform: `rotate(${(ang*180/Math.PI).toFixed(6)} ${C.sx.toFixed(2)} ${C.sy.toFixed(2)})`,
        "stroke-linecap":"round",
        "stroke-linejoin":"round"
      });
      renderNameCaption(obj, C.sx + a*cam.scale*0.7, C.sy - b*cam.scale*0.7);
      return;
    }

    if (obj.kind === "parabola" || obj.kind === "hyperbola"){
      const poly = sampleObject(obj);
      if (poly.length < 2) return;

      // split by NaN separator (used for hyperbola branches)
      const parts = [];
      let cur = [];
      for (const p of poly){
        if (!Number.isFinite(p.x) || !Number.isFinite(p.y)){
          if (cur.length > 1) parts.push(cur);
          cur = [];
        } else {
          cur.push(p);
        }
      }
      if (cur.length > 1) parts.push(cur);
      if (!parts.length) return;

      for (const part of parts){
        const spts = part.map(q => worldToScreen(q.x, q.y));
        const d = catmullRomPath(spts);
        svgEl("path", {
          d,
          fill: "none",
          stroke: sCol,
          "stroke-width": sw,
          "stroke-linecap": "round",
          "stroke-linejoin": "round"
        });
      }

      // label anchor: midpoint of first branch
      const mid = parts[0][Math.floor(parts[0].length/2)];
      const M = worldToScreen(mid.x, mid.y);
      renderNameCaption(obj, M.sx, M.sy);
      return;
    }
  }


  function renderNameCaption(obj, px, py){
    const text = (selected && selected.id === obj.id) ? (obj.name || "") : (obj.caption || "");
    if (!text) return;
    addOverlayLabel(px + 10, py - 10, text);
  }

  function renderPointsAndTexts(){
    // points
    for (const o of objects){
      if (o.kind !== "point") continue;
      const P = worldToScreen(o.x,o.y);
      const r = 4.2;
      const isSel = selected && selected.id === o.id;
      svgEl("circle", {cx:P.sx, cy:P.sy, r, fill: isSel?"rgba(255,255,255,.95)":"rgba(199,210,254,.92)", stroke:"none"});
      const label = isSel ? (o.name || "") : (o.caption || "");
      if (label) addOverlayLabel(P.sx + 10, P.sy - 10, label);
    }

    // texts
    for (const o of objects){
      if (o.kind !== "text") continue;
      const P = worldToScreen(o.x,o.y);
      addOverlayLabel(P.sx, P.sy, o.content || "");
    }
  }

  function renderCurves(){
    // draw non-point/text objects
    for (const o of objects){
      if (["point","text"].includes(o.kind)) continue;
      if (o.kind === "parabola" || o.kind === "hyperbola"){
        const poly = sampleObject(o);
        if (poly.length < 2) continue;
        // split by NaN for hyperbola
        const parts=[];
        let cur=[];
        for (const p of poly){
          if (!Number.isFinite(p.x) || !Number.isFinite(p.y)){
            if (cur.length){ parts.push(cur); cur=[]; }
            continue;
          }
          cur.push(p);
        }
        if (cur.length) parts.push(cur);

        const isSel = selected && selected.id === o.id;
        const sCol = isSel ? "rgba(255,255,255,.98)" : (o.kind === "parabola" ? "rgba(124,92,255,.95)" : "rgba(199,210,254,.92)");
        const sw = isSel ? 2.8 : 2.0;

        for (const part of parts){
          if (part.length < 2) continue;
          const screenPts = part.map(p => {
            const s = worldToScreen(p.x,p.y);
            return {sx:s.sx, sy:s.sy};
          });
          const d = polylineToSmoothPathScreen(screenPts);
          svgEl("path", {d, fill:"none", stroke:sCol, "stroke-width":sw, "stroke-linecap":"round", "stroke-linejoin":"round"});
        }
        // label near first point
        const sp = worldToScreen(parts[0][Math.floor(parts[0].length*0.65)].x, parts[0][Math.floor(parts[0].length*0.65)].y);
        renderNameCaption(o, sp.sx, sp.sy);
        continue;
      }
      renderObject(o);
    }
  }

  function render(){
    updateConstraints();
    clearSvg();
    const {w,h} = size();
    sv.setAttribute("viewBox", `0 0 ${w} ${h}`);
    drawGridAndAxes();
    renderCurves();
    renderPointsAndTexts();
  }

  // =========================
  // Editors
  // =========================
  let editingId = null;
  let editingTextId = null;
  let beforeEditSnapshot = null;

  function closeEditors(silent=false){
    objEditor.style.display = "none";
    textEditor.style.display = "none";
    editingId = null;
    editingTextId = null;
    beforeEditSnapshot = null;
    if (!silent) render();
  }

  function openObjEditor(id){
    const o = getById(id);
    if (!o) return;
    beforeEditSnapshot = snapshot();
    editingId = id;

    $("objTitle").textContent = t().editor.objTitle;
    $("lblKind").textContent = t().editor.kind;
    $("lblName").textContent = t().editor.name;
    $("lblCaption").textContent = t().editor.caption;
    $("btnObjSave").textContent = t().editor.save;
    $("btnObjCancel").textContent = t().editor.cancel;

    $("objKind").value = o.kind;
    $("objId").value = o.id;
    $("objName").value = o.name || "";
    $("objCaption").value = o.caption || "";

    // coords row only for point/text
    const showXY = (o.kind === "point" || o.kind === "text");
    $("rowX").style.display = showXY ? "flex" : "none";
    $("rowY").style.display = showXY ? "flex" : "none";
    if (showXY){
      $("objX").value = (o.x ?? "");
      $("objY").value = (o.y ?? "");
    }

    objEditor.style.display = "block";
    textEditor.style.display = "none";
  }

  function saveObjEditor(){
    const o = getById(editingId);
    if (!o) return;
    const desiredName = $("objName").value;
    const cap = $("objCaption").value;

    // name uniqueness rule
    ensureUniqueName(o, desiredName);
    // caption should be set exactly as user typed
    o.caption = cap;

    if (o.kind === "point" || o.kind === "text"){
      const x = parseFloat($("objX").value);
      const y = parseFloat($("objY").value);
      if (Number.isFinite(x)) o.x = x;
      if (Number.isFinite(y)) o.y = y;
    }

    pushState();
    saveToStorage();
    closeEditors(true);
    render();
  }

  function cancelObjEditor(){
    if (beforeEditSnapshot){
      restoreFrom(beforeEditSnapshot);
    }
    closeEditors(true);
    render();
    syncUI();
  }

  function openTextEditor(id){
    const o = getById(id);
    if (!o || o.kind !== "text") return;
    beforeEditSnapshot = snapshot();
    editingTextId = id;

    $("textTitle").textContent = t().editor.textTitle;
    $("lblText").textContent = t().editor.content;
    $("btnTextSave").textContent = t().editor.save;
    $("btnTextCancel").textContent = t().editor.cancel;

    $("txtContent").value = o.content || "";

    textEditor.style.display = "block";
    objEditor.style.display = "none";
  }

  function saveTextEditor(){
    const o = getById(editingTextId);
    if (!o || o.kind !== "text") return;
    o.content = $("txtContent").value;
    pushState();
    saveToStorage();
    closeEditors(true);
    render();
  }

  function cancelTextEditor(){
    if (beforeEditSnapshot){
      restoreFrom(beforeEditSnapshot);
    }
    closeEditors(true);
    render();
    syncUI();
  }

  // click outside editor closes (cancel)
  document.addEventListener("pointerdown", (e) => {
    if (objEditor.style.display === "block" || textEditor.style.display === "block"){
      const inObj = objEditor.contains(e.target);
      const inTxt = textEditor.contains(e.target);
      if (!inObj && !inTxt){
        cancelObjEditor();
        cancelTextEditor();
      }
    }
  }, {capture:true});

  $("btnObjSave").addEventListener("click", (e) => { e.preventDefault(); saveObjEditor(); });
  $("btnObjCancel").addEventListener("click", (e) => { e.preventDefault(); cancelObjEditor(); });
  $("btnTextSave").addEventListener("click", (e) => { e.preventDefault(); saveTextEditor(); });
  $("btnTextCancel").addEventListener("click", (e) => { e.preventDefault(); cancelTextEditor(); });

  // =========================
  // Tool dropdown
  // =========================
  function openToolsMenu(){ toolsDropdown.classList.add("open"); }
  function closeToolsMenu(){ toolsDropdown.classList.remove("open"); }
  btnTools.addEventListener("click", (e) => {
    cancelFloatingTip();
    e.stopPropagation();
    toolsDropdown.classList.toggle("open");
  });

  document.addEventListener("pointerdown", (e) => {
    if (!toolsDropdown.contains(e.target)) closeToolsMenu();
  });

  // =========================
  // Floating tooltips (1s idle after click)
  // =========================
  let pendingTip = null; // {toolKey, anchorEl, timer}

  function cancelFloatingTip(){
    if (pendingTip?.timer){ clearTimeout(pendingTip.timer); }
    pendingTip = null;
    floatingTip.style.display = "none";
  }

  function armTipForButton(anchorEl, toolKey){
    cancelFloatingTip();
    pendingTip = { toolKey, anchorEl, timer: null };
    pendingTip.timer = setTimeout(() => {
      if (!pendingTip) return;
      const info = t().tools[toolKey];
      if (!info) return;
      const r = anchorEl.getBoundingClientRect();
      tipTitle.textContent = info.name;
      tipDesc.textContent = info.desc;
      floatingTip.style.left = (r.right + 10) + "px";
      floatingTip.style.top = (r.top - 4) + "px";
      floatingTip.style.display = "block";
    }, 1000);
  }

  function cancelTipOnAction(){
    if (!pendingTip) return;
    cancelFloatingTip();
  }

  // cancel tooltip on any interaction
  ["pointerdown","pointermove","wheel","keydown"].forEach(ev => {
    document.addEventListener(ev, cancelTipOnAction, {passive:true, capture:true});
  });

  // =========================
  // UI
  // =========================
  function resetToolProgress(){
    segP1=null; lineP1=null; circleC=null;
    parabolaFocus=null; parabolaD1=null;
    ellipseF1=null; ellipseF2=null;
    hyperF1=null; hyperF2=null;
  }

  function syncUI(){
    hint.textContent = t().ui.hint;
    btnUndo.textContent = t().ui.undo;
    btnRedo.textContent = t().ui.redo;
    btnLang.textContent = (lang === "ko") ? "KO" : "EN";

    btnSelect.textContent = t().ui.select;
    btnText.textContent = t().ui.text;

    // active classes
    btnSelect.classList.toggle("active", tool === "select");
    btnText.classList.toggle("active", tool === "text");

    // dropdown label shows current tool
    const base = t().ui.tools;
    const isInMenu = ["point","segment","line","circle","parabola","ellipse","hyperbola"].includes(tool);
    btnTools.textContent = (isInMenu ? t().tools[tool].name : base) + " ▾";
    btnTools.classList.toggle("active", isInMenu);

    // menu labels
    for (const b of toolsMenu.querySelectorAll("button[data-tool]")){
      const k = b.dataset.tool;
      b.textContent = t().tools[k]?.name || k;
      b.classList.toggle("active", tool === k);
    }

    saveToStorage();
  }

  function setTool(nextTool){
    tool = nextTool;
    selected = null;
    dragging = null;
    isPanning = false;
    panStart = null;
    resetToolProgress();
    closeToolsMenu();
    syncUI();
    render();
  }

  btnSelect.addEventListener("click", () => { setTool("select"); armTipForButton(btnSelect, "select"); });
  btnText.addEventListener("click", () => { setTool("text"); armTipForButton(btnText, "text"); });

  toolsMenu.querySelectorAll("button[data-tool]").forEach((b) => {
    b.addEventListener("click", () => {
      const k = b.dataset.tool;
      setTool(k);
      armTipForButton(btnTools, k);
    });
  });

  btnUndo.addEventListener("click", () => { cancelFloatingTip(); undo(); });
  btnRedo.addEventListener("click", () => { cancelFloatingTip(); redo(); });

  btnLang.addEventListener("click", () => {
    cancelFloatingTip();
    lang = (lang === "ko") ? "en" : "ko";
    syncUI();
    render();
  });

  // =========================
  // Wheel zoom (desktop)
  // =========================
  sv.addEventListener("wheel", (e) => {
    e.preventDefault();
    cancelFloatingTip();
    const {sx,sy} = clientToScreen(e.clientX,e.clientY);
    const anchor = screenToWorld(sx,sy);
    const factor = Math.exp(-e.deltaY / 450);
    const newScale = clamp(cam.scale * factor, 20, 260);

    // keep anchor stable
    cam.x = anchor.wx - (sx - size().w/2)/newScale;
    cam.y = anchor.wy - (size().h/2 - sy)/newScale;
    cam.scale = newScale;

    saveToStorage();
    render();
  }, {passive:false});

  // =========================
  // Pointer events (create/move/pan + pinch zoom)
  // =========================
  function isEditorOpen(){
    return objEditor.style.display === "block" || textEditor.style.display === "block";
  }

  sv.addEventListener("pointermove", (e) => {
    // pinch zoom
    if (e.pointerType === "touch"){
      if (activeTouches.has(e.pointerId)){
        activeTouches.set(e.pointerId, {x:e.clientX, y:e.clientY});
      }
      if (pinchState && activeTouches.size >= 2){
        const ids = pinchState.ids.filter(id => activeTouches.has(id));
        if (ids.length < 2){
          pinchState = null;
        } else {
          const a = activeTouches.get(ids[0]);
          const b = activeTouches.get(ids[1]);
          const cx = (a.x + b.x)/2;
          const cy = (a.y + b.y)/2;
          const distNow = Math.hypot(a.x-b.x, a.y-b.y) || 1;
          const ratio = distNow / (pinchState.startDist || distNow);
          const newScale = clamp(pinchState.startScale * ratio, 20, 260);

          const {sx,sy} = clientToScreen(cx,cy);
          const {w,h} = size();
          cam.scale = newScale;
          cam.x = pinchState.anchor.wx - (sx - w/2)/cam.scale;
          cam.y = pinchState.anchor.wy - (h/2 - sy)/cam.scale;

          // cancel other interactions while pinching
          dragging = null;
          isPanning = false;
          panStart = null;

          saveToStorage();
          render();
          try{ e.preventDefault(); } catch {}
          return;
        }
      }
    }

    // regular pan/drag
    if (isPanning && panStart){
      const {sx,sy} = clientToScreen(e.clientX,e.clientY);
      const dx = sx - panStart.sx;
      const dy = sy - panStart.sy;
      cam.x = panStart.camX - dx / panStart.scale;
      cam.y = panStart.camY + dy / panStart.scale;
      saveToStorage();
      render();
      return;
    }

    if (dragging && dragging.pointerId === e.pointerId){
      const {sx,sy} = clientToScreen(e.clientX,e.clientY);
      const w = screenToWorld(sx,sy);
      const obj = getById(dragging.id);
      if (!obj) return;

      const nx = w.wx + (dragging.offX || 0);
      const ny = w.wy + (dragging.offY || 0);

      if (dragging.kind === "point"){
        if (obj.constraint?.type === "intersection") return;
        if (obj.constraint?.type === "on"){
          const parent = getById(obj.constraint.parentId);
          const poly = parent ? sampleObject(parent).filter(p=>Number.isFinite(p.x)&&Number.isFinite(p.y)) : null;
          if (poly && poly.length >= 2){
            const proj = polylineNearest(poly, {x:nx,y:ny});
            obj.x = proj.x; obj.y = proj.y; obj.constraint.t = proj.t;
          } else {
            obj.x = nx; obj.y = ny;
          }
        } else {
          obj.x = nx; obj.y = ny;
        }
      }

      if (dragging.kind === "text"){
        obj.x = nx; obj.y = ny;
      }

      saveToStorage();
      render();
      return;
    }
  });

  sv.addEventListener("pointerdown", (e) => {
    cancelFloatingTip();
    if (isEditorOpen()) return;

    // touch tracking for pinch
    if (e.pointerType === "touch"){
      activeTouches.set(e.pointerId, {x:e.clientX, y:e.clientY});
      try{ sv.setPointerCapture(e.pointerId); } catch {}

      if (activeTouches.size === 2){
        const ids = [...activeTouches.keys()];
        const a = activeTouches.get(ids[0]);
        const b = activeTouches.get(ids[1]);
        const cx = (a.x + b.x)/2;
        const cy = (a.y + b.y)/2;
        const {sx,sy} = clientToScreen(cx,cy);
        const anchor = screenToWorld(sx,sy);

        pushState();
        pinchState = {
          ids,
          startDist: Math.hypot(a.x-b.x, a.y-b.y) || 1,
          startScale: cam.scale,
          anchor: {wx: anchor.wx, wy: anchor.wy}
        };

        // cancel other interactions
        selected = null;
        dragging = null;
        isPanning = false;
        panStart = null;

        saveToStorage();
        render();
        try{ e.preventDefault(); } catch {}
        return;
      } else if (activeTouches.size < 2){
        pinchState = null;
      }
    } else {
      pinchState = null;
    }

    const {sx,sy} = clientToScreen(e.clientX,e.clientY);
    const w = screenToWorld(sx,sy);

    if (tool === "select"){
      const id = hitTest(w.wx,w.wy);
      if (id){
        selected = {id};
        const obj = getById(id);
        if (obj?.kind === "point"){
          if (!obj.constraint || obj.constraint.type !== "intersection"){
            pushState();
            dragging = { id, kind:"point", offX: obj.x - w.wx, offY: obj.y - w.wy, pointerId: e.pointerId };
            try{ sv.setPointerCapture(e.pointerId); } catch {}
          }
        } else if (obj?.kind === "text"){
          pushState();
          dragging = { id, kind:"text", offX: obj.x - w.wx, offY: obj.y - w.wy, pointerId: e.pointerId };
          try{ sv.setPointerCapture(e.pointerId); } catch {}
        } else {
          dragging = null;
        }
        isPanning = false;
        panStart = null;
      } else {
        selected = null;
        dragging = null;
        pushState();
        isPanning = true;
        panStart = { sx, sy, camX: cam.x, camY: cam.y, scale: cam.scale };
        try{ sv.setPointerCapture(e.pointerId); } catch {}
      }
      saveToStorage();
      render();
      return;
    }

    if (tool === "point"){
      // 1) intersection
      const hit = findNearestIntersectionCandidate(w.wx,w.wy);
      if (hit){
        pushState();
        const p = createIntersectionPoint(hit);
        selected = {id:p.id};
        saveToStorage();
        render();
        return;
      }
      // 2) on-object
      const id = hitTest(w.wx,w.wy);
      const obj = id ? getById(id) : null;
      if (obj && obj.kind !== "point" && obj.kind !== "text"){
        pushState();
        const p = createPointOnObject(obj.id, w.wx,w.wy);
        if (p){
          selected = {id:p.id};
          saveToStorage();
          render();
          return;
        }
      }
      // 3) free
      pushState();
      const p = ensurePointAt(w.wx,w.wy);
      selected = {id:p.id};
      saveToStorage();
      render();
      return;
    }

    if (tool === "segment"){
      pushState();
      const p = getOrCreatePointForClick(w.wx,w.wy);
      if (!segP1) segP1 = p.id;
      else {
        if (segP1 !== p.id) createSegment(segP1, p.id);
        segP1 = null;
      }
      selected = null;
      saveToStorage();
      render();
      return;
    }

    if (tool === "line"){
      pushState();
      const p = getOrCreatePointForClick(w.wx,w.wy);
      if (!lineP1) lineP1 = p.id;
      else {
        if (lineP1 !== p.id) createLine(lineP1, p.id);
        lineP1 = null;
      }
      selected = null;
      saveToStorage();
      render();
      return;
    }

    if (tool === "circle"){
      pushState();
      const p = getOrCreatePointForClick(w.wx,w.wy);
      if (!circleC) circleC = p.id;
      else {
        if (circleC !== p.id) createCircle(circleC, p.id);
        circleC = null;
      }
      selected = null;
      saveToStorage();
      render();
      return;
    }

    if (tool === "parabola"){
      pushState();
      if (!parabolaFocus){
        const p = getOrCreatePointForClick(w.wx,w.wy);
        parabolaFocus = p.id;
        saveToStorage();
        render();
        return;
      }
      const id = hitTest(w.wx,w.wy);
      const obj = id ? getById(id) : null;
      if (obj && (obj.kind === "line" || obj.kind === "segment")){
        const a = getById(obj.aId), b = getById(obj.bId);
        if (a && b) createParabola(parabolaFocus, a.id, b.id);
        parabolaFocus = null;
        parabolaD1 = null;
        selected = null;
        saveToStorage();
        render();
        return;
      }
      const p = getOrCreatePointForClick(w.wx,w.wy);
      if (!parabolaD1) parabolaD1 = p.id;
      else {
        if (parabolaD1 !== p.id) createParabola(parabolaFocus, parabolaD1, p.id);
        parabolaFocus = null;
        parabolaD1 = null;
      }
      selected = null;
      saveToStorage();
      render();
      return;
    }

    if (tool === "ellipse"){
      pushState();
      const p = getOrCreatePointForClick(w.wx,w.wy);
      if (!ellipseF1){ ellipseF1 = p.id; saveToStorage(); render(); return; }
      if (!ellipseF2){ ellipseF2 = p.id; saveToStorage(); render(); return; }
      createEllipse(ellipseF1, ellipseF2, p.id);
      ellipseF1 = null; ellipseF2 = null;
      selected = null;
      saveToStorage();
      render();
      return;
    }

    if (tool === "hyperbola"){
      pushState();
      const p = getOrCreatePointForClick(w.wx,w.wy);
      if (!hyperF1){ hyperF1 = p.id; saveToStorage(); render(); return; }
      if (!hyperF2){ hyperF2 = p.id; saveToStorage(); render(); return; }
      createHyperbola(hyperF1, hyperF2, p.id);
      hyperF1 = null; hyperF2 = null;
      selected = null;
      saveToStorage();
      render();
      return;
    }

    if (tool === "text"){
      pushState();
      const tx = createText(w.wx,w.wy, "");
      selected = {id: tx.id};
      saveToStorage();
      render();
      openTextEditor(tx.id);
      return;
    }
  });

  function endPointer(e){
    if (e.pointerType === "touch"){
      activeTouches.delete(e.pointerId);
      if (activeTouches.size < 2) pinchState = null;
    }
    if (dragging && dragging.pointerId === e.pointerId) dragging = null;
    isPanning = false;
    panStart = null;
    try{ sv.releasePointerCapture(e.pointerId); } catch {}
    saveToStorage();
    render();
  }

  sv.addEventListener("pointerup", endPointer);
  sv.addEventListener("pointercancel", endPointer);

  // =========================
  // Double click: edit
  // =========================
  sv.addEventListener("dblclick", (e) => {
    if (isEditorOpen()) return;
    const {sx,sy} = clientToScreen(e.clientX,e.clientY);
    const w = screenToWorld(sx,sy);
    const id = hitTest(w.wx,w.wy);
    if (!id) return;
    const obj = getById(id);
    if (!obj) return;
    selected = {id};
    saveToStorage();
    render();
    if (obj.kind === "text") openTextEditor(id);
    else openObjEditor(id);
  });

  // =========================
  // Enter key
  // =========================
  document.addEventListener("keydown", (e) => {
    if (e.key !== "Enter") return;
    if (objEditor.style.display === "block"){
      e.preventDefault();
      saveObjEditor();
      return;
    }
    if (textEditor.style.display === "block"){
      e.preventDefault();
      saveTextEditor();
      return;
    }
    if (selected?.id){
      const obj = getById(selected.id);
      if (!obj) return;
      e.preventDefault();
      if (obj.kind === "text") openTextEditor(obj.id);
      else openObjEditor(obj.id);
    }
  });

  // =========================
  // Init
  // =========================
  function bootstrap(){
    loadFromStorage();
    // ensure minimal state
    if (!Array.isArray(objects)) objects = [];

    // first render after layout
    syncUI();
    requestAnimationFrame(() => {
      render();
    });
  }

  // Resize observer
  const ro = new ResizeObserver(() => {
    render();
  });
  ro.observe($("work"));

  bootstrap();
})();
</script>

</body>
</html>
